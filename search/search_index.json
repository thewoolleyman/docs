{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the SAFE documentation site! This site contains all the documentation you'll need to quickly starting creating SAFE apps in F#. If you've not heard of SAFE before, please feel free to start with the introduction . Alternatively, you can immediately try out the quick start guide and tutorial, or simply browse through the documentation. If there's anything missing from here, please feel free to add the documentation directly (or supply an issue) to the GitHub repository . We hope you enjoy using SAFE as much as we do! The SAFE team.","title":"Home"},{"location":"component-azure/","text":"Azure in SAFE What is Azure? Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions. How does Azure integrate with SAFE? Azure provides a number of flexible services for SAFE applications, including (but not only): Hosting Services Azure comes with several ready-made hosting services, including App Service , which enables seamless hosting of web applications, including ASP.NET Core applications (which Saturn is built on top of). In addition, Azure supports a number of managed hosting services for Docker and Kubernetes , which work fantastically well with SAFE. Platform Services Azure comes with a large number of ready-made platform services that can dramatically lower the cost of developing bespoke systems, including: Compute services such as Azure Functions , for hosting F# code that can dynamically scale based on load, as well as Service Fabric or Virtual Machines . Storage services such as Azure Storage and Data Lake , for storing virtually limitless volumes of data in unstructured or structure form. Database services, including managed SQL Server , MySQL and Postgres , as well as CosmosDB for document and graph stores, Redis and more. Messaging services including Queues , Service Bus and Event Hub . Analytical services such as Stream Analytics , Databricks , Machine Learning and Analysis Services . Security services such as Key Vault and Active Directory . Many of the above services have ready-made SDKs that can be run on .NET and therefore from F#. In addition, the Azure Storage Type Provider provides unparallel ease of access to Azure Storage Blobs, Queues and Tables from F# (currently not yet supported on .NET Core) .","title":"Learn about Azure"},{"location":"component-azure/#azure-in-safe","text":"","title":"Azure in SAFE"},{"location":"component-azure/#what-is-azure","text":"Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.","title":"What is Azure?"},{"location":"component-azure/#how-does-azure-integrate-with-safe","text":"Azure provides a number of flexible services for SAFE applications, including (but not only):","title":"How does Azure integrate with SAFE?"},{"location":"component-azure/#hosting-services","text":"Azure comes with several ready-made hosting services, including App Service , which enables seamless hosting of web applications, including ASP.NET Core applications (which Saturn is built on top of). In addition, Azure supports a number of managed hosting services for Docker and Kubernetes , which work fantastically well with SAFE.","title":"Hosting Services"},{"location":"component-azure/#platform-services","text":"Azure comes with a large number of ready-made platform services that can dramatically lower the cost of developing bespoke systems, including: Compute services such as Azure Functions , for hosting F# code that can dynamically scale based on load, as well as Service Fabric or Virtual Machines . Storage services such as Azure Storage and Data Lake , for storing virtually limitless volumes of data in unstructured or structure form. Database services, including managed SQL Server , MySQL and Postgres , as well as CosmosDB for document and graph stores, Redis and more. Messaging services including Queues , Service Bus and Event Hub . Analytical services such as Stream Analytics , Databricks , Machine Learning and Analysis Services . Security services such as Key Vault and Active Directory . Many of the above services have ready-made SDKs that can be run on .NET and therefore from F#. In addition, the Azure Storage Type Provider provides unparallel ease of access to Azure Storage Blobs, Queues and Tables from F# (currently not yet supported on .NET Core) .","title":"Platform Services"},{"location":"component-elmish/","text":"Elmish in SAFE What is Elmish? Elmish is a library for building single page applications in F# applications, following the model-view-update architecture made famous by Elm . The following diagram is a simplified, high-level view of the MVU pattern. Model in this case refers to your application's state, with Update and View the two functions that handle the flow of messaging. If you wish to read more, we also recommend reading the excellent Elmish Book . stateDiagram-v2 [*] --> Update : Current model and Command Update --> View : Updated model View --> [*] : HTML rendered on page How does Elmish integrate with SAFE? Elmish is the library used to build the front-end application in SAFE and that application is compiled to Javascript by Fable to run in the browser. The SAFE Stack template comes pre-bundled with the Elmish React module, which (as the name suggests) uses the React library to handle the heavy lifting of modifyng the DOM in an efficient way. This allow us to use the pure functional style of the MVU pattern whilst still retaining the ability to have a highly performant user interface. Because Elmish works alongside React, it is possible to use the vast number of available React components from the Javascript ecosystem within our Elmish applications. This conceptual diagram illustrates how the different pieces of Elmish, React and Fable fit together to make the front-end part of your SAFE application which runs in the browser. flowchart RL subgraph Browser React(React - Handles DOM updates) Fable(Fable - Translates F# to JS) ER(Elmish React - Elmish to React bridge) Elmish(Elmish - Provides MVU abstractions) You(Your F# domain logic) You --- Elmish --- ER --- Fable --- React end Learn Elmish The official Elmish docs The Elmish Book","title":"Learn about Elmish"},{"location":"component-elmish/#elmish-in-safe","text":"","title":"Elmish in SAFE"},{"location":"component-elmish/#what-is-elmish","text":"Elmish is a library for building single page applications in F# applications, following the model-view-update architecture made famous by Elm . The following diagram is a simplified, high-level view of the MVU pattern. Model in this case refers to your application's state, with Update and View the two functions that handle the flow of messaging. If you wish to read more, we also recommend reading the excellent Elmish Book . stateDiagram-v2 [*] --> Update : Current model and Command Update --> View : Updated model View --> [*] : HTML rendered on page","title":"What is Elmish?"},{"location":"component-elmish/#how-does-elmish-integrate-with-safe","text":"Elmish is the library used to build the front-end application in SAFE and that application is compiled to Javascript by Fable to run in the browser. The SAFE Stack template comes pre-bundled with the Elmish React module, which (as the name suggests) uses the React library to handle the heavy lifting of modifyng the DOM in an efficient way. This allow us to use the pure functional style of the MVU pattern whilst still retaining the ability to have a highly performant user interface. Because Elmish works alongside React, it is possible to use the vast number of available React components from the Javascript ecosystem within our Elmish applications. This conceptual diagram illustrates how the different pieces of Elmish, React and Fable fit together to make the front-end part of your SAFE application which runs in the browser. flowchart RL subgraph Browser React(React - Handles DOM updates) Fable(Fable - Translates F# to JS) ER(Elmish React - Elmish to React bridge) Elmish(Elmish - Provides MVU abstractions) You(Your F# domain logic) You --- Elmish --- ER --- Fable --- React end","title":"How does Elmish integrate with SAFE?"},{"location":"component-elmish/#learn-elmish","text":"The official Elmish docs The Elmish Book","title":"Learn Elmish"},{"location":"component-fable/","text":"Fable in SAFE What is Fable? Fable is an F#-to-JavaScript (JS) compiler powered by Babel , designed to produce readable and standard JS code. Fable brings all the power of F# to the JS ecosystem, with support for most of the F# core library as well as the most commonly used .NET APIs. How does Fable integrate with SAFE? Fable is much more than an F#-to-JS compiler - it also provides rich integration with the JS ecosystem which means that you can use JS libraries from F# (and vice versa) as well as make use of standard JS tools. It's important to understand the Fable is not simply an application that takes in F# and emits JS - instead, the dotnet fable application emits an intermediary file (a Babel Abstract Syntax Tree), which in turn is converted by webpack into well-written JS. Fable and webpack Fable is actually not a .NET Core tool, but is an NPM package that is hosted within the context of webpack , a powerful bundling tool. You'll normally see a webpack.config.js file in the client folder of your SAFE applications. This file tells webpack how to emit JS from F# files and hosts the Fable webpack plugin, fable-loader . Using webpack also provides many advantages - for example, we as developers can control how JS is rendered through standard tools that exist in the JS ecosystem, whilst also using features such as Hot Module replacement and Source Maps. Creating a webpack config file isn't the easiest thing in the world, so the SAFE Template already has one pre-built that contains the basics to get you up and running immediately. Learn more about Fable here .","title":"Learn about Fable"},{"location":"component-fable/#fable-in-safe","text":"","title":"Fable in SAFE"},{"location":"component-fable/#what-is-fable","text":"Fable is an F#-to-JavaScript (JS) compiler powered by Babel , designed to produce readable and standard JS code. Fable brings all the power of F# to the JS ecosystem, with support for most of the F# core library as well as the most commonly used .NET APIs.","title":"What is Fable?"},{"location":"component-fable/#how-does-fable-integrate-with-safe","text":"Fable is much more than an F#-to-JS compiler - it also provides rich integration with the JS ecosystem which means that you can use JS libraries from F# (and vice versa) as well as make use of standard JS tools. It's important to understand the Fable is not simply an application that takes in F# and emits JS - instead, the dotnet fable application emits an intermediary file (a Babel Abstract Syntax Tree), which in turn is converted by webpack into well-written JS.","title":"How does Fable integrate with SAFE?"},{"location":"component-fable/#fable-and-webpack","text":"Fable is actually not a .NET Core tool, but is an NPM package that is hosted within the context of webpack , a powerful bundling tool. You'll normally see a webpack.config.js file in the client folder of your SAFE applications. This file tells webpack how to emit JS from F# files and hosts the Fable webpack plugin, fable-loader . Using webpack also provides many advantages - for example, we as developers can control how JS is rendered through standard tools that exist in the JS ecosystem, whilst also using features such as Hot Module replacement and Source Maps. Creating a webpack config file isn't the easiest thing in the world, so the SAFE Template already has one pre-built that contains the basics to get you up and running immediately. Learn more about Fable here .","title":"Fable and webpack"},{"location":"component-saturn/","text":"Saturn in SAFE Saturn is a web development library written in F# which allows you to easily create both server-side MVC applications as well as web APIs. It runs on top of two other components: Giraffe , an F#-specific library for writing functional-first web applications. Microsoft's ASP.NET Core . Saturn, via Giraffe, provides very good integration with other ASP.NET Core components such as authentication. Many of Saturn's components and concepts will seem familiar to those of us with experience of other web frameworks such as Ruby on Rails, Python\u2019s Django or especially Elixir's Phoenix . How does Saturn integrate with SAFE? Saturn provides the ability to drive your SAFE applications from the server. It enables: Routing and hosting of your server-side APIs through a set of simple-to-use abstractions. Hosting of your client-side assets, such as HTML, CSS and JavaScript generated by Fable. Other cross cutting concerns e.g. authentication etc. It also integrates with SAFE to allow seamless sharing of types and functions, since Fable will convert most F# into JavaScript. In addition, you can seamless transport data between client and server using either the Fable.JSON or Fable.Remoting libraries, both of which have support for Saturn. You can read more about this here . flowchart TB outputs>JSON, HTML etc.] subgraph host[.NET Core Host] saturn[Saturn - Routers, Controllers etc.] giraffe[Giraffe - Core F# abstractions] aspnet[ASP.NET Core - HTTP Context etc.] kestrel[Kestrel - Web Server] saturn --- giraffe --- aspnet --- kestrel end data[(Transactional Data e.g. SQL)] content>Static Content e.g. HTML, CSS, Javascript] outputs -- serves --- host kestrel -- reads --- data kestrel -- reads --- content Learn more about Saturn here .","title":"Learn about Saturn"},{"location":"component-saturn/#saturn-in-safe","text":"Saturn is a web development library written in F# which allows you to easily create both server-side MVC applications as well as web APIs. It runs on top of two other components: Giraffe , an F#-specific library for writing functional-first web applications. Microsoft's ASP.NET Core . Saturn, via Giraffe, provides very good integration with other ASP.NET Core components such as authentication. Many of Saturn's components and concepts will seem familiar to those of us with experience of other web frameworks such as Ruby on Rails, Python\u2019s Django or especially Elixir's Phoenix .","title":"Saturn in SAFE"},{"location":"component-saturn/#how-does-saturn-integrate-with-safe","text":"Saturn provides the ability to drive your SAFE applications from the server. It enables: Routing and hosting of your server-side APIs through a set of simple-to-use abstractions. Hosting of your client-side assets, such as HTML, CSS and JavaScript generated by Fable. Other cross cutting concerns e.g. authentication etc. It also integrates with SAFE to allow seamless sharing of types and functions, since Fable will convert most F# into JavaScript. In addition, you can seamless transport data between client and server using either the Fable.JSON or Fable.Remoting libraries, both of which have support for Saturn. You can read more about this here . flowchart TB outputs>JSON, HTML etc.] subgraph host[.NET Core Host] saturn[Saturn - Routers, Controllers etc.] giraffe[Giraffe - Core F# abstractions] aspnet[ASP.NET Core - HTTP Context etc.] kestrel[Kestrel - Web Server] saturn --- giraffe --- aspnet --- kestrel end data[(Transactional Data e.g. SQL)] content>Static Content e.g. HTML, CSS, Javascript] outputs -- serves --- host kestrel -- reads --- data kestrel -- reads --- content Learn more about Saturn here .","title":"How does Saturn integrate with SAFE?"},{"location":"events/","text":"Upcoming events Title Type Date Location Who Cost Past events 2019 Title Type Date Location Who Cost SAFE Stack - The Pit of Success for Functional Web Programming User Group Jan 22 2019 Dresden, Germany Compositional IT Free SAFE Stack - The Pit of Success for Functional Web Programming User Group Jan 23 2019 Prague, Czech Republic Compositional IT Free Web development with SAFE Stack Conference Jan 26 2019 Minsk, Belarus Mikhail Smal Paid Hacking F# in JS ecosystem Conference Feb 2 2019 Brussels, Belgium Krzysztof Cieslak Free Reinventing MVC pattern for web programming with F# Conference Feb 2 2019 Brussels, Belgium Krzysztof Cieslak Free SAFE Stack - The Pit of Success for Functional Web Programming User Group Feb 12 2019 Osnabr\u00fcck, Germany Compositional IT Free SAFE web development with F# User Group Mar 28 2019 Prague, Czech Republic Mikhail Smal Free SAFE Stack: Current State Conference April 4-5 2019 London, UK Tomasz Heimowski Paid Workshop: Up and Running with the SAFE Stack Conference April 4-5 2019 London, UK Compositional IT Paid The Pit of Success with SAFE Stack User Group April 11 2019 Berlin, Germany Isaac Abraham Free Workshop: Hands on with F# Conference workshop April 27 2019 Berlin, Germany Isaac Abraham Free Workshop: SAFE Web development with F# Conference May 14 2019 Vilnius, Lithuania Mikhail Smal Paid Write Your Own Domain Specific Language with F# Conference May 15-16 2019 Vilnius, Lithuania Mikhail Smal Paid Full Stack Web in F# Conference June 8 2019 Minsk, Belarus Tomasz Heimowski Paid Write Your Own Domain Specific Language with F# Conference Jun 18 2019 Oslo, Norway Mikhail Smal Paid FableConf Conference Sep 6-7 2019 Antwerp, Belgium Paid Functional Web Programming with the SAFE Stack Training Sep 12-13 2019 London, UK Isaac Abraham / Compositional IT Paid Hands-on with SAFE Stack Conference Oct 17-18 2019 C\u00e1diz, Spain Tomasz Heimowski Paid Full Stack Web in F# Conference November 6-8 2019 Malm\u00f6, Sweden Tomasz Heimowski Paid 2018 Title Type Date Location Who Cost SAFE apps with F# web stack Conference Feb 23 2018 Krak\u00f3w, Poland Tomasz Heimowski Paid SAFE apps with F# web stack Conference April 5 2018 London, UK Tomasz Heimowski Paid SAFE Stack Workshop User Group Aug 22 2018 Bristol, UK Compositional IT Free SAFE apps with F# web stack Conference Sep 21 2018 Gda\u0144sk, Poland Tomasz Heimowski Free SAFE Stack: Functional Web Programming in .NET Conference Sep 22 2018 Cambridge, UK Compositional IT Free F# Full Stack with SAFE Training Sep 26 2018 San Francisco, USA Lambda Factory Paid SAFE Hackday Training Oct 6 2018 Birmingham, UK Ian Russel Free Cloud Programming with F# Training Oct 25 2018 Berlin, Germany Compositional IT Paid FableConf / RemmiDemmi Conference Oct 26/27 2018 Berlin, Germany Paid F# development with SAFE Training Nov 7 2018 Vienna, Austria Lambda Factory Paid","title":"Events"},{"location":"events/#upcoming-events","text":"Title Type Date Location Who Cost","title":"Upcoming events"},{"location":"events/#past-events","text":"","title":"Past events"},{"location":"events/#2019","text":"Title Type Date Location Who Cost SAFE Stack - The Pit of Success for Functional Web Programming User Group Jan 22 2019 Dresden, Germany Compositional IT Free SAFE Stack - The Pit of Success for Functional Web Programming User Group Jan 23 2019 Prague, Czech Republic Compositional IT Free Web development with SAFE Stack Conference Jan 26 2019 Minsk, Belarus Mikhail Smal Paid Hacking F# in JS ecosystem Conference Feb 2 2019 Brussels, Belgium Krzysztof Cieslak Free Reinventing MVC pattern for web programming with F# Conference Feb 2 2019 Brussels, Belgium Krzysztof Cieslak Free SAFE Stack - The Pit of Success for Functional Web Programming User Group Feb 12 2019 Osnabr\u00fcck, Germany Compositional IT Free SAFE web development with F# User Group Mar 28 2019 Prague, Czech Republic Mikhail Smal Free SAFE Stack: Current State Conference April 4-5 2019 London, UK Tomasz Heimowski Paid Workshop: Up and Running with the SAFE Stack Conference April 4-5 2019 London, UK Compositional IT Paid The Pit of Success with SAFE Stack User Group April 11 2019 Berlin, Germany Isaac Abraham Free Workshop: Hands on with F# Conference workshop April 27 2019 Berlin, Germany Isaac Abraham Free Workshop: SAFE Web development with F# Conference May 14 2019 Vilnius, Lithuania Mikhail Smal Paid Write Your Own Domain Specific Language with F# Conference May 15-16 2019 Vilnius, Lithuania Mikhail Smal Paid Full Stack Web in F# Conference June 8 2019 Minsk, Belarus Tomasz Heimowski Paid Write Your Own Domain Specific Language with F# Conference Jun 18 2019 Oslo, Norway Mikhail Smal Paid FableConf Conference Sep 6-7 2019 Antwerp, Belgium Paid Functional Web Programming with the SAFE Stack Training Sep 12-13 2019 London, UK Isaac Abraham / Compositional IT Paid Hands-on with SAFE Stack Conference Oct 17-18 2019 C\u00e1diz, Spain Tomasz Heimowski Paid Full Stack Web in F# Conference November 6-8 2019 Malm\u00f6, Sweden Tomasz Heimowski Paid","title":"2019"},{"location":"events/#2018","text":"Title Type Date Location Who Cost SAFE apps with F# web stack Conference Feb 23 2018 Krak\u00f3w, Poland Tomasz Heimowski Paid SAFE apps with F# web stack Conference April 5 2018 London, UK Tomasz Heimowski Paid SAFE Stack Workshop User Group Aug 22 2018 Bristol, UK Compositional IT Free SAFE apps with F# web stack Conference Sep 21 2018 Gda\u0144sk, Poland Tomasz Heimowski Free SAFE Stack: Functional Web Programming in .NET Conference Sep 22 2018 Cambridge, UK Compositional IT Free F# Full Stack with SAFE Training Sep 26 2018 San Francisco, USA Lambda Factory Paid SAFE Hackday Training Oct 6 2018 Birmingham, UK Ian Russel Free Cloud Programming with F# Training Oct 25 2018 Berlin, Germany Compositional IT Paid FableConf / RemmiDemmi Conference Oct 26/27 2018 Berlin, Germany Paid F# development with SAFE Training Nov 7 2018 Vienna, Austria Lambda Factory Paid","title":"2018"},{"location":"faq-build/","text":"This page explains the key differences that you should be aware of between running SAFE applications in development and production. Developing SAFE applications The SAFE template is geared towards a streamlined development process. Firstly, it contains a FAKE build script which you can use to quickly download dependencies, as well as build and run both the client and server on your machine. The development process uses two web servers running in tandem: The \"back-end\" .NET web server which hosts your API endpoints and another for server-generated content. This uses Kestrel on ASP.NET out of the box (although you can opt for other options ). A \"front-end\" web server which hosts your Fable application. The SAFE template uses the Webpack Dev Server for this. flowchart LR subgraph c[localhost:8080] js>Fable-compiled JS] webpack(Webpack dev server) js -- hot module replacement --- webpack end subgraph s[localhost:8085] dotnet(dotnet watch run) saturn(Saturn on Kestrel) saturn --- dotnet end c -- /api redirect --> s The backend build makes use of dotnet watch to allow you to make changes to your server-side application and have the server automatically restart with the latest changes. Since your backend applications will typically be stateless, this permits a rapid development workflow. On the client side, your code is compiled using webpack. This provides many benefits for working with Javascript, such as minification and bundling, as well as hot module replacement , a feature made possible when using the webpack dev server. This means that you can continually make changes to your client application code and can rapidly see the results reflected in your browser, without the need to fully reload the application. Webpack Dev Server It's important to note that the webpack dev server is configured to automatically route traffic intended for api/* routes to the backend web server. This simulates how a SAFE application might work in a production environment, with both client and server assets served from a single web server. This also allows you to not worry about ports and hosts for your backend server in your client code, or CORS issues. Running SAFE applications in production In a production environment, you won't typically use the webpack dev server. Instead, it's more common to use webpack as a one-off compiler step to create your bundled Javascript from your Fable app (plus dependencies), and then deploy this along with your backend web server which also hosts that content directly. For example, you can use Saturn to host the static content required by the application e.g. HTML, JS and CSS files etc. as well as your backend APIs. This fits very well with standard CI / CD processes, as a build step in your FAKE script or VSTS / AppVeyor / Travis step etc. flowchart BT subgraph dest[Web server e.g. https://contoso.com] saturn(Saturn myapp.dll) db[(transactional data)] assets>static assets] saturn -- api/customers --- db saturn -- bundle.js --- assets end subgraph src[CI/CD Server] exec>deployment script] webpack(webpack) dotnet(dotnet publish) source(F# source code) exec -- bundle.js --- webpack exec -- myapp.dll --- dotnet webpack --- source dotnet --- source end src -- file copy --> dest Client asset hosting alternatives Rather than hosting your client-side content and application inside your web server, you can opt to host your static content from some other service that supports hosting of HTTP content, such as Azure Blobs, or a content hosting service. In such a case, you'll need to consider how to route traffic to your back-end API from your client application (as they are hosted on different domains), as well as handle any potential CORS issues.","title":"Moving from dev to prod"},{"location":"faq-build/#developing-safe-applications","text":"The SAFE template is geared towards a streamlined development process. Firstly, it contains a FAKE build script which you can use to quickly download dependencies, as well as build and run both the client and server on your machine. The development process uses two web servers running in tandem: The \"back-end\" .NET web server which hosts your API endpoints and another for server-generated content. This uses Kestrel on ASP.NET out of the box (although you can opt for other options ). A \"front-end\" web server which hosts your Fable application. The SAFE template uses the Webpack Dev Server for this. flowchart LR subgraph c[localhost:8080] js>Fable-compiled JS] webpack(Webpack dev server) js -- hot module replacement --- webpack end subgraph s[localhost:8085] dotnet(dotnet watch run) saturn(Saturn on Kestrel) saturn --- dotnet end c -- /api redirect --> s The backend build makes use of dotnet watch to allow you to make changes to your server-side application and have the server automatically restart with the latest changes. Since your backend applications will typically be stateless, this permits a rapid development workflow. On the client side, your code is compiled using webpack. This provides many benefits for working with Javascript, such as minification and bundling, as well as hot module replacement , a feature made possible when using the webpack dev server. This means that you can continually make changes to your client application code and can rapidly see the results reflected in your browser, without the need to fully reload the application.","title":"Developing SAFE applications"},{"location":"faq-build/#webpack-dev-server","text":"It's important to note that the webpack dev server is configured to automatically route traffic intended for api/* routes to the backend web server. This simulates how a SAFE application might work in a production environment, with both client and server assets served from a single web server. This also allows you to not worry about ports and hosts for your backend server in your client code, or CORS issues.","title":"Webpack Dev Server"},{"location":"faq-build/#running-safe-applications-in-production","text":"In a production environment, you won't typically use the webpack dev server. Instead, it's more common to use webpack as a one-off compiler step to create your bundled Javascript from your Fable app (plus dependencies), and then deploy this along with your backend web server which also hosts that content directly. For example, you can use Saturn to host the static content required by the application e.g. HTML, JS and CSS files etc. as well as your backend APIs. This fits very well with standard CI / CD processes, as a build step in your FAKE script or VSTS / AppVeyor / Travis step etc. flowchart BT subgraph dest[Web server e.g. https://contoso.com] saturn(Saturn myapp.dll) db[(transactional data)] assets>static assets] saturn -- api/customers --- db saturn -- bundle.js --- assets end subgraph src[CI/CD Server] exec>deployment script] webpack(webpack) dotnet(dotnet publish) source(F# source code) exec -- bundle.js --- webpack exec -- myapp.dll --- dotnet webpack --- source dotnet --- source end src -- file copy --> dest","title":"Running SAFE applications in production"},{"location":"faq-build/#client-asset-hosting-alternatives","text":"Rather than hosting your client-side content and application inside your web server, you can opt to host your static content from some other service that supports hosting of HTTP content, such as Azure Blobs, or a content hosting service. In such a case, you'll need to consider how to route traffic to your back-end API from your client application (as they are hosted on different domains), as well as handle any potential CORS issues.","title":"Client asset hosting alternatives"},{"location":"faq-troubleshooting/","text":"Getting Started Diagnostics SocketProtocolError in Debug Console You may see the following SocketProtocolError message in the Debug Console once you have started your SAFE application. WebSocket connection to 'ws://localhost:8000/socketcluster/' failed: Error during WebSocket handshake: Unexpected response code: 404 Whilst these messages can be safely ignored, you can eliminate them by installing Redux Dev Tools in the launched Chrome instance as described in the debugging prerequisites section. Debugging in VS Code Node Process does not stop after stopping the debugger VS Code does not kill the Fable process when you stop the debugger, leaving it running as a \"zombie\". In such a case, you will have to explicitly kill the process otherwise it will hold onto port 8080 and prevent you starting new instances. This should be easily doable by sending Ctrl+C in the Terminal window in VS Code for Watch Client task. Tracked here . Chrome opens to a blank window Occasionally, VS Code will open Chrome before the Client has started. In this case, you will be presented with a blank screen until the client starts. Depending on the order in which compilation occurs, VS Code may launch the web browser before the server has started. If this occurs, you may need to refresh the browser once the server is fully initialised. Fable JavaScript bundle size A project created from SAFE template might issue the following warning from Webpack upon building the JavaScript bundle: WARNING in entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance. We're striving to optimise the bundle size, however with a number of different options and dependencies it's not that easy to stay below the Webpack recommended limit. To minimize the bundle size in your project you can try restricting browser compatibility by modifying the Babel Preset targets for Browserslist and thus using less polyfills. For more info, see this issue .","title":"Troubleshooting"},{"location":"faq-troubleshooting/#getting-started","text":"","title":"Getting Started"},{"location":"faq-troubleshooting/#diagnostics","text":"","title":"Diagnostics"},{"location":"faq-troubleshooting/#socketprotocolerror-in-debug-console","text":"You may see the following SocketProtocolError message in the Debug Console once you have started your SAFE application. WebSocket connection to 'ws://localhost:8000/socketcluster/' failed: Error during WebSocket handshake: Unexpected response code: 404 Whilst these messages can be safely ignored, you can eliminate them by installing Redux Dev Tools in the launched Chrome instance as described in the debugging prerequisites section.","title":"SocketProtocolError in Debug Console"},{"location":"faq-troubleshooting/#debugging-in-vs-code","text":"","title":"Debugging in VS Code"},{"location":"faq-troubleshooting/#node-process-does-not-stop-after-stopping-the-debugger","text":"VS Code does not kill the Fable process when you stop the debugger, leaving it running as a \"zombie\". In such a case, you will have to explicitly kill the process otherwise it will hold onto port 8080 and prevent you starting new instances. This should be easily doable by sending Ctrl+C in the Terminal window in VS Code for Watch Client task. Tracked here .","title":"Node Process does not stop after stopping the debugger"},{"location":"faq-troubleshooting/#chrome-opens-to-a-blank-window","text":"Occasionally, VS Code will open Chrome before the Client has started. In this case, you will be presented with a blank screen until the client starts. Depending on the order in which compilation occurs, VS Code may launch the web browser before the server has started. If this occurs, you may need to refresh the browser once the server is fully initialised.","title":"Chrome opens to a blank window"},{"location":"faq-troubleshooting/#fable","text":"","title":"Fable"},{"location":"faq-troubleshooting/#javascript-bundle-size","text":"A project created from SAFE template might issue the following warning from Webpack upon building the JavaScript bundle: WARNING in entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance. We're striving to optimise the bundle size, however with a number of different options and dependencies it's not that easy to stay below the Webpack recommended limit. To minimize the bundle size in your project you can try restricting browser compatibility by modifying the Babel Preset targets for Browserslist and thus using less polyfills. For more info, see this issue .","title":"JavaScript bundle size"},{"location":"feature-azurefunctions/","text":"Going serverless with SAFE With SAFE-Stack you can easily take advantage of serverless computing via Azure Functions . With Functions-As-A-Service (FAAS) you can focus on building your business logic and don't need to worry about provisioning and maintaining servers (hence \"serverless\"). Azure Functions provide a managed compute platform with high reliability. If you use a \"consumption plan\" it scales on demand and you only get billed for the actual runtime of your code. Potential use cases For SAFE apps we see various use cases for FAAS: Running recurring jobs to create statistics or maintenance actions via timer triggers Running jobs that can be processed async like creating accountings or sending email Command processing in CQRS apps via message queues or HTTP triggers Editing Functions in the Azure Portal The Azure Portal allows you to create and edit Functions and their source code via an online editor. For a short test go to the portal, click the \"New\" button and search for \"Function App\". Click through the wizard to create a new Function App. Open the app when it's created and add a new function. Pick \"Timer\" as scenario and F# as language. Replace the contents of function.json with: { \"bindings\": [ { \"name\": \"myTimer\", \"type\": \"timerTrigger\", \"direction\": \"in\", \"schedule\": \"0 * * * * *\" } ], \"disabled\": false } and replace the run.fsx with the following F# code: open System let minutesSince ( d : DateTime ) = ( DateTime . Now - d ). TotalMinutes let run ( myTimer : TimerInfo , log : TraceWriter ) = let meetupStart = new DateTime ( 2017 , 11 , 8 , 19 , 0 , 0 ) minutesSince meetupStart |> int |> sprintf \"Our meetup has been running for %d minutes\" |> log . Info Now observe the logs to see that the function runs every minute and outputs the message about the meetup duration. While it seems very convenient, the online editor should only be used for testing and prototyping. In SAFE-Stack you usually benefit from reusing your domain model at various places see Client/Server - so we recommend to use \"precompiled Azure Functions\" as described below. Deployment In SAFE-Stack scenarios we recommend all deployments should be automated. Here, we discuss two options for deploying your functions apps into Azure. Azure Functions Core Tools In the case of Function Apps the excellent Azure Functions Core Tools can be used. If you use core tools version 2 then the following should be added to your build/deploy script: dotnet publish - c Release func azure functionapp publish [ FunctionApp Name ] This will compile your Function App in release mode and push it to the Azure portal. In the case of a CI server etc., you will need to install the Functions Core Tools on the server and once per functions app log into the CI machine and explicitly authenticate it manually (see the Functions Core Tools docs). HTTPS Upload Since Azure Functions sits on top of Azure App Service, the same mechanisms for deployment there also exist here. In this case, you can use the exact same HTTPS upload capabilities of the App Service to upload a zip of your functions app into your Functions app. The standard SAFE Template can generate this for you for the core SAFE application as part of the FAKE script; the exact same mechanism can be utilised for your functions app. As per the standard App Service, HTTPS upload uses a user/pass supplied in the header of the zip which is PUT into the functions app. This user / pass can be taken from the App Service in the Azure Portal directly, or extracted during deployment of your ARM template (as per the FAKE script does for the App Service).","title":"Working with Azure functions"},{"location":"feature-azurefunctions/#going-serverless-with-safe","text":"With SAFE-Stack you can easily take advantage of serverless computing via Azure Functions . With Functions-As-A-Service (FAAS) you can focus on building your business logic and don't need to worry about provisioning and maintaining servers (hence \"serverless\"). Azure Functions provide a managed compute platform with high reliability. If you use a \"consumption plan\" it scales on demand and you only get billed for the actual runtime of your code.","title":"Going serverless with SAFE"},{"location":"feature-azurefunctions/#potential-use-cases","text":"For SAFE apps we see various use cases for FAAS: Running recurring jobs to create statistics or maintenance actions via timer triggers Running jobs that can be processed async like creating accountings or sending email Command processing in CQRS apps via message queues or HTTP triggers","title":"Potential use cases"},{"location":"feature-azurefunctions/#editing-functions-in-the-azure-portal","text":"The Azure Portal allows you to create and edit Functions and their source code via an online editor. For a short test go to the portal, click the \"New\" button and search for \"Function App\". Click through the wizard to create a new Function App. Open the app when it's created and add a new function. Pick \"Timer\" as scenario and F# as language. Replace the contents of function.json with: { \"bindings\": [ { \"name\": \"myTimer\", \"type\": \"timerTrigger\", \"direction\": \"in\", \"schedule\": \"0 * * * * *\" } ], \"disabled\": false } and replace the run.fsx with the following F# code: open System let minutesSince ( d : DateTime ) = ( DateTime . Now - d ). TotalMinutes let run ( myTimer : TimerInfo , log : TraceWriter ) = let meetupStart = new DateTime ( 2017 , 11 , 8 , 19 , 0 , 0 ) minutesSince meetupStart |> int |> sprintf \"Our meetup has been running for %d minutes\" |> log . Info Now observe the logs to see that the function runs every minute and outputs the message about the meetup duration. While it seems very convenient, the online editor should only be used for testing and prototyping. In SAFE-Stack you usually benefit from reusing your domain model at various places see Client/Server - so we recommend to use \"precompiled Azure Functions\" as described below.","title":"Editing Functions in the Azure Portal"},{"location":"feature-azurefunctions/#deployment","text":"In SAFE-Stack scenarios we recommend all deployments should be automated. Here, we discuss two options for deploying your functions apps into Azure.","title":"Deployment"},{"location":"feature-azurefunctions/#azure-functions-core-tools","text":"In the case of Function Apps the excellent Azure Functions Core Tools can be used. If you use core tools version 2 then the following should be added to your build/deploy script: dotnet publish - c Release func azure functionapp publish [ FunctionApp Name ] This will compile your Function App in release mode and push it to the Azure portal. In the case of a CI server etc., you will need to install the Functions Core Tools on the server and once per functions app log into the CI machine and explicitly authenticate it manually (see the Functions Core Tools docs).","title":"Azure Functions Core Tools"},{"location":"feature-azurefunctions/#https-upload","text":"Since Azure Functions sits on top of Azure App Service, the same mechanisms for deployment there also exist here. In this case, you can use the exact same HTTPS upload capabilities of the App Service to upload a zip of your functions app into your Functions app. The standard SAFE Template can generate this for you for the core SAFE application as part of the FAKE script; the exact same mechanism can be utilised for your functions app. As per the standard App Service, HTTPS upload uses a user/pass supplied in the header of the zip which is PUT into the functions app. This user / pass can be taken from the App Service in the Azure Portal directly, or extracted during deployment of your ARM template (as per the FAKE script does for the App Service).","title":"HTTPS Upload"},{"location":"feature-clientserver-basics/","text":"Sharing Types Sharing your domain types and contracts between client and server is extremely simple. Thanks to Fable's excellent F# transpilation into Javascript, you can use all standard F# language features such as Records, Tuples and Discriminated Unions without worry. To share types across both your client and server project, first create a file in your repository called e.g Shared.fs . Then, create types in the file as needed e.g type Customer = { Id : int ; Name : string } Reference this file from your server project. You can now reference those types on the server. <Project Sdk= \"Microsoft.NET.Sdk\" > ... <ItemGroup> <Compile Include= \"../Shared/Shared.fs\" /> </ItemGroup> ... </Project> Finally, reference this file in your client project (as above). You can now reference those types on the client; Fable will automatically convert your F# types into Javascript in the background. Sharing Behaviour You can also share behaviour using the same mechanism at that for sharing types. This is extremely useful for e.g shared validation or business logic that needs to occur on both client and server. Fable will translate your functions into native Javascript, and will even translate many calls to the .NET base class library into corresponding Javascript! This allows you to compile your domain model and domain logic to many many different targets including: ASP.NET Core (via Saturn) Azure Functions Javascript that runs in the browser Javascript that runs on mobile devices with React Native . Raspberry Pi (via .NET Core) You can read more about this on the Fable website .","title":"Sharing Types and Code"},{"location":"feature-clientserver-basics/#sharing-types","text":"Sharing your domain types and contracts between client and server is extremely simple. Thanks to Fable's excellent F# transpilation into Javascript, you can use all standard F# language features such as Records, Tuples and Discriminated Unions without worry. To share types across both your client and server project, first create a file in your repository called e.g Shared.fs . Then, create types in the file as needed e.g type Customer = { Id : int ; Name : string } Reference this file from your server project. You can now reference those types on the server. <Project Sdk= \"Microsoft.NET.Sdk\" > ... <ItemGroup> <Compile Include= \"../Shared/Shared.fs\" /> </ItemGroup> ... </Project> Finally, reference this file in your client project (as above). You can now reference those types on the client; Fable will automatically convert your F# types into Javascript in the background.","title":"Sharing Types"},{"location":"feature-clientserver-basics/#sharing-behaviour","text":"You can also share behaviour using the same mechanism at that for sharing types. This is extremely useful for e.g shared validation or business logic that needs to occur on both client and server. Fable will translate your functions into native Javascript, and will even translate many calls to the .NET base class library into corresponding Javascript! This allows you to compile your domain model and domain logic to many many different targets including: ASP.NET Core (via Saturn) Azure Functions Javascript that runs in the browser Javascript that runs on mobile devices with React Native . Raspberry Pi (via .NET Core) You can read more about this on the Fable website .","title":"Sharing Behaviour"},{"location":"feature-clientserver-bridge/","text":"Using F# on both client and server is at the core of the SAFE stack, as it simplifies the way we think about building web applications by using the same language, idioms and in many cases sharing our code and domain models. However, building a client and a server app requires a fundamentally different way of thinking. On the server side we build stateless APIs in Saturn that map HTTP requests to internal functionality, whereas on the frontend we use the Elmish model, implementing the model-view-update pattern : a stateful pattern that lets us think about the application state as it evolves while the application is running. Even though we use the same language across platforms, applying these two different programming models forces us to switch our way of thinking back and forth when writing code for the client and for the server. This is where the Elmish.Bridge library comes into play: it brings the Elmish programming model to the server and unifies the way we write the application as a whole. How does Elmish work on the server? Think of Elmish on the server as the model-view-update pattern but without the view part . Instead, you only need to implement init and update functions to manage the server state as it evolves while the server is running. Server state can contain data that is relevant to a single or all clients The dispatch loop running on the server is connected to the dispatch loop on the client via a persistent stateful websocket connection The update functions on client and server can exchange data via message passing. A simple example Let's see a simple example of how this might work in practice: // Client-side let update msg state = match msg with | LoadUsers -> // send the message to the server state , Cmd . bridgeSend ServerMsg . LoadUsers | UsersLoaded users -> // receive message from the server let nextState = { state with Users = users } nextState , Cmd . none // Server-side let update clientDispatch msg state = match msg with | ServerMsg . LoadUsers -> let loadUsersCmd = Cmd . ofAsync getUsersFromDb // unit -> Async<User list> () // input arg = unit UsersLoadedFromDb // User list -> ServerMsg DoNothing // ServerMsg state , loadUsersCmd | ServerMsg . UsersLoadedFromDbSuccess users -> // answer the current connected client with data clientDispatch ( ClientMsg . UsersLoaded users ) state , Cmd . none | ServerMsg . DoNothing -> state , Cmd . none The above example mimics what would have been a GET request to the server to get user data from database. However, now the client sends a fire-and-forget message to the server to load users, and at some point the server messages the current client back with the results. Notice that the server could have decided to do other things than just messaging the client back: for example, it could have broadcasted the same message to other clients updating their local state of the users. When to use Elmish.Bridge There are many scenarios where it makes sense to use Elmish.Bridge: Chat-like applications with many connected users through many channels Syncing price data in real-time while viewing ticket prices Multiplayer games that need real-time update of game states Other applications of web sockets through an Elmish model Things to consider The biggest distinction between using this and \"raw\" Saturn is that your web server becomes a stateful service. This introduces several differences for application design. The server state has a lifespan equal to the that of the process under which the server instance is running. This means if the server application restarts then the server state will be reset. The server state is local to the server instance . This means that if you run multiple web servers, they won't be sharing the same server state by default. As of now there is no built-in persistence for the state, but you can implement this yourself using any number of persistance layers such as Redis Cache, Azure Tables or Blobs etc. In addition Elmish.Bridge does not use standard HTTP verbs for communication, but rather websockets. Therefore, it is not a suitable technology for an open web server that can serve requests from other sources than Elmish.Bridge clients. Learn more about Elmish.Bridge Head over to Elmish.Bridge to learn more.","title":"Stateful Messaging through Bridge"},{"location":"feature-clientserver-bridge/#how-does-elmish-work-on-the-server","text":"Think of Elmish on the server as the model-view-update pattern but without the view part . Instead, you only need to implement init and update functions to manage the server state as it evolves while the server is running. Server state can contain data that is relevant to a single or all clients The dispatch loop running on the server is connected to the dispatch loop on the client via a persistent stateful websocket connection The update functions on client and server can exchange data via message passing.","title":"How does Elmish work on the server?"},{"location":"feature-clientserver-bridge/#a-simple-example","text":"Let's see a simple example of how this might work in practice: // Client-side let update msg state = match msg with | LoadUsers -> // send the message to the server state , Cmd . bridgeSend ServerMsg . LoadUsers | UsersLoaded users -> // receive message from the server let nextState = { state with Users = users } nextState , Cmd . none // Server-side let update clientDispatch msg state = match msg with | ServerMsg . LoadUsers -> let loadUsersCmd = Cmd . ofAsync getUsersFromDb // unit -> Async<User list> () // input arg = unit UsersLoadedFromDb // User list -> ServerMsg DoNothing // ServerMsg state , loadUsersCmd | ServerMsg . UsersLoadedFromDbSuccess users -> // answer the current connected client with data clientDispatch ( ClientMsg . UsersLoaded users ) state , Cmd . none | ServerMsg . DoNothing -> state , Cmd . none The above example mimics what would have been a GET request to the server to get user data from database. However, now the client sends a fire-and-forget message to the server to load users, and at some point the server messages the current client back with the results. Notice that the server could have decided to do other things than just messaging the client back: for example, it could have broadcasted the same message to other clients updating their local state of the users.","title":"A simple example"},{"location":"feature-clientserver-bridge/#when-to-use-elmishbridge","text":"There are many scenarios where it makes sense to use Elmish.Bridge: Chat-like applications with many connected users through many channels Syncing price data in real-time while viewing ticket prices Multiplayer games that need real-time update of game states Other applications of web sockets through an Elmish model","title":"When to use Elmish.Bridge"},{"location":"feature-clientserver-bridge/#things-to-consider","text":"The biggest distinction between using this and \"raw\" Saturn is that your web server becomes a stateful service. This introduces several differences for application design. The server state has a lifespan equal to the that of the process under which the server instance is running. This means if the server application restarts then the server state will be reset. The server state is local to the server instance . This means that if you run multiple web servers, they won't be sharing the same server state by default. As of now there is no built-in persistence for the state, but you can implement this yourself using any number of persistance layers such as Redis Cache, Azure Tables or Blobs etc. In addition Elmish.Bridge does not use standard HTTP verbs for communication, but rather websockets. Therefore, it is not a suitable technology for an open web server that can serve requests from other sources than Elmish.Bridge clients.","title":"Things to consider"},{"location":"feature-clientserver-bridge/#learn-more-about-elmishbridge","text":"Head over to Elmish.Bridge to learn more.","title":"Learn more about Elmish.Bridge"},{"location":"feature-clientserver-http/","text":"Client Server communication over HTTP Communicating over raw HTTP using Saturn has three main steps. 1. Load your data Start by creating a function on your server that returns some data: let loadCustomersFromDb () = [ { Id = 1 ; Name = \"Joe Bloggs\" } ] Next, create a method which returns the data as JSON within Giraffe's HTTP context. /// Returns the results of loadCustomersFromDb as JSON. let getCustomers next ctx = json ( loadCustomersFromDb () ) next ctx You can opt to combine both of the above functions into one, depending on your preferences, but it's often good practice to separate your data access from serving data in HTTP endpoints. Also note the next and ctx arguments. These are used by Giraffe as part of its HTTP pipeline and are required by the json function (Note you can also use Successful.Ok instead of json , which will offer XML serialization as well). 2. Expose data through Saturn Now expose the api method using Saturn's router construct and add it to your overall application scope: let myApis = router { get \"/api/customers/\" getCustomers } For simple endpoints you may elect to embed the API call directly in the scope (and use partial application to omit the next and ctx arguments): let myApis = router { get \"/api/customers/\" ( json ( loadCustomersFromDb () )) } 3. Consume the endpoint from the client Finally, call the endpoint from your client application. promise { let! customers = Fetch . fetchAs < Customer list > \"api/customers\" ( Decode . Auto . generateDecoder () ) [] // do more with customers here... } Note the use of the promise { } computation expression. This behaves similarly to async { } blocks that you might already know, whilst the fetchAs function retrieves data from the HTTP endpoint specified. The JSON is deserialized as a Customer array using an automatically-generated \"decoder\" (see the section on serialization for more information).","title":"Messaging using HTTP"},{"location":"feature-clientserver-http/#client-server-communication-over-http","text":"Communicating over raw HTTP using Saturn has three main steps.","title":"Client Server communication over HTTP"},{"location":"feature-clientserver-http/#1-load-your-data","text":"Start by creating a function on your server that returns some data: let loadCustomersFromDb () = [ { Id = 1 ; Name = \"Joe Bloggs\" } ] Next, create a method which returns the data as JSON within Giraffe's HTTP context. /// Returns the results of loadCustomersFromDb as JSON. let getCustomers next ctx = json ( loadCustomersFromDb () ) next ctx You can opt to combine both of the above functions into one, depending on your preferences, but it's often good practice to separate your data access from serving data in HTTP endpoints. Also note the next and ctx arguments. These are used by Giraffe as part of its HTTP pipeline and are required by the json function (Note you can also use Successful.Ok instead of json , which will offer XML serialization as well).","title":"1. Load your data"},{"location":"feature-clientserver-http/#2-expose-data-through-saturn","text":"Now expose the api method using Saturn's router construct and add it to your overall application scope: let myApis = router { get \"/api/customers/\" getCustomers } For simple endpoints you may elect to embed the API call directly in the scope (and use partial application to omit the next and ctx arguments): let myApis = router { get \"/api/customers/\" ( json ( loadCustomersFromDb () )) }","title":"2. Expose data through Saturn"},{"location":"feature-clientserver-http/#3-consume-the-endpoint-from-the-client","text":"Finally, call the endpoint from your client application. promise { let! customers = Fetch . fetchAs < Customer list > \"api/customers\" ( Decode . Auto . generateDecoder () ) [] // do more with customers here... } Note the use of the promise { } computation expression. This behaves similarly to async { } blocks that you might already know, whilst the fetchAs function retrieves data from the HTTP endpoint specified. The JSON is deserialized as a Customer array using an automatically-generated \"decoder\" (see the section on serialization for more information).","title":"3. Consume the endpoint from the client"},{"location":"feature-clientserver-remoting/","text":"Data sharing with Fable.Remoting Alongside raw HTTP, you can also use Fable.Remoting , which provides an RPC-style mechanism for calling server endpoints. With Remoting, you don't need to worry about the details of serialization or of how to consume the endpoint - instead, remoting lets you define you client-server interactions as a shared type that is commonly referred to as a protocol or contract . 1. Define a protocol Each field of the record is either of type Async<T> or a function that returns Async<T> , for example: type ICustomerApi = { getCustomers : unit -> Async < Customer list > findCustomerByName : string -> Async < Customer option > } The supported types used within the protocol can be any F# type: primitive values (int, string, DateTime, etc.), records, options, discriminated unions or collections etc. 2. Implement the protocol on the server On the server you would implement the protocol as follows: let getCustomers () = async { return [ { Id = 1 ; Name = \"John Doe\" } { Id = 2 ; Name = \"Jane Smith\" } ] } let findCustomerByName ( name : string ) = async { let! allCustomers = getCustomers () return allCustomers |> List . tryFind ( fun c -> c . Name = name ) } let customerApi : ICustomerApi = { getCustomers = getCustomers findCustomerByName = findCustomerByName } 3. Consume the protocol on the client After exposing an HttpHandler from customerApi you can start calling the API from the client. let api = Remoting . createApi () |> Remoting . buildProxy < ICustomerApi > async { let! customers = api . getCustomers () for customer in customers do printfn \"#%d => %s\" customer . Id customer . Name } Notice here, there is no need to configure routes or JSON serialization, worry about HTTP verbs, or even involve yourself with the Giraffe pipeline. If you open your browser network tab, you can easily inspect what remoting is doing behind the scenes.","title":"Messaging with Protocols"},{"location":"feature-clientserver-remoting/#data-sharing-with-fableremoting","text":"Alongside raw HTTP, you can also use Fable.Remoting , which provides an RPC-style mechanism for calling server endpoints. With Remoting, you don't need to worry about the details of serialization or of how to consume the endpoint - instead, remoting lets you define you client-server interactions as a shared type that is commonly referred to as a protocol or contract .","title":"Data sharing with Fable.Remoting"},{"location":"feature-clientserver-remoting/#1-define-a-protocol","text":"Each field of the record is either of type Async<T> or a function that returns Async<T> , for example: type ICustomerApi = { getCustomers : unit -> Async < Customer list > findCustomerByName : string -> Async < Customer option > } The supported types used within the protocol can be any F# type: primitive values (int, string, DateTime, etc.), records, options, discriminated unions or collections etc.","title":"1. Define a protocol"},{"location":"feature-clientserver-remoting/#2-implement-the-protocol-on-the-server","text":"On the server you would implement the protocol as follows: let getCustomers () = async { return [ { Id = 1 ; Name = \"John Doe\" } { Id = 2 ; Name = \"Jane Smith\" } ] } let findCustomerByName ( name : string ) = async { let! allCustomers = getCustomers () return allCustomers |> List . tryFind ( fun c -> c . Name = name ) } let customerApi : ICustomerApi = { getCustomers = getCustomers findCustomerByName = findCustomerByName }","title":"2. Implement the protocol on the server"},{"location":"feature-clientserver-remoting/#3-consume-the-protocol-on-the-client","text":"After exposing an HttpHandler from customerApi you can start calling the API from the client. let api = Remoting . createApi () |> Remoting . buildProxy < ICustomerApi > async { let! customers = api . getCustomers () for customer in customers do printfn \"#%d => %s\" customer . Id customer . Name } Notice here, there is no need to configure routes or JSON serialization, worry about HTTP verbs, or even involve yourself with the Giraffe pipeline. If you open your browser network tab, you can easily inspect what remoting is doing behind the scenes.","title":"3. Consume the protocol on the client"},{"location":"feature-clientserver-serialization/","text":"Serialization basics with Thoth When using basic HTTP communication between the client and server, you'll need to consider how to deserialize data from JSON to F# types. In order to guarantee that the serialization / deserialization routines between client and server are compatible, you should replace the JSON converter in Giraffe / Saturn with the Thoth library's serializer. This is the same library as that used in Fable for deserialization, and so will work seamlessly together. let configureSerialization ( services : IServiceCollection ) = services . AddSingleton < Giraffe . Serialization . Json . IJsonSerializer >( Thoth . Json . Giraffe . ThothSerializer () ) If you are using the SAFE Template , this will automatically be done for you in Server.fs . Approaches to deserialization Fable 2 uses the Thoth library for JSON deserialization, which makes use of decoders to convert JSON into F# values. There are generally two main approaches to take when doing this: automatic and manual decoders. Assume the following Customer record for the remaining examples. type Customer = { Id : int Name : string } Automatic Decoders Automatic decoders are the quickest and easier way to deserialize data. It works by Thoth trying to decode JSON automatically from a raw string to an F# type using automatic mapping rules. In the sample below, we fetch data from the /api/customers endpoint and have Thoth create a strongly-typed Decoder for a Customer array. fetchAs < Customer [] > \"/api/customers\" ( Decode . Auto . generateDecoder () ) [] If the serialization fails, Thoth will create an Error (rather than Ok ) value for this. Be aware that automatic decoders are designed to work with primitives, collections, F# records, tuples and discriminated unions but cannot deserialize classes. Improving efficiency with cached decoders You can reuse decoders when you know you'll be calling them often: // let-bound value that exists outside of the update function let customerDecoder = Decode . Auto . generateDecoder < Customer > () // inside the update function Fetch . fetchAs ( sprintf \"api/customers\" ) ( Decode . array customerDecoder [] ) Notice how the decoder is bound to a single Customer, and not an array. This way, we can also reuse the decoder on other routes, for example api/customers/1 which would return a single Customer object rather than a collection. Manual Decoders Manual decoders give you total control over how you rehydrate an object from JSON. Use them when: The JSON does not directly map 1:1 with your F# types You want flexibility to evolve JSON and F# types independently You are calling an external service and need fine-grained control over the deserialization process You are using F# on the client and another language on the server You create a manual decoder as follows: let customerDecoder : Decoder < Customer > = Decode . object ( fun get -> { Id = get . Required . Field \"id\" Decode . int Name = get . Optional . Field \"customerName\" Decode . string |> Option . defaultValue \"\" }) You can now replace the automatically generated decoder from earlier. You can also \"manually\" decode JSON to Customers as follows: Decode . fromString customerDecoder \"\"\"{ \"id\": 67, \"customerName\": \"Joe Bloggs\" }\"\"\" If decoding fails on any field, an error case will be returned. Handling \"unit\" calls You may design API methods that return unit i.e. they have no result. In such a case, you must currently do one of the following: Return some non-unit type e.g. boolean or int etc. and simply ignore it on the client response. Set the result type on the client as obj (or even _ - the F# compiler will infer obj for you). This will be correctly handled by Thoth and passed as a null object which can be safely ignored.","title":"Serialization in SAFE"},{"location":"feature-clientserver-serialization/#serialization-basics-with-thoth","text":"When using basic HTTP communication between the client and server, you'll need to consider how to deserialize data from JSON to F# types. In order to guarantee that the serialization / deserialization routines between client and server are compatible, you should replace the JSON converter in Giraffe / Saturn with the Thoth library's serializer. This is the same library as that used in Fable for deserialization, and so will work seamlessly together. let configureSerialization ( services : IServiceCollection ) = services . AddSingleton < Giraffe . Serialization . Json . IJsonSerializer >( Thoth . Json . Giraffe . ThothSerializer () ) If you are using the SAFE Template , this will automatically be done for you in Server.fs .","title":"Serialization basics with Thoth"},{"location":"feature-clientserver-serialization/#approaches-to-deserialization","text":"Fable 2 uses the Thoth library for JSON deserialization, which makes use of decoders to convert JSON into F# values. There are generally two main approaches to take when doing this: automatic and manual decoders. Assume the following Customer record for the remaining examples. type Customer = { Id : int Name : string }","title":"Approaches to deserialization"},{"location":"feature-clientserver-serialization/#automatic-decoders","text":"Automatic decoders are the quickest and easier way to deserialize data. It works by Thoth trying to decode JSON automatically from a raw string to an F# type using automatic mapping rules. In the sample below, we fetch data from the /api/customers endpoint and have Thoth create a strongly-typed Decoder for a Customer array. fetchAs < Customer [] > \"/api/customers\" ( Decode . Auto . generateDecoder () ) [] If the serialization fails, Thoth will create an Error (rather than Ok ) value for this. Be aware that automatic decoders are designed to work with primitives, collections, F# records, tuples and discriminated unions but cannot deserialize classes.","title":"Automatic Decoders"},{"location":"feature-clientserver-serialization/#improving-efficiency-with-cached-decoders","text":"You can reuse decoders when you know you'll be calling them often: // let-bound value that exists outside of the update function let customerDecoder = Decode . Auto . generateDecoder < Customer > () // inside the update function Fetch . fetchAs ( sprintf \"api/customers\" ) ( Decode . array customerDecoder [] ) Notice how the decoder is bound to a single Customer, and not an array. This way, we can also reuse the decoder on other routes, for example api/customers/1 which would return a single Customer object rather than a collection.","title":"Improving efficiency with cached decoders"},{"location":"feature-clientserver-serialization/#manual-decoders","text":"Manual decoders give you total control over how you rehydrate an object from JSON. Use them when: The JSON does not directly map 1:1 with your F# types You want flexibility to evolve JSON and F# types independently You are calling an external service and need fine-grained control over the deserialization process You are using F# on the client and another language on the server You create a manual decoder as follows: let customerDecoder : Decoder < Customer > = Decode . object ( fun get -> { Id = get . Required . Field \"id\" Decode . int Name = get . Optional . Field \"customerName\" Decode . string |> Option . defaultValue \"\" }) You can now replace the automatically generated decoder from earlier. You can also \"manually\" decode JSON to Customers as follows: Decode . fromString customerDecoder \"\"\"{ \"id\": 67, \"customerName\": \"Joe Bloggs\" }\"\"\" If decoding fails on any field, an error case will be returned.","title":"Manual Decoders"},{"location":"feature-clientserver-serialization/#handling-unit-calls","text":"You may design API methods that return unit i.e. they have no result. In such a case, you must currently do one of the following: Return some non-unit type e.g. boolean or int etc. and simply ignore it on the client response. Set the result type on the client as obj (or even _ - the F# compiler will infer obj for you). This will be correctly handled by Thoth and passed as a null object which can be safely ignored.","title":"Handling \"unit\" calls"},{"location":"feature-clientserver/","text":"One of the most powerful features of SAFE is the ability to seamlessly share code across client and server. Sharing Basics The basics of code sharing across client and server include: Sharing types . Useful for contracts between client and server, as well as to share a common domain. Sharing behaviour . In other words, functions that perform e.g. shared validation or similar. These two core areas are explained in more detail here . Sending messages between client and server In addition to types and messages, there are several technologies availabile in SAFE that allow you to send messages from client to server (and from server to client). Each has their own strengths and weaknesses: Raw HTTP using Saturn's routing capabilities. Contracts / protocols via Fable Remoting. Stateful servers through Elmish Bridge. Which technology should I use? The raw HTTP model provided by Saturn with router { } requires you to construct routes manually and does not guarantee that the client and endpoint have the same contract (you have to specify the same type on both sides yourself). However, using the raw HTTP model gives you total control over the routing and verbs used. If you have a public API that is exposed not just to your own application but to third-parties, or you need more fine grained control over your routes and data, you should use this approach. Alternatively, Fable Remoting provides an excellent way to quickly get up and running with the SAFE stack. You can rapidly create contracts and have guaranteed type-safety between both client and server. Consider using remoting for rapid prototyping, since JSON serialization and HTTP routing is handled by the library, you only think of your client-server code in terms of types and stateless functions. If you need full control over the HTTP channel for returning specific status codes, using custom HTTP verbs or working with headers, then remoting is probably not for you. Lastly, Elmish.Bridge provides an alternative way of modelling client/server communication. Unlike the other two mechanisms, Elmish Bridge provides the same Elmish model on the server as well as the client, as well as the ability to send notifications from the server back to connected clients via websockets. However, the Bridge model is inherently stateful, which means that a server restart could impact all connected clients. Fable.Remoting Raw HTTP Elmish.Bridge Client / Server support Very easy Easy Very Easy State model Stateless Stateless Stateful \"Open\" API? Yes Yes No HTTP Verbs? POST, GET Fully Configurable None Push messages? No No Yes Pipeline Control? Limited Full Limited Consider using a combination of multiple endpoints supporting combinations of the above to suit your needs!","title":"Sharing Overview"},{"location":"feature-clientserver/#sharing-basics","text":"The basics of code sharing across client and server include: Sharing types . Useful for contracts between client and server, as well as to share a common domain. Sharing behaviour . In other words, functions that perform e.g. shared validation or similar. These two core areas are explained in more detail here .","title":"Sharing Basics"},{"location":"feature-clientserver/#sending-messages-between-client-and-server","text":"In addition to types and messages, there are several technologies availabile in SAFE that allow you to send messages from client to server (and from server to client). Each has their own strengths and weaknesses: Raw HTTP using Saturn's routing capabilities. Contracts / protocols via Fable Remoting. Stateful servers through Elmish Bridge.","title":"Sending messages between client and server"},{"location":"feature-clientserver/#which-technology-should-i-use","text":"The raw HTTP model provided by Saturn with router { } requires you to construct routes manually and does not guarantee that the client and endpoint have the same contract (you have to specify the same type on both sides yourself). However, using the raw HTTP model gives you total control over the routing and verbs used. If you have a public API that is exposed not just to your own application but to third-parties, or you need more fine grained control over your routes and data, you should use this approach. Alternatively, Fable Remoting provides an excellent way to quickly get up and running with the SAFE stack. You can rapidly create contracts and have guaranteed type-safety between both client and server. Consider using remoting for rapid prototyping, since JSON serialization and HTTP routing is handled by the library, you only think of your client-server code in terms of types and stateless functions. If you need full control over the HTTP channel for returning specific status codes, using custom HTTP verbs or working with headers, then remoting is probably not for you. Lastly, Elmish.Bridge provides an alternative way of modelling client/server communication. Unlike the other two mechanisms, Elmish Bridge provides the same Elmish model on the server as well as the client, as well as the ability to send notifications from the server back to connected clients via websockets. However, the Bridge model is inherently stateful, which means that a server restart could impact all connected clients. Fable.Remoting Raw HTTP Elmish.Bridge Client / Server support Very easy Easy Very Easy State model Stateless Stateless Stateful \"Open\" API? Yes Yes No HTTP Verbs? POST, GET Fully Configurable None Push messages? No No Yes Pipeline Control? Limited Full Limited Consider using a combination of multiple endpoints supporting combinations of the above to suit your needs!","title":"Which technology should I use?"},{"location":"feature-hmr/","text":"Hot Module Replacement (HMR) allows to update the UI of an application while it is running, without a full reload. In SAFE stack apps, this can dramatically speed up the development for web and mobile GUIs, since there is no need to \"stop\" and \"reload\" and application. Instead, you can make changes to your views and have them immediately update in the browser, without the need to restart the application. How does it work? In case of web development, the webpack development server will automatically refresh the changed parts of your elmish views whenever you save a file. Alternatively, in the case of mobile app development, this is achieved through React Native 's own bundler. Why does it work so well with SAFE? Since SAFE uses the Model-View-Update architecture with immutable models, the application state only changes when a message is processed; this fits the HMR model very nicely. Here's an example of HMR in action to change the input of a textbox to automatically convert the input to upper case. Further reading Hot Module Replacement via webpack Introducing Hot Reloading in React Native","title":"Hot Module Replacement"},{"location":"feature-hmr/#how-does-it-work","text":"In case of web development, the webpack development server will automatically refresh the changed parts of your elmish views whenever you save a file. Alternatively, in the case of mobile app development, this is achieved through React Native 's own bundler.","title":"How does it work?"},{"location":"feature-hmr/#why-does-it-work-so-well-with-safe","text":"Since SAFE uses the Model-View-Update architecture with immutable models, the application state only changes when a message is processed; this fits the HMR model very nicely. Here's an example of HMR in action to change the input of a textbox to automatically convert the input to upper case.","title":"Why does it work so well with SAFE?"},{"location":"feature-hmr/#further-reading","text":"Hot Module Replacement via webpack Introducing Hot Reloading in React Native","title":"Further reading"},{"location":"feature-ssr/","text":"Server-Side Rendering (SSR) means that some parts of your application code can run on both the server and the client. For React this means that you can render your components directly to HTML on the server side (e.g. via a node.js server ), which allows for better search engine optimization (SEO) and gives a faster initial response, especially on mobile devices. The browser typically receives a static HTML site and starts updating the UI immediately; React's bundle code will be downloaded asynchronously and when it completes, the client-side JavaScript will take over via React's hydrate functionality. In the JavaScript ecosystem this is also known as an \"isomorphic\" or \"universal\" app. Why use SSR? Pros Better SEO support, as web crawlers will directly see the fully rendered HTML page. Faster time-to-content, especially on slow internet connections or devices. Cons Some development constraints. Browser-specific code requires some compiler directives to be ignored when running on the server. Increased complexity of build and deployment processes. Increased server-side load. SSR on SAFE In SAFE, SSR can be done using fable-react . Its approach is a little different from those you might have seen in the JavaScript ecosystem, as it takes a purely F# approach: you render your Elmish views directly on .NET Core, with all the benefits of the .NET Core runtime. Further reading More details can be found in the SSR tutorial . The SAFE-BookStore sample project uses SSR.","title":"Server Side Rendering"},{"location":"feature-ssr/#why-use-ssr","text":"","title":"Why use SSR?"},{"location":"feature-ssr/#pros","text":"Better SEO support, as web crawlers will directly see the fully rendered HTML page. Faster time-to-content, especially on slow internet connections or devices.","title":"Pros"},{"location":"feature-ssr/#cons","text":"Some development constraints. Browser-specific code requires some compiler directives to be ignored when running on the server. Increased complexity of build and deployment processes. Increased server-side load.","title":"Cons"},{"location":"feature-ssr/#ssr-on-safe","text":"In SAFE, SSR can be done using fable-react . Its approach is a little different from those you might have seen in the JavaScript ecosystem, as it takes a purely F# approach: you render your Elmish views directly on .NET Core, with all the benefits of the .NET Core runtime.","title":"SSR on SAFE"},{"location":"feature-ssr/#further-reading","text":"More details can be found in the SSR tutorial . The SAFE-BookStore sample project uses SSR.","title":"Further reading"},{"location":"intro/","text":"What is SAFE? The SAFE stack is the best way to write functional-first web applications . The SAFE stack allows you to develop web applications almost entirely in F# , without needing to compromise and shoehorn your codebase into an object-oriented framework or library, and without needing you to be an expert in CSS or HTML to create compelling, rich client-side web applications. SAFE Stack is: Open-source Free Type-safe Flexible Cloud-ready The SAFE stack is made up of four components: A web server running on .NET Core for hosting back-end services in F# A hosting platform that provides simple, scalable deployment models plus associated platform services for application developers A mechanism to run F# in the web browser for client-side delivery of F# An F# programming model for client-side user interfaces Why SAFE? SAFE provides developers with a simple and consistent programming model for developing rich, scalable web-enabled applications that can run on multiple platforms. SAFE takes advantage of F#'s functional-first experience backed by the powerful and mature .NET framework to provide a type-safe, reliable experience that leads to the \"pit of success\". Create client / server applications entirely in F# Re-use development skills on client and server Rapidly create rich client-side web applications with no Javascript knowledge Runs on the latest .NET Core (and tested daily by Microsoft) Rapid development cycle with support for hot module replacement Interact with native Javascript libraries whenever needed Create client-side applications purely in F#, with full type checking for safety Seamlessly share code between client and server","title":"Introduction"},{"location":"intro/#what-is-safe","text":"The SAFE stack is the best way to write functional-first web applications . The SAFE stack allows you to develop web applications almost entirely in F# , without needing to compromise and shoehorn your codebase into an object-oriented framework or library, and without needing you to be an expert in CSS or HTML to create compelling, rich client-side web applications. SAFE Stack is: Open-source Free Type-safe Flexible Cloud-ready The SAFE stack is made up of four components: A web server running on .NET Core for hosting back-end services in F# A hosting platform that provides simple, scalable deployment models plus associated platform services for application developers A mechanism to run F# in the web browser for client-side delivery of F# An F# programming model for client-side user interfaces","title":"What is SAFE?"},{"location":"intro/#why-safe","text":"SAFE provides developers with a simple and consistent programming model for developing rich, scalable web-enabled applications that can run on multiple platforms. SAFE takes advantage of F#'s functional-first experience backed by the powerful and mature .NET framework to provide a type-safe, reliable experience that leads to the \"pit of success\". Create client / server applications entirely in F# Re-use development skills on client and server Rapidly create rich client-side web applications with no Javascript knowledge Runs on the latest .NET Core (and tested daily by Microsoft) Rapid development cycle with support for hot module replacement Interact with native Javascript libraries whenever needed Create client-side applications purely in F#, with full type checking for safety Seamlessly share code between client and server","title":"Why SAFE?"},{"location":"learning/","text":"This section contains useful repositories that allow you to learn more about the SAFE stack, at your own pace. Tutorials SAFE Dojo This dojo is a guided set of tasks designed to give you hands-on experience with the client and server components of the SAFE stack. You'll create server-side routes, client side UI and shared validation logic as you create a mashup application to provide details on UK locations. The dojo takes around 90 minutes to complete if you have never worked with the stack before. SAFE Samples The following example repositories (and more!) can be found in the official SAFE Stack organisational GitHub page. SAFE Todo List The simplest Todo app: a client-server application written entirely in F# using Elmish on the client. Remoting for type-safe communication between the two. tabula-rasa A minimalistic real-worldish blog engine written entirely in F#. Specifically made as a learning resource when building apps with the SAFE stack. This application features many concerns of large apps such as logging, database access, secured remoting, web sockets and much more. SAFE Bookstore This sample demonstrates many of the useful features of a larger SAFE application, including login authentication using JWT tokens, automated deployment via Docker and SEO support with urls for pages. It also includes an example of using Azure Storage tables as a persistence store. SAFE ConfPlanner This sample demonstrates how to build and share a complex domain model in SAFE across client and server, along with the use of websockets for a \"reactive\" UI support push notifications. It also demonstrates the use of F#'s flexible mailbox processors to implement an event-driven architecture. SAFE Search This repository shows how to use Azure services to implement a SAFE application that supports searching over multiple data sources with support for find-ahead typing and throttling. The application uses a combination of Azure Search and Azure Storage Tables to construct a large search index that can rapidly find results in a number of ways. SAFE Chat This application is a real-time chat application built on SAFE that uses the AKKA framework to manage actors that represent chat users, including Akka Streams and the Akkling F# library. SAFE Nightwatch This application is a sample mobile application using the React Native library, built on top of the SAFE stack. React Native permits a very similar programming when writing SAFE applications as browser applications, so the experience should be very familiar to you. Videos SAFE apps with F# web stack at Lambda Days 2018 (Tomasz Heimowski) Modern app development with Fable and React Native at NDC Oslo 2017 (Steffen Forkmann) Reinventing MVC pattern for F# web development at NDC Oslo 2018 (Krzysztof Cieslak) Other Resources The Hanselminutes podcast: F# and the functional SAFE Stack with Krzysztof Cieslak Introducing Fable.Remoting: Automated Type-Safe Client-Server Communication for Fable Apps Learning about the F# SAFE stack High level introduction to the SAFE stack by Scott Hanselman","title":"Learning Resources"},{"location":"learning/#tutorials","text":"","title":"Tutorials"},{"location":"learning/#safe-dojo","text":"This dojo is a guided set of tasks designed to give you hands-on experience with the client and server components of the SAFE stack. You'll create server-side routes, client side UI and shared validation logic as you create a mashup application to provide details on UK locations. The dojo takes around 90 minutes to complete if you have never worked with the stack before.","title":"SAFE Dojo"},{"location":"learning/#safe-samples","text":"The following example repositories (and more!) can be found in the official SAFE Stack organisational GitHub page.","title":"SAFE Samples"},{"location":"learning/#safe-todo-list","text":"The simplest Todo app: a client-server application written entirely in F# using Elmish on the client. Remoting for type-safe communication between the two.","title":"SAFE Todo List"},{"location":"learning/#tabula-rasa","text":"A minimalistic real-worldish blog engine written entirely in F#. Specifically made as a learning resource when building apps with the SAFE stack. This application features many concerns of large apps such as logging, database access, secured remoting, web sockets and much more.","title":"tabula-rasa"},{"location":"learning/#safe-bookstore","text":"This sample demonstrates many of the useful features of a larger SAFE application, including login authentication using JWT tokens, automated deployment via Docker and SEO support with urls for pages. It also includes an example of using Azure Storage tables as a persistence store.","title":"SAFE Bookstore"},{"location":"learning/#safe-confplanner","text":"This sample demonstrates how to build and share a complex domain model in SAFE across client and server, along with the use of websockets for a \"reactive\" UI support push notifications. It also demonstrates the use of F#'s flexible mailbox processors to implement an event-driven architecture.","title":"SAFE ConfPlanner"},{"location":"learning/#safe-search","text":"This repository shows how to use Azure services to implement a SAFE application that supports searching over multiple data sources with support for find-ahead typing and throttling. The application uses a combination of Azure Search and Azure Storage Tables to construct a large search index that can rapidly find results in a number of ways.","title":"SAFE Search"},{"location":"learning/#safe-chat","text":"This application is a real-time chat application built on SAFE that uses the AKKA framework to manage actors that represent chat users, including Akka Streams and the Akkling F# library.","title":"SAFE Chat"},{"location":"learning/#safe-nightwatch","text":"This application is a sample mobile application using the React Native library, built on top of the SAFE stack. React Native permits a very similar programming when writing SAFE applications as browser applications, so the experience should be very familiar to you.","title":"SAFE Nightwatch"},{"location":"learning/#videos","text":"SAFE apps with F# web stack at Lambda Days 2018 (Tomasz Heimowski) Modern app development with Fable and React Native at NDC Oslo 2017 (Steffen Forkmann) Reinventing MVC pattern for F# web development at NDC Oslo 2018 (Krzysztof Cieslak)","title":"Videos"},{"location":"learning/#other-resources","text":"The Hanselminutes podcast: F# and the functional SAFE Stack with Krzysztof Cieslak Introducing Fable.Remoting: Automated Type-Safe Client-Server Communication for Fable Apps Learning about the F# SAFE stack High level introduction to the SAFE stack by Scott Hanselman","title":"Other Resources"},{"location":"legacy-feature-debugging/","text":"A powerful features of the SAFE Stack is that it supports combined client / server debugging in F#. This means that you can use a single IDE (in this case, Visual Studio Code ) to debug both client and server code in the same IDE session . As of v0.38 of the SAFE Template, new SAFE applications come pre-configured with build, launch and debugging support in VS Code. Prerequisites Install Google Chrome : Enables client-side debugging. Configure Chrome with the following extensions: Redux Dev Tools : Provides improved debugging support in Chrome with Elmish and access to Redux debugging. React Developer Tools : Provides access to React debugging in Chrome. Configure VS Code with the following extensions: Ionide : Provides F# support to Code. C# : Provides .NET Core debugging support. Debugger for Chrome : Provides integrated client-side debugging in Code. Launching and debugging a SAFE application in VS Code The SAFE template allows you to launch a SAFE Stack application with both client and server debugging enabled automatically. Create a new SAFE application using the SAFE template Open VS Code in the folder containing your application Go to the Debug pane ( CTRL + Shift + D ) Note : Depending on your configuration, the Debug pane may be pinned to the left- or right-hand-side of VS Code. Ensure that Debug SAFE App is selected as the launch configuration Hit F5 to launch the application, or hit the green play button in the launch configuration panel That's it. VS Code will now automatically: Download all dependencies for both client and server Build both the client and server Start both client and server Attach debuggers for both the client and server simultaneously! Note : When you stop debugging, you also need to kill the associated Watch Client task - see details . The VS Code debugger This section explains the basics of debugging SAFE applications with VS Code. Refer to here to learn more about the VS Code debugger. VS Code Tooling basics Once you start debugging a SAFE app, in the Terminal pane two Tasks will begin in parallel: Watch Client : Builds and runs the client in hot module reload mode Build Server : Builds and runs the server Low-level output from the command line of both client and server can be seen in the appropriate Terminal window. Observe that the floating Debug control contains two active debugging sessions: Debug Client : Selects the Client debug session Debug Server : Selects the Server debug session Selecting one or the other will instruct the Debug pane to show details for that \"side\" of the application e.g. breakpoints, call stack etc. Setting breakpoints To set a breakpoint, simply highlight the line of code that you wish to stop on and hit F9 , or click on the left-side gutter of the code window; a red dot will appear to show the breakpoint is set. You can see more on VS Code breakpoints here . Here you can see a breakpoint that has been hit in the update method of the sample application that is bundled with the SAFE template. Viewing debug output Debug output from Chrome will automatically be sent to the integrated Debug Console. This is especially useful for Elmish applications, as you can view Elmish messages and model updates directly in the IDE. Restarting your application In the standard launch mode seen above, hot module reloading is enabled on the client, so changes that are made to your Fable application will occur immediately. However, in order to support debugging, watch mode is not enabled on the server; server changes require a restart of the server debugging session: Having ensured that Debug Server is selected in the floating Debug control, select the Restart icon or hit CTRL + SHIFT + F5 . The server will stop, rebuild and restart with the debugger automatically re-attached. Advanced options The SAFE template comes with several other modes of operation for debugging: Full watch mode If you prefer to use \"watch\" mode on both client and server, choose the Watch SAFE app option from the Debug Launcher. Here, changes to any server file will automatically initiate a restart of it. However, whilst you will still be able to debug the client, in this mode there is no capability for server-side debugging. Debug Server or Client only You can also launch and debug either the client or server in isolation. This may be useful if you are running the other component separately e.g. through FAKE, the dotnet command line tool directly or via Visual Studio. You can initiate this by choosing either Debug Client or Debug Server as required. Build Server You can initiate a restore and rebuild of the server by hitting CTRL + SHIFT + B and selecting Build Server from the drop-down. Troubleshooting Still have issues getting the debugger to work? Check out the troubleshooting page.","title":"Full Stack Debugging"},{"location":"legacy-feature-debugging/#prerequisites","text":"Install Google Chrome : Enables client-side debugging. Configure Chrome with the following extensions: Redux Dev Tools : Provides improved debugging support in Chrome with Elmish and access to Redux debugging. React Developer Tools : Provides access to React debugging in Chrome. Configure VS Code with the following extensions: Ionide : Provides F# support to Code. C# : Provides .NET Core debugging support. Debugger for Chrome : Provides integrated client-side debugging in Code.","title":"Prerequisites"},{"location":"legacy-feature-debugging/#launching-and-debugging-a-safe-application-in-vs-code","text":"The SAFE template allows you to launch a SAFE Stack application with both client and server debugging enabled automatically. Create a new SAFE application using the SAFE template Open VS Code in the folder containing your application Go to the Debug pane ( CTRL + Shift + D ) Note : Depending on your configuration, the Debug pane may be pinned to the left- or right-hand-side of VS Code. Ensure that Debug SAFE App is selected as the launch configuration Hit F5 to launch the application, or hit the green play button in the launch configuration panel That's it. VS Code will now automatically: Download all dependencies for both client and server Build both the client and server Start both client and server Attach debuggers for both the client and server simultaneously! Note : When you stop debugging, you also need to kill the associated Watch Client task - see details .","title":"Launching and debugging a SAFE application in VS Code"},{"location":"legacy-feature-debugging/#the-vs-code-debugger","text":"This section explains the basics of debugging SAFE applications with VS Code. Refer to here to learn more about the VS Code debugger.","title":"The VS Code debugger"},{"location":"legacy-feature-debugging/#vs-code-tooling-basics","text":"Once you start debugging a SAFE app, in the Terminal pane two Tasks will begin in parallel: Watch Client : Builds and runs the client in hot module reload mode Build Server : Builds and runs the server Low-level output from the command line of both client and server can be seen in the appropriate Terminal window. Observe that the floating Debug control contains two active debugging sessions: Debug Client : Selects the Client debug session Debug Server : Selects the Server debug session Selecting one or the other will instruct the Debug pane to show details for that \"side\" of the application e.g. breakpoints, call stack etc.","title":"VS Code Tooling basics"},{"location":"legacy-feature-debugging/#setting-breakpoints","text":"To set a breakpoint, simply highlight the line of code that you wish to stop on and hit F9 , or click on the left-side gutter of the code window; a red dot will appear to show the breakpoint is set. You can see more on VS Code breakpoints here . Here you can see a breakpoint that has been hit in the update method of the sample application that is bundled with the SAFE template.","title":"Setting breakpoints"},{"location":"legacy-feature-debugging/#viewing-debug-output","text":"Debug output from Chrome will automatically be sent to the integrated Debug Console. This is especially useful for Elmish applications, as you can view Elmish messages and model updates directly in the IDE.","title":"Viewing debug output"},{"location":"legacy-feature-debugging/#restarting-your-application","text":"In the standard launch mode seen above, hot module reloading is enabled on the client, so changes that are made to your Fable application will occur immediately. However, in order to support debugging, watch mode is not enabled on the server; server changes require a restart of the server debugging session: Having ensured that Debug Server is selected in the floating Debug control, select the Restart icon or hit CTRL + SHIFT + F5 . The server will stop, rebuild and restart with the debugger automatically re-attached.","title":"Restarting your application"},{"location":"legacy-feature-debugging/#advanced-options","text":"The SAFE template comes with several other modes of operation for debugging:","title":"Advanced options"},{"location":"legacy-feature-debugging/#full-watch-mode","text":"If you prefer to use \"watch\" mode on both client and server, choose the Watch SAFE app option from the Debug Launcher. Here, changes to any server file will automatically initiate a restart of it. However, whilst you will still be able to debug the client, in this mode there is no capability for server-side debugging.","title":"Full watch mode"},{"location":"legacy-feature-debugging/#debug-server-or-client-only","text":"You can also launch and debug either the client or server in isolation. This may be useful if you are running the other component separately e.g. through FAKE, the dotnet command line tool directly or via Visual Studio. You can initiate this by choosing either Debug Client or Debug Server as required.","title":"Debug Server or Client only"},{"location":"legacy-feature-debugging/#build-server","text":"You can initiate a restore and rebuild of the server by hitting CTRL + SHIFT + B and selecting Build Server from the drop-down.","title":"Build Server"},{"location":"legacy-feature-debugging/#troubleshooting","text":"Still have issues getting the debugger to work? Check out the troubleshooting page.","title":"Troubleshooting"},{"location":"legacy-template-appservice/","text":"The SAFE template has the ability to deploy to Azure's App Service with minimum effort. This template mode will also create you an Application Insights account, linked to your web application. What is Azure App Service? The Azure App Service allows you to quickly build, deploy, and scale enterprise-grade web, mobile, and API apps running on any platform whilst meeting rigorous performance, scalability, security and compliance requirements using a fully-managed platform to perform infrastructure maintenance. It comes in a number of pricing plans, including a free option and has options for scale-up, scale-out, turn-key authentication as well as powerful monitoring capabilities. It is compatible with many runtimes and includes excellent support for both .NET Framework and .NET Core. Deployment Steps In order to deploy your SAFE application to the App Service, you must have first created an Azure Account , selected a Subscription ID and created an associated App Registration . Custom FAKE build tasks The Azure variant of the SAFE template adds the following extra build stages: Bundle - Runs after the standard Build step. It combines the outputs of the Client and Server application into a single folder. ArmTemplate - Deploys an Azure Resource Manager (ARM) template containing an entire environment as required by the SAFE application. AppService - Zips up the bundled folder and deploys it into the created environment. There is a known issue that currently the FAKE script may sometimes fail the first time you run it with this error . If this occurs, simply open the FAKE script in your favourite editor, add a new line anywhere in the script, save and re-run. We're looking to fix this as soon as possible! What is an ARM template? An ARM template is a declarative JSON file which contains the details of the Azure resources you require in your environment. This might include a web application, database, VM and messaging service - essentially any service supported by Azure. ARM templates are smart, in that you can repeatedly deploy them over an existing environment and only the newly added elements in the template will be applied onto the environment - perfect for a CI / CD approach. This also allows you to create entire dev / test environments from scratch within just a few minutes. The ARM template that comes with the SAFE template includes everything you need for a complete deployment to Azure from a clean state. Build arguments Deploying your application through FAKE is relatively simple. Use the following command: dotnet fake build --target appservice -e subscriptionId=<subId> -e clientId=<clientId> -e tenantId=<tenantId> -e environment=<environment> (optional) -e location=<location> (optional) -e pricingTier=<pricingTier> (optional) where: subscriptionId is an Azure Subscription ID. clientId is the Application (Client) ID of an Azure App Registration. tenantId is the Directory (Tenant) ID of an Azure App Registration. environment is an optional environment name that will be appended to all Azure resources created, which allows you to create entire dev / test environments quickly and easily. This defaults to a random GUID. location is the Azure data center location you wish to use. There are currently over 30 different data centers worldwide. This defaults to westeurope ; the full list can be viewed here . The location must be supplied in lower case and without spaces. pricingTier is the pricing tier of the app service that hosts your SAFE app. This defaults to F1 (free); the full list can be viewed here . Note that you can also modify the FAKE script and embed both the subscriptionId , clientId and tenantId values directly in the script and commit into source control. This is completely safe to do as these values are not sufficient on their own to authenticate into Azure (see below). Interactive deployment When running the build script, you will need to interactively authenticate with Azure in order to deploy the ARM template. During the FAKE script, you will see the following midway through the build cycle: Navigating to that URL will request you to input the code shown above: Finally, you will be prompted sign into Azure using your normal user account, and possibly consent to granting permissions to the application. After a short delay, the FAKE script will continue. Note: If you're getting FileNotFoundException for Microsoft.Rest.ClientRuntime.Azure , try editing and rerunning FAKE script ( see details ). Creating a fully automated deployment You can also elect to implement a fully-automated (non-interactive) deployment model, ideal for Continuous Deployment (CD) scenarios through tools such as AppVeyor and Visual Studio Team Services, using an Azure Active Directory Application . In this model, in addition to a SubscriptionID and Client ID, you also supply a Tenant ID and an Application Secret into the FAKE script to deploy your ARM resources; these identities should normally be secured and supplied into your FAKE script as arguments rather than committed into source control. Viewing the deployed SAFE application Once the deployment is complete, you can log into the Azure Portal and see your environment being created. Log into the Azure Portal. Navigate to the Resource Groups blade and locate the newly-created group. Its name will be safe-<environment> e.g. safe-helloworld . Navigate to the App Service entry shown in the group following the convention safe-<environment>-web . Hit Browse from the new App Service blade that appears. Your application will be shown in the browser running on a url following the convention https://safe-<environment>-web.azurewebsites.net/ . You can also deploy to a Docker Container .","title":"Deploy to App Service"},{"location":"legacy-template-appservice/#what-is-azure-app-service","text":"The Azure App Service allows you to quickly build, deploy, and scale enterprise-grade web, mobile, and API apps running on any platform whilst meeting rigorous performance, scalability, security and compliance requirements using a fully-managed platform to perform infrastructure maintenance. It comes in a number of pricing plans, including a free option and has options for scale-up, scale-out, turn-key authentication as well as powerful monitoring capabilities. It is compatible with many runtimes and includes excellent support for both .NET Framework and .NET Core.","title":"What is Azure App Service?"},{"location":"legacy-template-appservice/#deployment-steps","text":"In order to deploy your SAFE application to the App Service, you must have first created an Azure Account , selected a Subscription ID and created an associated App Registration .","title":"Deployment Steps"},{"location":"legacy-template-appservice/#custom-fake-build-tasks","text":"The Azure variant of the SAFE template adds the following extra build stages: Bundle - Runs after the standard Build step. It combines the outputs of the Client and Server application into a single folder. ArmTemplate - Deploys an Azure Resource Manager (ARM) template containing an entire environment as required by the SAFE application. AppService - Zips up the bundled folder and deploys it into the created environment. There is a known issue that currently the FAKE script may sometimes fail the first time you run it with this error . If this occurs, simply open the FAKE script in your favourite editor, add a new line anywhere in the script, save and re-run. We're looking to fix this as soon as possible!","title":"Custom FAKE build tasks"},{"location":"legacy-template-appservice/#what-is-an-arm-template","text":"An ARM template is a declarative JSON file which contains the details of the Azure resources you require in your environment. This might include a web application, database, VM and messaging service - essentially any service supported by Azure. ARM templates are smart, in that you can repeatedly deploy them over an existing environment and only the newly added elements in the template will be applied onto the environment - perfect for a CI / CD approach. This also allows you to create entire dev / test environments from scratch within just a few minutes. The ARM template that comes with the SAFE template includes everything you need for a complete deployment to Azure from a clean state.","title":"What is an ARM template?"},{"location":"legacy-template-appservice/#build-arguments","text":"Deploying your application through FAKE is relatively simple. Use the following command: dotnet fake build --target appservice -e subscriptionId=<subId> -e clientId=<clientId> -e tenantId=<tenantId> -e environment=<environment> (optional) -e location=<location> (optional) -e pricingTier=<pricingTier> (optional) where: subscriptionId is an Azure Subscription ID. clientId is the Application (Client) ID of an Azure App Registration. tenantId is the Directory (Tenant) ID of an Azure App Registration. environment is an optional environment name that will be appended to all Azure resources created, which allows you to create entire dev / test environments quickly and easily. This defaults to a random GUID. location is the Azure data center location you wish to use. There are currently over 30 different data centers worldwide. This defaults to westeurope ; the full list can be viewed here . The location must be supplied in lower case and without spaces. pricingTier is the pricing tier of the app service that hosts your SAFE app. This defaults to F1 (free); the full list can be viewed here . Note that you can also modify the FAKE script and embed both the subscriptionId , clientId and tenantId values directly in the script and commit into source control. This is completely safe to do as these values are not sufficient on their own to authenticate into Azure (see below).","title":"Build arguments"},{"location":"legacy-template-appservice/#interactive-deployment","text":"When running the build script, you will need to interactively authenticate with Azure in order to deploy the ARM template. During the FAKE script, you will see the following midway through the build cycle: Navigating to that URL will request you to input the code shown above: Finally, you will be prompted sign into Azure using your normal user account, and possibly consent to granting permissions to the application. After a short delay, the FAKE script will continue. Note: If you're getting FileNotFoundException for Microsoft.Rest.ClientRuntime.Azure , try editing and rerunning FAKE script ( see details ).","title":"Interactive deployment"},{"location":"legacy-template-appservice/#creating-a-fully-automated-deployment","text":"You can also elect to implement a fully-automated (non-interactive) deployment model, ideal for Continuous Deployment (CD) scenarios through tools such as AppVeyor and Visual Studio Team Services, using an Azure Active Directory Application . In this model, in addition to a SubscriptionID and Client ID, you also supply a Tenant ID and an Application Secret into the FAKE script to deploy your ARM resources; these identities should normally be secured and supplied into your FAKE script as arguments rather than committed into source control.","title":"Creating a fully automated deployment"},{"location":"legacy-template-appservice/#viewing-the-deployed-safe-application","text":"Once the deployment is complete, you can log into the Azure Portal and see your environment being created. Log into the Azure Portal. Navigate to the Resource Groups blade and locate the newly-created group. Its name will be safe-<environment> e.g. safe-helloworld . Navigate to the App Service entry shown in the group following the convention safe-<environment>-web . Hit Browse from the new App Service blade that appears. Your application will be shown in the browser running on a url following the convention https://safe-<environment>-web.azurewebsites.net/ . You can also deploy to a Docker Container .","title":"Viewing the deployed SAFE application"},{"location":"legacy-template-azure-ai/","text":"What is Application Insights? Application Insights is an extensible Application Performance Management (APM) service for web developers on multiple platforms. You can use it to monitor your live web application; it will automatically detect performance anomalies. It includes powerful analytics tools to help you diagnose issues and to understand what users actually do with your app. It's designed to help you continuously improve performance and usability. Features of AI include: Request tracking : monitoring every request, timing and response, with full correlation of operations within a request. Dependency tracking : understand calls to third-party dependencies e.g. databases, web services etc. Failures : Understand which failures are occurring on your site, how often and with full stack traces. User behaviours : Understand user flows such as funnels and retention. Custom Events and Metrics : You can easily create arbitrary metrics and events using the Application Insights SDK for tracing and reporting. Reporting Capabilities : Either use Application Insights's built-in query language to create reports, or automatically export all data into a Storage Account for offline analytics. Basics of working with Application Insights Application Insights will automatically activate when you start running your SAFE application. You can locate your Application Insights instance directly from within your SAFE Resource Group in the Azure Portal, or from the \"Application Insights\" link in the SAFE App Service. From your Application Insights dashboard, you can drill down to trace all server requests: You can then drill into any specific request, such as the api/init route shown above, in order to see individual requests. From here, you can even track further into any individual call. AI has many more features, so it's worth reading the extensive documentation on the Azure website. How do SAFE apps integrate with Application Insights? Although Application Insights supports monitoring for both client and server, at the current time, the SAFE template only supports the server mode (although you can add support for client events yourself). Server-side support includes: Support in the bundled ARM template to create a free Application Insights instance along with your web application. Automatic configuration of your web application with connection details to the created Application Insights instance. Application support for activating Application Insights in code for e.g. custom events and metrics. AI integration is provided out-of-the-box in the template, since Giraffe uses the standard .NET Core Application Insights SDK in order to communicate with the Application Insights service. It uses the standard Application Insights middleware support for ASP.NET Core, which provides complete tracking of requests, dependencies, errors and live streaming.","title":"Application Insights Integration"},{"location":"legacy-template-azure-ai/#what-is-application-insights","text":"Application Insights is an extensible Application Performance Management (APM) service for web developers on multiple platforms. You can use it to monitor your live web application; it will automatically detect performance anomalies. It includes powerful analytics tools to help you diagnose issues and to understand what users actually do with your app. It's designed to help you continuously improve performance and usability. Features of AI include: Request tracking : monitoring every request, timing and response, with full correlation of operations within a request. Dependency tracking : understand calls to third-party dependencies e.g. databases, web services etc. Failures : Understand which failures are occurring on your site, how often and with full stack traces. User behaviours : Understand user flows such as funnels and retention. Custom Events and Metrics : You can easily create arbitrary metrics and events using the Application Insights SDK for tracing and reporting. Reporting Capabilities : Either use Application Insights's built-in query language to create reports, or automatically export all data into a Storage Account for offline analytics.","title":"What is Application Insights?"},{"location":"legacy-template-azure-ai/#basics-of-working-with-application-insights","text":"Application Insights will automatically activate when you start running your SAFE application. You can locate your Application Insights instance directly from within your SAFE Resource Group in the Azure Portal, or from the \"Application Insights\" link in the SAFE App Service. From your Application Insights dashboard, you can drill down to trace all server requests: You can then drill into any specific request, such as the api/init route shown above, in order to see individual requests. From here, you can even track further into any individual call. AI has many more features, so it's worth reading the extensive documentation on the Azure website.","title":"Basics of working with Application Insights"},{"location":"legacy-template-azure-ai/#how-do-safe-apps-integrate-with-application-insights","text":"Although Application Insights supports monitoring for both client and server, at the current time, the SAFE template only supports the server mode (although you can add support for client events yourself). Server-side support includes: Support in the bundled ARM template to create a free Application Insights instance along with your web application. Automatic configuration of your web application with connection details to the created Application Insights instance. Application support for activating Application Insights in code for e.g. custom events and metrics. AI integration is provided out-of-the-box in the template, since Giraffe uses the standard .NET Core Application Insights SDK in order to communicate with the Application Insights service. It uses the standard Application Insights middleware support for ASP.NET Core, which provides complete tracking of requests, dependencies, errors and live streaming.","title":"How do SAFE apps integrate with Application Insights?"},{"location":"legacy-template-azure-registration/","text":"In order to deploy applications to Azure from the FAKE script created by the SAFE template, you first need to create an Azure account and create an App Registration which allows remote deployments as a one-off task. This section explains how to do this. Creating an Azure Account You'll need to register for an Azure account. This can be achieved quickly and easily at https://azure.microsoft.com . New users are afforded a number of services for free for an entire year, including Azure SQL, Storage and VMs etc. Selecting a Subscription Once you have created your account, make a note of the Azure Subscription ID that you will deploy your SAFE applications into: Log in to your Azure Portal . Select All Services on the left-menu menu and locate Subscriptions in the blade on the right. Make a note of the Subscription ID of the subscription that you wish to deploy your application into. If you just created your Azure account, you'll most likely have a single subscription in the list. Creating an App Registration You now need to create an \"App Registration\" in your Azure Active Directory. This registration allows you to deploy an entire environment directly into Azure, complete with the deployed application, directly from a FAKE script. Create the application Navigate to the Azure Active Directory blade in the Portal. Select App registrations from the menu in the blade. Select New registration . Enter the Name of your application as any name e.g SAFE Deploy Set the Redirect URI as any URI e.g http://safe-stack.github.io/ Hit Register . Grant Permissions There are two ways of authenticating; the first (which we show here) is to use an \"impersonation\" model where you are required to explicitly log in to Azure as part of the deployment process. An alternative way is to use a \"Client Secret\" (which should never be committed into source control) to deploy the application in a non-interactive fashion. Choose API Permissions from the Manage group on the left menu. Choose Add a permission from the top menu in the new blade that appears. Choose Azure Service Management and hit Select . Check the user_impersonation option and hit Select . Hit Done from the Add API Access blade. Choose Authentication from the Manage group on the left menu. Ensure that Treat application as a public client is set to Yes . Hit Save . Copy configuration data Make a note of the Application (client) ID on the blade. Make a note of the Directory (tenant) ID on the blade. Congratulations - you're now ready to use the SAFE FAKE template to perform remote deployments.","title":"Registering with Azure"},{"location":"legacy-template-azure-registration/#creating-an-azure-account","text":"You'll need to register for an Azure account. This can be achieved quickly and easily at https://azure.microsoft.com . New users are afforded a number of services for free for an entire year, including Azure SQL, Storage and VMs etc.","title":"Creating an Azure Account"},{"location":"legacy-template-azure-registration/#selecting-a-subscription","text":"Once you have created your account, make a note of the Azure Subscription ID that you will deploy your SAFE applications into: Log in to your Azure Portal . Select All Services on the left-menu menu and locate Subscriptions in the blade on the right. Make a note of the Subscription ID of the subscription that you wish to deploy your application into. If you just created your Azure account, you'll most likely have a single subscription in the list.","title":"Selecting a Subscription"},{"location":"legacy-template-azure-registration/#creating-an-app-registration","text":"You now need to create an \"App Registration\" in your Azure Active Directory. This registration allows you to deploy an entire environment directly into Azure, complete with the deployed application, directly from a FAKE script.","title":"Creating an App Registration"},{"location":"legacy-template-azure-registration/#create-the-application","text":"Navigate to the Azure Active Directory blade in the Portal. Select App registrations from the menu in the blade. Select New registration . Enter the Name of your application as any name e.g SAFE Deploy Set the Redirect URI as any URI e.g http://safe-stack.github.io/ Hit Register .","title":"Create the application"},{"location":"legacy-template-azure-registration/#grant-permissions","text":"There are two ways of authenticating; the first (which we show here) is to use an \"impersonation\" model where you are required to explicitly log in to Azure as part of the deployment process. An alternative way is to use a \"Client Secret\" (which should never be committed into source control) to deploy the application in a non-interactive fashion. Choose API Permissions from the Manage group on the left menu. Choose Add a permission from the top menu in the new blade that appears. Choose Azure Service Management and hit Select . Check the user_impersonation option and hit Select . Hit Done from the Add API Access blade. Choose Authentication from the Manage group on the left menu. Ensure that Treat application as a public client is set to Yes . Hit Save .","title":"Grant Permissions"},{"location":"legacy-template-azure-registration/#copy-configuration-data","text":"Make a note of the Application (client) ID on the blade. Make a note of the Directory (tenant) ID on the blade. Congratulations - you're now ready to use the SAFE FAKE template to perform remote deployments.","title":"Copy configuration data"},{"location":"legacy-template-docker/","text":"The SAFE template has the ability to easily create a Docker container. The details of the additions to the FAKE script are shown here. For this deployment option SAFE uses the Linux containers and therefore you need docker installed on your machine and configure it to run with Linux containers . Custom FAKE build tasks Bundle - all necessary artifacts for both Server and Client are collected for following Docker target. Docker - based on present Dockerfile , docker image is built and tagged using dockerUser and dockerImageName values from the script. Note: Before running the Docker target, make sure to modify the default dockerUser and dockerImageName values in script. Testing docker image locally Make sure you have docker installed and created the template with --deploy docker option Run dotnet fake build --target docker Run docker run -d -it -p 8085:8085 {dockerUser}/{dockerImageName} Navigate to {dockerHost}:8085 url Docker image The image is based on microsoft/dotnet:runtime . Entrypoint for the image is dotnet Server.dll (with /Server working directory). To allow incoming traffic, port 8085 is exposed. Release to Azure App Service The following part shows how to set up automatic deployment to Microsoft Azure . Currently, SAFE template doesn't contain additional FAKE build targets to deploy a Docker image directly to Azure, so you'll need to grab (and possibly adjust) additional FAKE \"Deploy\" target from SAFE BookStore build script. Following steps assume you've added the necessary build script fragments from SAFE BookStore. Docker Hub Create a new Docker Hub account and a new public repository on Docker Hub. Release script Create a file called release.cmd with the following content and configure your DockerHub credentials: @echo off cls dotnet fake build --target Deploy \"DockerLoginServer=docker.io\" \"DockerImageName=****\" \"DockerUser=****\" \"DockerPassword=***\" %* Don't worry the file is already in .gitignore so your password will not be commited. Initial docker push In order to release a container you need to create a new entry in [RELEASE_NOTES.md] and run release.cmd . This will build the server and client, run all test, put the app into a docker container and push it to your docker hub repo. Azure Portal Go to the Azure Portal and create a new \"Web App for Containers\". Configure the Web App to point to the docker public repository and type in an image and tag. Also look for the \"Webhook Url\" on the portal (It is available in Settings/Container Settings of your deployed app), copy that url and set it as new trigger in your Docker Hub repo. Note that startup command is not necessary. The Dockerfile used to create the docker image exposes port 8085 for the Giraffe server application. This port needs to be mapped to port 80 within the Azure App Service for the application to receive http traffic. Presently this can only be done using the Azure CLI. You can do this easily in Azure Cloud Shell (accessible from the Azure Portal in the top menu bar) using the following command: az webapp config appsettings set --resource-group <resource group name> --name <web app name> --settings WEBSITES_PORT=8085 The above command is effectively the same as running docker run -p 80:8085 <image name> . Now you should be able to reach the website on your yourapp.azurewebsites.net url. Further releases Now everything is set up. By creating new entries in [RELEASE_NOTES.md] and a new run of release.cmd the website should update automatically. Alternatively, you can use the ARM deploy option to do automatic deployment to the Azure App Service platform.","title":"Deploy to Docker"},{"location":"legacy-template-docker/#custom-fake-build-tasks","text":"Bundle - all necessary artifacts for both Server and Client are collected for following Docker target. Docker - based on present Dockerfile , docker image is built and tagged using dockerUser and dockerImageName values from the script. Note: Before running the Docker target, make sure to modify the default dockerUser and dockerImageName values in script.","title":"Custom FAKE build tasks"},{"location":"legacy-template-docker/#testing-docker-image-locally","text":"Make sure you have docker installed and created the template with --deploy docker option Run dotnet fake build --target docker Run docker run -d -it -p 8085:8085 {dockerUser}/{dockerImageName} Navigate to {dockerHost}:8085 url","title":"Testing docker image locally"},{"location":"legacy-template-docker/#docker-image","text":"The image is based on microsoft/dotnet:runtime . Entrypoint for the image is dotnet Server.dll (with /Server working directory). To allow incoming traffic, port 8085 is exposed.","title":"Docker image"},{"location":"legacy-template-docker/#release-to-azure-app-service","text":"The following part shows how to set up automatic deployment to Microsoft Azure . Currently, SAFE template doesn't contain additional FAKE build targets to deploy a Docker image directly to Azure, so you'll need to grab (and possibly adjust) additional FAKE \"Deploy\" target from SAFE BookStore build script. Following steps assume you've added the necessary build script fragments from SAFE BookStore.","title":"Release to Azure App Service"},{"location":"legacy-template-docker/#docker-hub","text":"Create a new Docker Hub account and a new public repository on Docker Hub.","title":"Docker Hub"},{"location":"legacy-template-docker/#release-script","text":"Create a file called release.cmd with the following content and configure your DockerHub credentials: @echo off cls dotnet fake build --target Deploy \"DockerLoginServer=docker.io\" \"DockerImageName=****\" \"DockerUser=****\" \"DockerPassword=***\" %* Don't worry the file is already in .gitignore so your password will not be commited.","title":"Release script"},{"location":"legacy-template-docker/#initial-docker-push","text":"In order to release a container you need to create a new entry in [RELEASE_NOTES.md] and run release.cmd . This will build the server and client, run all test, put the app into a docker container and push it to your docker hub repo.","title":"Initial docker push"},{"location":"legacy-template-docker/#azure-portal","text":"Go to the Azure Portal and create a new \"Web App for Containers\". Configure the Web App to point to the docker public repository and type in an image and tag. Also look for the \"Webhook Url\" on the portal (It is available in Settings/Container Settings of your deployed app), copy that url and set it as new trigger in your Docker Hub repo. Note that startup command is not necessary. The Dockerfile used to create the docker image exposes port 8085 for the Giraffe server application. This port needs to be mapped to port 80 within the Azure App Service for the application to receive http traffic. Presently this can only be done using the Azure CLI. You can do this easily in Azure Cloud Shell (accessible from the Azure Portal in the top menu bar) using the following command: az webapp config appsettings set --resource-group <resource group name> --name <web app name> --settings WEBSITES_PORT=8085 The above command is effectively the same as running docker run -p 80:8085 <image name> . Now you should be able to reach the website on your yourapp.azurewebsites.net url.","title":"Azure Portal"},{"location":"legacy-template-docker/#further-releases","text":"Now everything is set up. By creating new entries in [RELEASE_NOTES.md] and a new run of release.cmd the website should update automatically. Alternatively, you can use the ARM deploy option to do automatic deployment to the Azure App Service platform.","title":"Further releases"},{"location":"legacy-template-fake/","text":"The template uses FAKE to build the application. Generated FAKE script consist of two primary build targets, used for different purposes: \"Run\" target Enter dotnet fake build --target run to build and run the app This target is used for development purposes, and provides a great live-reload experience. It consists of following steps: InstallClient - same as below in Build chain, RestoreServer - dotnet restore is invoked for Server to fetch all necessary packages (note dotnet build is skipped here), Run - most interesting part; in this step 3 separate actions are performed in parallel: dotnet watch run for Server side - compiles, runs Server and watches for changes in Server source files. Whenever a change in any source file is detected, Server is automatically stopped, recompiled and rerun in the background, dotnet fable webpack-dev-server for Client side - compiles Client to JavaScript and runs Webpack dev-server - this in turn recompiles and reloads the client application upon any source file change in Client project, New process is started for http://localhost:8080 to open the URL in default browser \"Build\" target This target is a standard build procedure, consisting of following steps: InstallDotNetCore - here, a required version of dotnet core is read from global.json file and if not yet installed, the script downloads and performs the installation of desired dotnet core SDK. InstallClient - in this step, either NPM or Yarn is invoked (based on which option was chosen when generating project) and it installs all Client dependencies defined in package.json . The step also performs dotnet restore to fetch NuGet-based packages used by front-end. Build - for server side dotnet build command is invoked, and for client side a special dotnet-fable CLI tool using dotnet fable webpack command with -p flag to compile Client project to a single JavaScript bundle file. Note: Extra build steps will be included if you specified the --deploy docker or --deploy azure flag when creating your project. For specific build parameters, go to one of the Deployment Options pages in the menu.","title":"Run and Build the app"},{"location":"legacy-template-fake/#run-target","text":"Enter dotnet fake build --target run to build and run the app This target is used for development purposes, and provides a great live-reload experience. It consists of following steps: InstallClient - same as below in Build chain, RestoreServer - dotnet restore is invoked for Server to fetch all necessary packages (note dotnet build is skipped here), Run - most interesting part; in this step 3 separate actions are performed in parallel: dotnet watch run for Server side - compiles, runs Server and watches for changes in Server source files. Whenever a change in any source file is detected, Server is automatically stopped, recompiled and rerun in the background, dotnet fable webpack-dev-server for Client side - compiles Client to JavaScript and runs Webpack dev-server - this in turn recompiles and reloads the client application upon any source file change in Client project, New process is started for http://localhost:8080 to open the URL in default browser","title":"\"Run\" target"},{"location":"legacy-template-fake/#build-target","text":"This target is a standard build procedure, consisting of following steps: InstallDotNetCore - here, a required version of dotnet core is read from global.json file and if not yet installed, the script downloads and performs the installation of desired dotnet core SDK. InstallClient - in this step, either NPM or Yarn is invoked (based on which option was chosen when generating project) and it installs all Client dependencies defined in package.json . The step also performs dotnet restore to fetch NuGet-based packages used by front-end. Build - for server side dotnet build command is invoked, and for client side a special dotnet-fable CLI tool using dotnet fable webpack command with -p flag to compile Client project to a single JavaScript bundle file. Note: Extra build steps will be included if you specified the --deploy docker or --deploy azure flag when creating your project. For specific build parameters, go to one of the Deployment Options pages in the menu.","title":"\"Build\" target"},{"location":"legacy-template-gcp-appengine/","text":"The SAFE template has the ability to deploy to AppEngine on Google Cloud Platform, GCP, with minimum effort. The deployment relies on AppEngine's flex deployment, that is, it is deploying a docker container. Quickstart First make sure you have gcloud cli tool configured . If you are already familiar with GCP and have gcloud in place, all you need to do to get started is: dotnet new SAFE --deploy gcp-appengine gcloud app create dotnet fake build -t Deploy gcloud app browse What is AppEngine Google Cloud AppEngine is a fully managed serverless application platform. AppEngine supports an environment that is called flexible environment . The flexible environment has native support for many different languages, and also an option of creating a custom environment. Even though .NET is supported, it is limited and focus on aspnet core, so the AppEngine support for SAFE is currently using the custom runtime for more flexibility. Pricing for AppEngine depends on the size of and the number of machines you use. Deployment steps Before you can deploy your AppEngine app you need to create a Google Cloud Platform account , set up the gcloud CLI tool and enable billing . Custom FAKE build tasks Bundle - Runs after the standard Build step. It combines the outputs of the Client and Server application into a single folder. Deploy - Invokes the gcloud command to deploy to AppEngine. How is deploy done? The deploy to AppEngine is not to complicated. The deploy leverage the fact that the AppEngine flex environment allows for custom runtimes. What that mean is that you basically can deploy an app that is defined by a docker container. In its simplest form you just need to have a Dockerfile present that defines the container and that will be built during deploy, and that is exactly how the deploy in this template is configured. We have a app.yaml file, that is used to configure your AppEngine app, and there we define runtime and also environment variables for the app. The Deploy task in the FAKE script invokes gcloud app deploy --quiet , which will deploy the app to the active google cloud project using the definition in the app.yaml and Dockerfile . Viewing the app When deploy is done the app will be publicly available, and all you need to do to access the app is to run gcloud app browse . Things to consider The main focus for the AppEngine template is to get you started. Exactly how you want to do the deployment depends on what your deployment process look like. For a small and simple app what you get here might be enough, but for a more complex scenario you might want to build the docker container separately and publish that to a container registry before running the actual deploy command. That makes it possible to disconnect the actual deploy of the container from the build of the container. The application also has health and liveliness checks disabled, and that is something you might want to enable again in app.yaml and also implement it in your app. The health and liveliness checks is a feature of AppEngine to make sure your app is running as expected.","title":"Deploy to Google Cloud AppEngine"},{"location":"legacy-template-gcp-appengine/#quickstart","text":"First make sure you have gcloud cli tool configured . If you are already familiar with GCP and have gcloud in place, all you need to do to get started is: dotnet new SAFE --deploy gcp-appengine gcloud app create dotnet fake build -t Deploy gcloud app browse","title":"Quickstart"},{"location":"legacy-template-gcp-appengine/#what-is-appengine","text":"Google Cloud AppEngine is a fully managed serverless application platform. AppEngine supports an environment that is called flexible environment . The flexible environment has native support for many different languages, and also an option of creating a custom environment. Even though .NET is supported, it is limited and focus on aspnet core, so the AppEngine support for SAFE is currently using the custom runtime for more flexibility. Pricing for AppEngine depends on the size of and the number of machines you use.","title":"What is AppEngine"},{"location":"legacy-template-gcp-appengine/#deployment-steps","text":"Before you can deploy your AppEngine app you need to create a Google Cloud Platform account , set up the gcloud CLI tool and enable billing .","title":"Deployment steps"},{"location":"legacy-template-gcp-appengine/#custom-fake-build-tasks","text":"Bundle - Runs after the standard Build step. It combines the outputs of the Client and Server application into a single folder. Deploy - Invokes the gcloud command to deploy to AppEngine.","title":"Custom FAKE build tasks"},{"location":"legacy-template-gcp-appengine/#how-is-deploy-done","text":"The deploy to AppEngine is not to complicated. The deploy leverage the fact that the AppEngine flex environment allows for custom runtimes. What that mean is that you basically can deploy an app that is defined by a docker container. In its simplest form you just need to have a Dockerfile present that defines the container and that will be built during deploy, and that is exactly how the deploy in this template is configured. We have a app.yaml file, that is used to configure your AppEngine app, and there we define runtime and also environment variables for the app. The Deploy task in the FAKE script invokes gcloud app deploy --quiet , which will deploy the app to the active google cloud project using the definition in the app.yaml and Dockerfile .","title":"How is deploy done?"},{"location":"legacy-template-gcp-appengine/#viewing-the-app","text":"When deploy is done the app will be publicly available, and all you need to do to access the app is to run gcloud app browse .","title":"Viewing the app"},{"location":"legacy-template-gcp-appengine/#things-to-consider","text":"The main focus for the AppEngine template is to get you started. Exactly how you want to do the deployment depends on what your deployment process look like. For a small and simple app what you get here might be enough, but for a more complex scenario you might want to build the docker container separately and publish that to a container registry before running the actual deploy command. That makes it possible to disconnect the actual deploy of the container from the build of the container. The application also has health and liveliness checks disabled, and that is something you might want to enable again in app.yaml and also implement it in your app. The health and liveliness checks is a feature of AppEngine to make sure your app is running as expected.","title":"Things to consider"},{"location":"legacy-template-gcp-kubernetes/","text":"In order to deploy to Google Cloud Platform, GCP, you first need to create a google cloud project. Creating an account Creating an account is simple and you get some free credits when you sign up try GCP out. Go to https://cloud.google.com/ to sign up for an account. Creating a project A project on GCP is used to organize resources that belongs together one way or another. Creating a project is as simple as just clicking a button an write down the name of the project. If your project name is unique across GCP it will also be your project id , but if there are more than one project named the same you need to figure out your project id . You find the project id in the Home dashboard in the GCP console. Setup gcloud CLI tool The command line interface for GCP is what most people use to interact with the platform instead of clicking in the UI. To get started with the tool you need to install it following the instructions here: https://cloud.google.com/sdk/install . When you have installed gcloud you need to authenticate and also set the default project to work with: Authenticate: gcloud auth login Set project: gcloud config set project PROJECT_ID Try it for free! Google cloud give new users $300 to spend on cloud computing over a 12 month period from when you sign up. In addition to that you also get some free computing resources every month so you can test new things. However, you still need to enable billing and add a credit card to verify who you are. Read more about the Google Cloud Platform Free Tier . As mentioned, you still need to add a credit card to your billing account and this is the way to go about it. Go to Billing and create a billing account, you might have your free credits here already. When the billing account is created go back to the Home dashboard and then select Billing again in the menu. The reason for this is that you first created a billing account that can be used in many projects, but now you also need to link your project to that billing account. On the billing page just click Link a billing account and link your project to the newly created billing account.","title":"Deploy to Google Cloud Kubernetes Engine"},{"location":"legacy-template-gcp-kubernetes/#creating-an-account","text":"Creating an account is simple and you get some free credits when you sign up try GCP out. Go to https://cloud.google.com/ to sign up for an account.","title":"Creating an account"},{"location":"legacy-template-gcp-kubernetes/#creating-a-project","text":"A project on GCP is used to organize resources that belongs together one way or another. Creating a project is as simple as just clicking a button an write down the name of the project. If your project name is unique across GCP it will also be your project id , but if there are more than one project named the same you need to figure out your project id . You find the project id in the Home dashboard in the GCP console.","title":"Creating a project"},{"location":"legacy-template-gcp-kubernetes/#setup-gcloud-cli-tool","text":"The command line interface for GCP is what most people use to interact with the platform instead of clicking in the UI. To get started with the tool you need to install it following the instructions here: https://cloud.google.com/sdk/install . When you have installed gcloud you need to authenticate and also set the default project to work with: Authenticate: gcloud auth login Set project: gcloud config set project PROJECT_ID","title":"Setup gcloud CLI tool"},{"location":"legacy-template-gcp-kubernetes/#try-it-for-free","text":"Google cloud give new users $300 to spend on cloud computing over a 12 month period from when you sign up. In addition to that you also get some free computing resources every month so you can test new things. However, you still need to enable billing and add a credit card to verify who you are. Read more about the Google Cloud Platform Free Tier . As mentioned, you still need to add a credit card to your billing account and this is the way to go about it. Go to Billing and create a billing account, you might have your free credits here already. When the billing account is created go back to the Home dashboard and then select Billing again in the menu. The reason for this is that you first created a billing account that can be used in many projects, but now you also need to link your project to that billing account. On the billing page just click Link a billing account and link your project to the newly created billing account.","title":"Try it for free!"},{"location":"legacy-template-google-cloud/","text":"In order to deploy to Google Cloud Platform, GCP, you first need to create a google cloud project. Creating an account Creating an account is simple and you get some free credits when you sign up try GCP out. Go to https://cloud.google.com/ to sign up for an account. Creating a project A project on GCP is used to organize resources that belongs together one way or another. Creating a project is as simple as just clicking a button an write down the name of the project. If your project name is unique across GCP it will also be your project id , but if there are more than one project named the same you need to figure out your project id . You find the project id in the Home dashboard in the GCP console. Setup gcloud CLI tool The command line interface for GCP is what most people use to interact with the platform instead of clicking in the UI. To get started with the tool you need to install it following the instructions here: https://cloud.google.com/sdk/install . When you have installed gcloud you need to authenticate and also set the default project to work with: Authenticate: gcloud auth login Set project: gcloud config set project PROJECT_ID Try it for free! Google cloud give new users $300 to spend on cloud computing over a 12 month period from when you sign up. In addition to that you also get some free computing resources every month so you can test new things. However, you still need to enable billing and add a credit card to verify who you are. Read more about the Google Cloud Platform Free Tier . As mentioned, you still need to add a credit card to your billing account and this is the way to go about it. Go to Billing and create a billing account, you might have your free credits here already. When the billing account is created go back to the Home dashboard and then select Billing again in the menu. The reason for this is that you first created a billing account that can be used in many projects, but now you also need to link your project to that billing account. On the billing page just click Link a billing account and link your project to the newly created billing account.","title":"Registering with Google Cloud"},{"location":"legacy-template-google-cloud/#creating-an-account","text":"Creating an account is simple and you get some free credits when you sign up try GCP out. Go to https://cloud.google.com/ to sign up for an account.","title":"Creating an account"},{"location":"legacy-template-google-cloud/#creating-a-project","text":"A project on GCP is used to organize resources that belongs together one way or another. Creating a project is as simple as just clicking a button an write down the name of the project. If your project name is unique across GCP it will also be your project id , but if there are more than one project named the same you need to figure out your project id . You find the project id in the Home dashboard in the GCP console.","title":"Creating a project"},{"location":"legacy-template-google-cloud/#setup-gcloud-cli-tool","text":"The command line interface for GCP is what most people use to interact with the platform instead of clicking in the UI. To get started with the tool you need to install it following the instructions here: https://cloud.google.com/sdk/install . When you have installed gcloud you need to authenticate and also set the default project to work with: Authenticate: gcloud auth login Set project: gcloud config set project PROJECT_ID","title":"Setup gcloud CLI tool"},{"location":"legacy-template-google-cloud/#try-it-for-free","text":"Google cloud give new users $300 to spend on cloud computing over a 12 month period from when you sign up. In addition to that you also get some free computing resources every month so you can test new things. However, you still need to enable billing and add a credit card to verify who you are. Read more about the Google Cloud Platform Free Tier . As mentioned, you still need to add a credit card to your billing account and this is the way to go about it. Go to Billing and create a billing account, you might have your free credits here already. When the billing account is created go back to the Home dashboard and then select Billing again in the menu. The reason for this is that you first created a billing account that can be used in many projects, but now you also need to link your project to that billing account. On the billing page just click Link a billing account and link your project to the newly created billing account.","title":"Try it for free!"},{"location":"legacy-template-heroku/","text":"In order to deploy to Heroku, you first need to create a Heroku account and download Heroku CLI. Creating an account Creating an account is simple and free. Go to https://signup.heroku.com/ to sign up for an account. Setup Heroku CLI tool The command line interface for Heroku is what the template uses to interact with the platform and create the projects. To get started with the tool you need to install it following the instructions here: https://devcenter.heroku.com/articles/heroku-cli . When you have installed heroku you need to authenticate: Authenticate: heroku login Quickstart After installing Heroku CLI and authenticating, the template makes the process of creating, configuring and deploying the project very straightforward: dotnet new SAFE --deploy heroku dotnet fake build -t Configure <optional app:create arguments> dotnet fake build -t Deploy After these steps if everything went right, the project should open on the browser. How is deploy done? When you are ready to deploy, you need to add your changes to git staging area and create a commit. After you push your changes, Heroku will compile the project using the Bundle target, creating a Procfile that tells the instance what command it will need to run. Custom FAKE build tasks Configure - Needs to be run only once when creating the project. Makes the following configurations: Creates the project using the heroku apps:create command. If no argument is supplied, heroku generates a random name for the project, otherwise it tries to use the supplied name. Initializes the current folder as a Git repository and commits everything. Links the created repository to the project's remote git. Configures the buildpack that compiles and run the project on heroku's server. Deploy - Serves as an shortcut for git push heroku master . Uploads the current commit to the server so it can be deployed.","title":"Deploy to Heroku"},{"location":"legacy-template-heroku/#creating-an-account","text":"Creating an account is simple and free. Go to https://signup.heroku.com/ to sign up for an account.","title":"Creating an account"},{"location":"legacy-template-heroku/#setup-heroku-cli-tool","text":"The command line interface for Heroku is what the template uses to interact with the platform and create the projects. To get started with the tool you need to install it following the instructions here: https://devcenter.heroku.com/articles/heroku-cli . When you have installed heroku you need to authenticate: Authenticate: heroku login","title":"Setup Heroku CLI tool"},{"location":"legacy-template-heroku/#quickstart","text":"After installing Heroku CLI and authenticating, the template makes the process of creating, configuring and deploying the project very straightforward: dotnet new SAFE --deploy heroku dotnet fake build -t Configure <optional app:create arguments> dotnet fake build -t Deploy After these steps if everything went right, the project should open on the browser.","title":"Quickstart"},{"location":"legacy-template-heroku/#how-is-deploy-done","text":"When you are ready to deploy, you need to add your changes to git staging area and create a commit. After you push your changes, Heroku will compile the project using the Bundle target, creating a Procfile that tells the instance what command it will need to run.","title":"How is deploy done?"},{"location":"legacy-template-heroku/#custom-fake-build-tasks","text":"Configure - Needs to be run only once when creating the project. Makes the following configurations: Creates the project using the heroku apps:create command. If no argument is supplied, heroku generates a random name for the project, otherwise it tries to use the supplied name. Initializes the current folder as a Git repository and commits everything. Links the created repository to the project's remote git. Configures the buildpack that compiles and run the project on heroku's server. Deploy - Serves as an shortcut for git push heroku master . Uploads the current commit to the server so it can be deployed.","title":"Custom FAKE build tasks"},{"location":"legacy-template-iis/","text":"Deploy to IIS The SAFE template can be easily deployed to IIS , either on-premise or on a hosted virtual machine running Windows. To get started, scaffold the template with the deploy option set to IIS: dotnet new SAFE --deploy iis The template will include a custom FAKE build target called Bundle to package your application and make it ready for deployment, run this target using: dotnet fake build --target bundle When the target finishes running succesfully, you will have a new deploy directory with this structure: {template root} | | - deploy | - Client | - Server Your app is now ready for deployment. Setting up IIS Create an Application Pool Hosting dotnet core on IIS does not support Application Pool sharing which means every dotnet application has it's own application pool, create a new one, give it the name of the application, for example SafeApp and make sure to set the .NET CLR version to No Managed Code : Required IIS Modules: ASP.NET Core module for Giraffe and Saturn HttpPlatformHandler for Suave ASP.NET Core module Like with any dotnet core app hosted within IIS, you will need to have the AspNetCoreModule installed in IIS * . This is a native module that starts your dotnet app in a child process of IIS and proxies all http requests coming from IIS to the application. Note that for netcoreapp2.2, you will need AspNetCoreModule and not AspNetCoreModuleV2. HttpPlatformHandler (applies to Suave) Because Suave does not run on Kestrel, it does not use built-in IIS integration from ASP.NET Core, and therefore, Suave will use the generic HttpPlatformHandler module in IIS. Make sure you have the module installed on your IIS server: There is a catch when using Suave and HttpPlatformHandler: you cannot create sub-applications within an IIS website (root level application) because the virtual paths will break how the routing works in Suave, meaning that you have to add a new website for a Suave application. Another thing to considor when deploying Suave, is that you have to change a part your web.config manually, from this: <httpPlatform stdoutLogEnabled= \"true\" stdoutLogFile= \"suave.log\" startupTimeLimit= \"20\" processPath= \"dotnet\" arguments= \"./Server\" /> to this: <httpPlatform stdoutLogEnabled= \"true\" stdoutLogFile= \"suave.log\" startupTimeLimit= \"20\" processPath= \"dotnet\" arguments= \"C:\\full\\path\\to\\deployed\\Server.dll\" /> because otherwise the HttpPlatformHandler will not be able to figure out where the application exactly is. Add Application (applies to Giraffe and Saturn) Now that the application pool is setup, we can add our application to it. When Adding an application, you give it an ailias, and a physical path. In our case, because this is the only application in the application pool, lets just name it SafeApp and the physical path of the application is the Server directory of the bundled deployment directory: { template root } | | - deploy | - Client | - Server <--- the physical path Here I am adding the application to the default (root) website of IIS Now your application should be up and running! Add Website (applies to Suave) Adding a website is the same as adding a sub-application, using a single application pool and having the physical path of the application be the Server directory of the bundled deployment directory: { template root } | | - deploy | - Client | - Server <--- the physical path but the difference is that now you have choose a different port for the application: for this example, I have chosen to run the application on port 8090 and web.config looks like this: <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <system.webServer> <handlers> <remove name= \"httpplatformhandler\" /> <add name= \"httpplatformhandler\" path= \"*\" verb= \"*\" modules= \"httpPlatformHandler\" resourceType= \"Unspecified\" /> </handlers> <httpPlatform stdoutLogEnabled= \"true\" stdoutLogFile= \"suave.log\" startupTimeLimit= \"20\" processPath= \"dotnet\" arguments= \"C:\\projects\\SafeApp\\deploy\\Server\\Server.dll\" /> </system.webServer> </configuration> Notice how I am using the full path of the compiled Server.dll from my deployment directory. Now click OK and your Suave app should be up and running: Deploying a new version Stop the application pool Replace the contents of the deployment directory Restart/Recycle the application pool Client developement considorations (applies to Giraffe and Saturn) When hosting inside IIS, your application will most likely run inside a virtual path like in the above example. This means that requests made using fetch will not work by default: // will not work fetchAs<Customer list> \"/api/customers\" To solve this, the template includes a module ServerPath with a function to normalize the routes, so instead of the above you would have: // this works fetchAs<Customer list> (ServerPath.normalize \"/api/customers\") You will have to this for every request you make, unless you are using remoting which is done only once during proxy setup. Be careful not to forget ServerPath.normalize , because if you forget it during developement, the route still works because there is no IIS but then when you deploy the app, the route won't work any more because of the virtual paths.","title":"Deploy to IIS"},{"location":"legacy-template-iis/#deploy-to-iis","text":"The SAFE template can be easily deployed to IIS , either on-premise or on a hosted virtual machine running Windows. To get started, scaffold the template with the deploy option set to IIS: dotnet new SAFE --deploy iis The template will include a custom FAKE build target called Bundle to package your application and make it ready for deployment, run this target using: dotnet fake build --target bundle When the target finishes running succesfully, you will have a new deploy directory with this structure: {template root} | | - deploy | - Client | - Server Your app is now ready for deployment.","title":"Deploy to IIS"},{"location":"legacy-template-iis/#setting-up-iis","text":"","title":"Setting up IIS"},{"location":"legacy-template-iis/#create-an-application-pool","text":"Hosting dotnet core on IIS does not support Application Pool sharing which means every dotnet application has it's own application pool, create a new one, give it the name of the application, for example SafeApp and make sure to set the .NET CLR version to No Managed Code :","title":"Create an Application Pool"},{"location":"legacy-template-iis/#required-iis-modules","text":"ASP.NET Core module for Giraffe and Saturn HttpPlatformHandler for Suave","title":"Required IIS Modules:"},{"location":"legacy-template-iis/#aspnet-core-module","text":"Like with any dotnet core app hosted within IIS, you will need to have the AspNetCoreModule installed in IIS * . This is a native module that starts your dotnet app in a child process of IIS and proxies all http requests coming from IIS to the application. Note that for netcoreapp2.2, you will need AspNetCoreModule and not AspNetCoreModuleV2.","title":"ASP.NET Core module"},{"location":"legacy-template-iis/#httpplatformhandler-applies-to-suave","text":"Because Suave does not run on Kestrel, it does not use built-in IIS integration from ASP.NET Core, and therefore, Suave will use the generic HttpPlatformHandler module in IIS. Make sure you have the module installed on your IIS server: There is a catch when using Suave and HttpPlatformHandler: you cannot create sub-applications within an IIS website (root level application) because the virtual paths will break how the routing works in Suave, meaning that you have to add a new website for a Suave application. Another thing to considor when deploying Suave, is that you have to change a part your web.config manually, from this: <httpPlatform stdoutLogEnabled= \"true\" stdoutLogFile= \"suave.log\" startupTimeLimit= \"20\" processPath= \"dotnet\" arguments= \"./Server\" /> to this: <httpPlatform stdoutLogEnabled= \"true\" stdoutLogFile= \"suave.log\" startupTimeLimit= \"20\" processPath= \"dotnet\" arguments= \"C:\\full\\path\\to\\deployed\\Server.dll\" /> because otherwise the HttpPlatformHandler will not be able to figure out where the application exactly is.","title":"HttpPlatformHandler (applies to Suave)"},{"location":"legacy-template-iis/#add-application-applies-to-giraffe-and-saturn","text":"Now that the application pool is setup, we can add our application to it. When Adding an application, you give it an ailias, and a physical path. In our case, because this is the only application in the application pool, lets just name it SafeApp and the physical path of the application is the Server directory of the bundled deployment directory: { template root } | | - deploy | - Client | - Server <--- the physical path Here I am adding the application to the default (root) website of IIS Now your application should be up and running!","title":"Add Application (applies to Giraffe and Saturn)"},{"location":"legacy-template-iis/#add-website-applies-to-suave","text":"Adding a website is the same as adding a sub-application, using a single application pool and having the physical path of the application be the Server directory of the bundled deployment directory: { template root } | | - deploy | - Client | - Server <--- the physical path but the difference is that now you have choose a different port for the application: for this example, I have chosen to run the application on port 8090 and web.config looks like this: <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <system.webServer> <handlers> <remove name= \"httpplatformhandler\" /> <add name= \"httpplatformhandler\" path= \"*\" verb= \"*\" modules= \"httpPlatformHandler\" resourceType= \"Unspecified\" /> </handlers> <httpPlatform stdoutLogEnabled= \"true\" stdoutLogFile= \"suave.log\" startupTimeLimit= \"20\" processPath= \"dotnet\" arguments= \"C:\\projects\\SafeApp\\deploy\\Server\\Server.dll\" /> </system.webServer> </configuration> Notice how I am using the full path of the compiled Server.dll from my deployment directory. Now click OK and your Suave app should be up and running:","title":"Add Website (applies to Suave)"},{"location":"legacy-template-iis/#deploying-a-new-version","text":"Stop the application pool Replace the contents of the deployment directory Restart/Recycle the application pool","title":"Deploying a new version"},{"location":"legacy-template-iis/#client-developement-considorations-applies-to-giraffe-and-saturn","text":"When hosting inside IIS, your application will most likely run inside a virtual path like in the above example. This means that requests made using fetch will not work by default: // will not work fetchAs<Customer list> \"/api/customers\" To solve this, the template includes a module ServerPath with a function to normalize the routes, so instead of the above you would have: // this works fetchAs<Customer list> (ServerPath.normalize \"/api/customers\") You will have to this for every request you make, unless you are using remoting which is done only once during proxy setup. Be careful not to forget ServerPath.normalize , because if you forget it during developement, the route still works because there is no IIS but then when you deploy the app, the route won't work any more because of the virtual paths.","title":"Client developement considorations (applies to Giraffe and Saturn)"},{"location":"legacy-template-overview/","text":"The SAFE Template is a dotnet CLI template for SAFE Stack projects, designed to get you up and running as quickly as possible, with flexible options to suit your application. The template gets you up and running with the most common elements of the stack: Saturn or Giraffe Fable for client-side F# Elmish for web UI Fulma for consistent web styling Docker , Azure App Service , Google Cloud AppEngine , Google Cloud Kubernetes Engine or Heroku deployment models for hosting. Using the template Refer to the Quick Start guide to see basic guidance on how to install and use the template. Examples Create a SAFE application using all defaults: dotnet new SAFE Create a SAFE application using Giraffe with Fable Remoting: dotnet new SAFE --server giraffe --communication remoting Create a SAFE application using Giraffe with Fulma 'Landing' : dotnet new SAFE --server giraffe --layout fulma-landing Template options The template provides the ability to customise the created application. You can see template version and available options by running dotnet new SAFE --help . Server Configures the SAFE app to use one of two different back-end hosting platforms. Usage: dotnet new SAFE --server <server> Where <server> is one of: saturn : Creates a SAFE app running on Saturn on top of Giraffe (default) . giraffe : Creates a SAFE app running on Giraffe only. Layout Configures the SAFE app to apply a CSS Framework to the UI template. Currently supports just Fulma bindings Usage: dotnet new SAFE --layout <layout> Where <layout> is one of: none : don't add any CSS framework. fulma-basic : adds Fulma basic template (default) . fulma-admin : adds Fulma with the 'Admin' Bulma template. fulma-cover : adds Fulma with the 'Cover' Bulma template. fulma-hero : adds Fulma with the 'Hero' Bulma template. fulma-landing : adds Fulma with the 'Landing' Bulma template. fulma-login : adds Fulma with the 'Login' Bulma template. If you want to use Feliz and Feliz.Bulma as an alternative html DSL you can also try the SAFE.Simplified template. Communication Configures the SAFE app to use one of available means of communication between client and server. Currently supports Fable.Remoting and Elmish.Bridge . If this argument is not supplied, client / server communication will be handled through the standard routing and serialization mechanism of the server. See here for an overview of Fable.Remoting, Elmish.Bridge and the alternatives for sharing data between client and server. Usage: dotnet new SAFE --communication <communication model> Where <communication model> is one of: none : don't add any additional libraries for client-server communication (default) remoting : add Fable.Remoting to the template. bridge : add Elmish.Bridge to the template. Pattern Configures Client app to use one of available patterns. Currently supports only either default Elmish architecture with Commands or simple (no Commands) Elmish Architecture in conjunction with Elmish.Streams library for reactive programming Usage: dotnet new SAFE --pattern <pattern model> Where <pattern model> is one of: default : use standard Elmish architecture with Commands (default) streams : use simple Elmish architecture without Commands + Elmish.Streams for reactive pattern Deploy Optionally configures the SAFE app to elements needed for deploying to one of two different hosting models. If this argument is not supplied, no explicit support for any hosting model will be provided. Usage: dotnet new SAFE --deploy <hosting model> Where <hosting model> is one of: none : don't add FAKE targets to deploy (default) . docker : Adds FAKE targets that bundles and build a Docker image. See here for more details about Docker deployment. azure : Adds FAKE targets and an Azure Resource Manager (ARM) template that allows deployment to the Azure App Service plus an Azure Application Insights instance. See here for more details about Azure deployment. gcp-appengine : Adds FAKE targets to deploy to Google Cloud AppEngine . gcp-kubernetes : Adds FAKE targets to deploy to Google Cloud Kubernetes Engine . iis : Adds FAKE targets and client paths normalization to easily publish the application to IIS . heroku : Adds FAKE targets to deploy to Heroku . JS Deps Configures the SAFE app to use either Yarn or NPM for JS package management. Usage: dotnet new SAFE --js-deps <package manager> Where <package manager> is one of: yarn : uses Yarn for JS package management (default) . npm : uses NPM for JS package management. If you use NPM, you'll also need NPX to run scripts.","title":"Overview"},{"location":"legacy-template-overview/#using-the-template","text":"Refer to the Quick Start guide to see basic guidance on how to install and use the template.","title":"Using the template"},{"location":"legacy-template-overview/#examples","text":"Create a SAFE application using all defaults: dotnet new SAFE Create a SAFE application using Giraffe with Fable Remoting: dotnet new SAFE --server giraffe --communication remoting Create a SAFE application using Giraffe with Fulma 'Landing' : dotnet new SAFE --server giraffe --layout fulma-landing","title":"Examples"},{"location":"legacy-template-overview/#template-options","text":"The template provides the ability to customise the created application. You can see template version and available options by running dotnet new SAFE --help .","title":"Template options"},{"location":"legacy-template-overview/#server","text":"Configures the SAFE app to use one of two different back-end hosting platforms. Usage: dotnet new SAFE --server <server> Where <server> is one of: saturn : Creates a SAFE app running on Saturn on top of Giraffe (default) . giraffe : Creates a SAFE app running on Giraffe only.","title":"Server"},{"location":"legacy-template-overview/#layout","text":"Configures the SAFE app to apply a CSS Framework to the UI template. Currently supports just Fulma bindings Usage: dotnet new SAFE --layout <layout> Where <layout> is one of: none : don't add any CSS framework. fulma-basic : adds Fulma basic template (default) . fulma-admin : adds Fulma with the 'Admin' Bulma template. fulma-cover : adds Fulma with the 'Cover' Bulma template. fulma-hero : adds Fulma with the 'Hero' Bulma template. fulma-landing : adds Fulma with the 'Landing' Bulma template. fulma-login : adds Fulma with the 'Login' Bulma template. If you want to use Feliz and Feliz.Bulma as an alternative html DSL you can also try the SAFE.Simplified template.","title":"Layout"},{"location":"legacy-template-overview/#communication","text":"Configures the SAFE app to use one of available means of communication between client and server. Currently supports Fable.Remoting and Elmish.Bridge . If this argument is not supplied, client / server communication will be handled through the standard routing and serialization mechanism of the server. See here for an overview of Fable.Remoting, Elmish.Bridge and the alternatives for sharing data between client and server. Usage: dotnet new SAFE --communication <communication model> Where <communication model> is one of: none : don't add any additional libraries for client-server communication (default) remoting : add Fable.Remoting to the template. bridge : add Elmish.Bridge to the template.","title":"Communication"},{"location":"legacy-template-overview/#pattern","text":"Configures Client app to use one of available patterns. Currently supports only either default Elmish architecture with Commands or simple (no Commands) Elmish Architecture in conjunction with Elmish.Streams library for reactive programming Usage: dotnet new SAFE --pattern <pattern model> Where <pattern model> is one of: default : use standard Elmish architecture with Commands (default) streams : use simple Elmish architecture without Commands + Elmish.Streams for reactive pattern","title":"Pattern"},{"location":"legacy-template-overview/#deploy","text":"Optionally configures the SAFE app to elements needed for deploying to one of two different hosting models. If this argument is not supplied, no explicit support for any hosting model will be provided. Usage: dotnet new SAFE --deploy <hosting model> Where <hosting model> is one of: none : don't add FAKE targets to deploy (default) . docker : Adds FAKE targets that bundles and build a Docker image. See here for more details about Docker deployment. azure : Adds FAKE targets and an Azure Resource Manager (ARM) template that allows deployment to the Azure App Service plus an Azure Application Insights instance. See here for more details about Azure deployment. gcp-appengine : Adds FAKE targets to deploy to Google Cloud AppEngine . gcp-kubernetes : Adds FAKE targets to deploy to Google Cloud Kubernetes Engine . iis : Adds FAKE targets and client paths normalization to easily publish the application to IIS . heroku : Adds FAKE targets to deploy to Heroku .","title":"Deploy"},{"location":"legacy-template-overview/#js-deps","text":"Configures the SAFE app to use either Yarn or NPM for JS package management. Usage: dotnet new SAFE --js-deps <package manager> Where <package manager> is one of: yarn : uses Yarn for JS package management (default) . npm : uses NPM for JS package management. If you use NPM, you'll also need NPX to run scripts.","title":"JS Deps"},{"location":"news/","text":"News and Announcements 2020 22nd August - SAFE v2 Launches! It's taken a while, but we're delighted to announce the launch of SAFE v2. The new template has been drastically slimmed down and provides a highly streamlined approach, whilst we've incorporated requested features such as testing support out of the box. We're looking forward to building on the new template with improved documentation, a set of easy-to-follow recipies for common tasks as well as new demos, exercises and a set of new wrappers around popular JS and React libraries. 2018 5th August We're pleased to see that the Suave team have clarified their license and explicitly removed the dependency on the Logary package. However, our decision to remove Suave from the SAFE stack remains: Suave no longer forms a part of the strategic goals of the SAFE project , and our server-side focus remains on improving the experience for both Giraffe and Saturn. We nonetheless wish the Suave project, team and contributors the best of luck for the future. 18th June Due to the unclear future regarding the licensing of Suave and its dependencies, the SAFE team have today made the unamimous decision to remove Suave as a recommended option on the SAFE stack . We will no longer provide guidance on integrating Suave with the SAFE stack, nor will we maintain existing capabilities for it in SAFE tooling. Our default recommendation for SAFE stack applications is to use Saturn or Giraffe directly, running on top of Kestel on ASP.NET. SAFE will continue to promote all libraries, frameworks and toolchains that provide clear and consistent licensing, do not aim to discriminate against specific libraries on a commercial basis and promote open discussion.","title":"News"},{"location":"news/#news-and-announcements","text":"","title":"News and Announcements"},{"location":"news/#2020","text":"","title":"2020"},{"location":"news/#22nd-august-safe-v2-launches","text":"It's taken a while, but we're delighted to announce the launch of SAFE v2. The new template has been drastically slimmed down and provides a highly streamlined approach, whilst we've incorporated requested features such as testing support out of the box. We're looking forward to building on the new template with improved documentation, a set of easy-to-follow recipies for common tasks as well as new demos, exercises and a set of new wrappers around popular JS and React libraries.","title":"22nd August - SAFE v2 Launches!"},{"location":"news/#2018","text":"","title":"2018"},{"location":"news/#5th-august","text":"We're pleased to see that the Suave team have clarified their license and explicitly removed the dependency on the Logary package. However, our decision to remove Suave from the SAFE stack remains: Suave no longer forms a part of the strategic goals of the SAFE project , and our server-side focus remains on improving the experience for both Giraffe and Saturn. We nonetheless wish the Suave project, team and contributors the best of luck for the future.","title":"5th August"},{"location":"news/#18th-june","text":"Due to the unclear future regarding the licensing of Suave and its dependencies, the SAFE team have today made the unamimous decision to remove Suave as a recommended option on the SAFE stack . We will no longer provide guidance on integrating Suave with the SAFE stack, nor will we maintain existing capabilities for it in SAFE tooling. Our default recommendation for SAFE stack applications is to use Saturn or Giraffe directly, running on top of Kestel on ASP.NET. SAFE will continue to promote all libraries, frameworks and toolchains that provide clear and consistent licensing, do not aim to discriminate against specific libraries on a commercial basis and promote open discussion.","title":"18th June"},{"location":"overview/","text":"SAFE Stack components The SAFE acronym is made up of four separate components: S aturn for back-end services in F# A zure as a hosting platform plus associated platform services F able for running F# in the web browser E lmish for client-side user interfaces flowchart TB subgraph Azure App Service Host Saturn(Saturn) Elmish(Elmish) <--> Fable(Fable) Saturn <-- HTTP --> Fable end Saturn The Saturn library builds on top of the solid foundation of both the F#-friendly Giraffe and the high performance, rock-solid ASP.NET Core web server to provide a set of optional abstractions which make configuring web applications and constructing complex routes extremely easy to achieve. Saturn can host RESTful API endpoints, drive static websites or server-generated content, all inside an easy-to-learn functional programming model. Microsoft Azure Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions. Fable Fable is an F# to JavaScript compiler powered by Babel, designed to produce readable and standard code. Fable allows you to create applications for the browser written entirely in F#, whilst also allowing you to interact with native Javascript as needed. Elmish The Elmish model allows you to construct user interfaces running in the browser using a functional programming model. Modelled on the Elm application model, Elmish uses the Model-View-Update paradigm to allow you to write applications that are simple to reason about. Elmish sits on top of the React framework. Further reading Please also feel free to read this blog series on the Compositional IT website for more details on the history of SAFE. Are there alternative components in the SAFE stack? Yes, absolutely. The above components are what we recommended as the default SAFE stack, but you can of course replace the components with alternatives as you see fit. Here are some alternative technologies which are also recommended by the SAFE team if the basic stack does not fit your needs: Giraffe is a programming model designed for F# that runs on ASP.NET Core. As Saturn runs on top of Giraffe, you automatically get full access to it, but nonetheless it is entirely possible to write applications solely in Giraffe. Freya is an alternative F#-first web stack which has a pluggable runtime model which allows it to be hosted in a variety of web servers including ASP.NET Core. AWS is Amazon's cloud compute offering, providing a large number of services available globally. WebSharper is a complete end-to-end programming stack, comprising both server- and client-side components. It supports both F# and C# programming models. Falco is a toolkit for building functional-first, fast and fault-tolerant web applications using F#. Built upon the high-performance primitives of ASP.NET Core and optimized for building HTTP applications quickly.","title":"SAFE Stack Overview"},{"location":"overview/#safe-stack-components","text":"The SAFE acronym is made up of four separate components: S aturn for back-end services in F# A zure as a hosting platform plus associated platform services F able for running F# in the web browser E lmish for client-side user interfaces flowchart TB subgraph Azure App Service Host Saturn(Saturn) Elmish(Elmish) <--> Fable(Fable) Saturn <-- HTTP --> Fable end","title":"SAFE Stack components"},{"location":"overview/#saturn","text":"The Saturn library builds on top of the solid foundation of both the F#-friendly Giraffe and the high performance, rock-solid ASP.NET Core web server to provide a set of optional abstractions which make configuring web applications and constructing complex routes extremely easy to achieve. Saturn can host RESTful API endpoints, drive static websites or server-generated content, all inside an easy-to-learn functional programming model.","title":"Saturn"},{"location":"overview/#microsoft-azure","text":"Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.","title":"Microsoft Azure"},{"location":"overview/#fable","text":"Fable is an F# to JavaScript compiler powered by Babel, designed to produce readable and standard code. Fable allows you to create applications for the browser written entirely in F#, whilst also allowing you to interact with native Javascript as needed.","title":"Fable"},{"location":"overview/#elmish","text":"The Elmish model allows you to construct user interfaces running in the browser using a functional programming model. Modelled on the Elm application model, Elmish uses the Model-View-Update paradigm to allow you to write applications that are simple to reason about. Elmish sits on top of the React framework.","title":"Elmish"},{"location":"overview/#further-reading","text":"Please also feel free to read this blog series on the Compositional IT website for more details on the history of SAFE.","title":"Further reading"},{"location":"overview/#are-there-alternative-components-in-the-safe-stack","text":"Yes, absolutely. The above components are what we recommended as the default SAFE stack, but you can of course replace the components with alternatives as you see fit. Here are some alternative technologies which are also recommended by the SAFE team if the basic stack does not fit your needs: Giraffe is a programming model designed for F# that runs on ASP.NET Core. As Saturn runs on top of Giraffe, you automatically get full access to it, but nonetheless it is entirely possible to write applications solely in Giraffe. Freya is an alternative F#-first web stack which has a pluggable runtime model which allows it to be hosted in a variety of web servers including ASP.NET Core. AWS is Amazon's cloud compute offering, providing a large number of services available globally. WebSharper is a complete end-to-end programming stack, comprising both server- and client-side components. It supports both F# and C# programming models. Falco is a toolkit for building functional-first, fast and fault-tolerant web applications using F#. Built upon the high-performance primitives of ASP.NET Core and optimized for building HTTP applications quickly.","title":"Are there alternative components in the SAFE stack?"},{"location":"quickstart/","text":"This page provides some basic guidance on getting up and running with your first SAFE application. Install pre-requisites You'll need to install the following pre-requisites in order to build SAFE applications The .NET Core SDK 3.1 node.js (>= 8.0) npm Azure CLI (optional - required for Azure deployments) Install an F# code editor You'll also want an IDE to create F# applications. We recommend one of the following great IDEs: VS Code + Ionide extension Visual Studio 2019 Jetbrains Rider Create your first SAFE app Open a command prompt Create a new directory on your machine and navigate into it Enter dotnet new -i SAFE.Template to install the SAFE project template ( only required once ) Enter dotnet new SAFE to create a new SAFE project Enter dotnet tool restore to install local tools like FAKE. Enter dotnet fake build --target run to build and run the app Open a web browser and navigate to http://localhost:8080. Congratulations - after a short delay, you'll be presented with a basic SAFE application running in your browser! The application will by default run in \"development mode\", which means it automatically watches your project for changes; whenever you save a file in the client project it will refresh the browser automatically ; if you save a file in the server project it will also restart the server in the background. The standard template creates an opinionated SAFE Stack app that contains everything you'll need to start developing, testing and deploying applications into Azure. Alternatively there is a \"bare-bones\" SAFE Stack app with minimal value-add features. Take a look at the template options to see a side by side comparison of features available between the standard and minimal template. Troubleshooting Still have issues getting started? Check out the troubleshooting page.","title":"Quick Start"},{"location":"quickstart/#install-pre-requisites","text":"You'll need to install the following pre-requisites in order to build SAFE applications The .NET Core SDK 3.1 node.js (>= 8.0) npm Azure CLI (optional - required for Azure deployments)","title":"Install pre-requisites"},{"location":"quickstart/#install-an-f-code-editor","text":"You'll also want an IDE to create F# applications. We recommend one of the following great IDEs: VS Code + Ionide extension Visual Studio 2019 Jetbrains Rider","title":"Install an F# code editor"},{"location":"quickstart/#create-your-first-safe-app","text":"Open a command prompt Create a new directory on your machine and navigate into it Enter dotnet new -i SAFE.Template to install the SAFE project template ( only required once ) Enter dotnet new SAFE to create a new SAFE project Enter dotnet tool restore to install local tools like FAKE. Enter dotnet fake build --target run to build and run the app Open a web browser and navigate to http://localhost:8080. Congratulations - after a short delay, you'll be presented with a basic SAFE application running in your browser! The application will by default run in \"development mode\", which means it automatically watches your project for changes; whenever you save a file in the client project it will refresh the browser automatically ; if you save a file in the server project it will also restart the server in the background. The standard template creates an opinionated SAFE Stack app that contains everything you'll need to start developing, testing and deploying applications into Azure. Alternatively there is a \"bare-bones\" SAFE Stack app with minimal value-add features. Take a look at the template options to see a side by side comparison of features available between the standard and minimal template.","title":"Create your first SAFE app"},{"location":"quickstart/#troubleshooting","text":"Still have issues getting started? Check out the troubleshooting page.","title":"Troubleshooting"},{"location":"support/","text":"The following companies provide commercial training, support, consultancy and development services for SAFE Stack applications. Compositional IT Compositional IT are experts in designing functional-first, cloud-ready systems, offering consultancy and support, training and development. Run by an F# MVP and well-known member of the .NET community, they are dedicated to raising awareness of the benefits of both functional programming and harnessing the power of the cloud to deliver high-quality, low-cost solutions. Lambda Factory Lambda Factory is a consulting company specializing in designing and building complex systems using Functional Programming languages such as F#, Elm and Elixir. It also offers help with introducing functional programming and open source driven development to the organization, as well as trainings, workshops and mentoring. Founded by open source contributor and well-known member of F# Community, Lambda Factory has been committed to supporting F# Community and helping it grow. Fuzzy Cloud Fuzzy Cloud is a fast-growing team of highly skilled and passionate IT professionals who can deliver services that help you speed up innovation and maximize efficiency. Our services are dynamic, scalable, resilient and responsive enabling rapid growth and high value for our clients. We take a highly collaborative approach to align our services with your business goals. We provide consulting in area like Cloud, Cross Platform mobile development, Machine Learning etc using Languages like F#, Python, Dart and few others. The F# Community The SAFE stack was written largely by the community as open source projects, such as Saturn, Giraffe, Fable and Elmish (as well as the alternative elements within the stack). All those teams are always happy to contribute and help out. Social You can also reach out to the SAFE team on @safe_stack or on the regular F# channels on Slack: either the official F# Foundation Slack or on the Functional Programming Slack . We'll be expanding this over time.","title":"Support"},{"location":"support/#compositional-it","text":"Compositional IT are experts in designing functional-first, cloud-ready systems, offering consultancy and support, training and development. Run by an F# MVP and well-known member of the .NET community, they are dedicated to raising awareness of the benefits of both functional programming and harnessing the power of the cloud to deliver high-quality, low-cost solutions.","title":"Compositional IT"},{"location":"support/#lambda-factory","text":"Lambda Factory is a consulting company specializing in designing and building complex systems using Functional Programming languages such as F#, Elm and Elixir. It also offers help with introducing functional programming and open source driven development to the organization, as well as trainings, workshops and mentoring. Founded by open source contributor and well-known member of F# Community, Lambda Factory has been committed to supporting F# Community and helping it grow.","title":"Lambda Factory"},{"location":"support/#fuzzy-cloud","text":"Fuzzy Cloud is a fast-growing team of highly skilled and passionate IT professionals who can deliver services that help you speed up innovation and maximize efficiency. Our services are dynamic, scalable, resilient and responsive enabling rapid growth and high value for our clients. We take a highly collaborative approach to align our services with your business goals. We provide consulting in area like Cloud, Cross Platform mobile development, Machine Learning etc using Languages like F#, Python, Dart and few others.","title":"Fuzzy Cloud"},{"location":"support/#the-f-community","text":"The SAFE stack was written largely by the community as open source projects, such as Saturn, Giraffe, Fable and Elmish (as well as the alternative elements within the stack). All those teams are always happy to contribute and help out.","title":"The F# Community"},{"location":"support/#social","text":"You can also reach out to the SAFE team on @safe_stack or on the regular F# channels on Slack: either the official F# Foundation Slack or on the Functional Programming Slack . We'll be expanding this over time.","title":"Social"},{"location":"template-fake/","text":"The template uses FAKE to build the application. Generated FAKE script contains a number of useful build targets: \"Run\" target dotnet fake build - -target run This target is used for development purposes, and provides a great live-reload experience. It pulls down any dependencies required for both the client and server, before running both the client and server in a \"watch\" mode, so any changes you make on either side will be automatically applied without your needing to restart the application. Navigating to http://localhost:8080/ will load the application. \"Bundle\" target dotnet fake build As Bundle is the default target, you do not need to supply any arguments to FAKE. This target is used to both build and package up your application in a production fashion, ready for deployment. It will restore all dependencies and build both the client and server in a production and release mode respectively, and correctly copy the outputs into the deploy folder in the root of the application. Once your build has completed, you can launch the entire application locally to test it as follows: cd deploy Server Navigating to http://localhost:8085/ will load the application. \"Azure\" target dotnet fake build - -target azure This target will deploy your application to Azure with a fully configured Application Insights instance. You do not need to pre-create any resources in Azure - the template will create everything needed, using free SKUs so you can test without any costs. You must already have an Azure account and will be prompted to log into it during the deployment process. This build step uses both the Azure CLI and Farmer projects to create all resources in just a few lines of code. The name of resources will be generated based on the folder in which you created the application. These may be incompatible with Azure naming rules, or may already be in use (Azure web applications must be globally unique) so you may have to modify the name of the webapp to pick one that is acceptable. \"RunTests\" target dotnet fake build - -target runtests This target behaves similarly to the standard Run target, except that it launches the unit tests for both client and server. The server tests will run immediately in the console, using watch mode to allow you to rapidly iterate on your tests. The client tests run in the browser . Again, they use a watch mode so you can make changes to your client code and see the results in the browser. Launch the client tests on http://localhost:8081/","title":"The FAKE script"},{"location":"template-fake/#run-target","text":"dotnet fake build - -target run This target is used for development purposes, and provides a great live-reload experience. It pulls down any dependencies required for both the client and server, before running both the client and server in a \"watch\" mode, so any changes you make on either side will be automatically applied without your needing to restart the application. Navigating to http://localhost:8080/ will load the application.","title":"\"Run\" target"},{"location":"template-fake/#bundle-target","text":"dotnet fake build As Bundle is the default target, you do not need to supply any arguments to FAKE. This target is used to both build and package up your application in a production fashion, ready for deployment. It will restore all dependencies and build both the client and server in a production and release mode respectively, and correctly copy the outputs into the deploy folder in the root of the application. Once your build has completed, you can launch the entire application locally to test it as follows: cd deploy Server Navigating to http://localhost:8085/ will load the application.","title":"\"Bundle\" target"},{"location":"template-fake/#azure-target","text":"dotnet fake build - -target azure This target will deploy your application to Azure with a fully configured Application Insights instance. You do not need to pre-create any resources in Azure - the template will create everything needed, using free SKUs so you can test without any costs. You must already have an Azure account and will be prompted to log into it during the deployment process. This build step uses both the Azure CLI and Farmer projects to create all resources in just a few lines of code. The name of resources will be generated based on the folder in which you created the application. These may be incompatible with Azure naming rules, or may already be in use (Azure web applications must be globally unique) so you may have to modify the name of the webapp to pick one that is acceptable.","title":"\"Azure\" target"},{"location":"template-fake/#runtests-target","text":"dotnet fake build - -target runtests This target behaves similarly to the standard Run target, except that it launches the unit tests for both client and server. The server tests will run immediately in the console, using watch mode to allow you to rapidly iterate on your tests. The client tests run in the browser . Again, they use a watch mode so you can make changes to your client code and see the results in the browser. Launch the client tests on http://localhost:8081/","title":"\"RunTests\" target"},{"location":"template-overview/","text":"The SAFE Template is a dotnet CLI template for SAFE Stack projects, designed to get you up and running as quickly as possible, with flexible options to suit your application. The template gets you up and running with the most common elements of the stack with minimal configuration options. All template options come with a fully working end-to-end SAFE application with known-good dependencies on client (NPM) and server (NuGet), as well as a preconfigured webpack configuration file. Using the template Refer to the Quick Start guide to see basic guidance on how to install and use the template. Template options The template provides two simple modes: the standard and minimal template. Standard Template The standard template creates an opinionated SAFE Stack app that contains everything you'll need to start developing, testing and deploying applications into Azure. dotnet new SAFE Use this configuration if.. .. you are brand new to SAFE Stack, or F#, or software development in general, and want a \"recommended\" experience .. you want to get up and running as quickly as possible .. you are an F# developer and want an experience that uses tools that you are familiar with Minimal Template The minimal template is a \"bare-bones\" SAFE Stack app with minimal value-add features. dotnet new SAFE -m Use this configuration if.. .. you are a SAFE Stack expert and want to hand-craft your own SAFE Stack application from a minimal starting point .. you are coming from a web development background and know your way around tools like NPM and Webpack .. you are comfortable creating your own build and packaging pipeline .. you want to see \"behind the magic\" and get a feel for what is happening behind the scenes At-a-glance Comparison Feature Standard Minimal Styling Fulma + Bulma None Starter App Todo List None Communication Fable Remoting Raw HTTP .NET Package Manager Paket NuGet Build Tooling FAKE None Azure Integration Farmer None Testing Support Client and Server None Recommendations VS Code Extensions, Code Style No","title":"Overview"},{"location":"template-overview/#using-the-template","text":"Refer to the Quick Start guide to see basic guidance on how to install and use the template.","title":"Using the template"},{"location":"template-overview/#template-options","text":"The template provides two simple modes: the standard and minimal template.","title":"Template options"},{"location":"template-overview/#standard-template","text":"The standard template creates an opinionated SAFE Stack app that contains everything you'll need to start developing, testing and deploying applications into Azure. dotnet new SAFE Use this configuration if.. .. you are brand new to SAFE Stack, or F#, or software development in general, and want a \"recommended\" experience .. you want to get up and running as quickly as possible .. you are an F# developer and want an experience that uses tools that you are familiar with","title":"Standard Template"},{"location":"template-overview/#minimal-template","text":"The minimal template is a \"bare-bones\" SAFE Stack app with minimal value-add features. dotnet new SAFE -m Use this configuration if.. .. you are a SAFE Stack expert and want to hand-craft your own SAFE Stack application from a minimal starting point .. you are coming from a web development background and know your way around tools like NPM and Webpack .. you are comfortable creating your own build and packaging pipeline .. you want to see \"behind the magic\" and get a feel for what is happening behind the scenes","title":"Minimal Template"},{"location":"template-overview/#at-a-glance-comparison","text":"Feature Standard Minimal Styling Fulma + Bulma None Starter App Todo List None Communication Fable Remoting Raw HTTP .NET Package Manager Paket NuGet Build Tooling FAKE None Azure Integration Farmer None Testing Support Client and Server None Recommendations VS Code Extensions, Code Style No","title":"At-a-glance Comparison"},{"location":"testimonials/","text":"Please feel free to submit a PR to add testimonials to this page! msu solutions GmbH SAFE gives us a fast development cycle for our web and mobile platforms We at msu solutions GmbH are big fans of SAFE stack. For the last couple of years we were already using F# open source technologies for web and mobile projects. Tools like the Fable compiler and elmish are rock solid and a pleasure to work with. Since the release of SAFE, we see that all these important technologies are now bundled and tested under one big umbrella. Especially the commercial support for SAFE is very important for us and our customers. Goswin Rothenthal It just works! The docs are very detailed and helpful. I got the template up and running on a public URL on Azure within one hour. Without any issues. Even though I am new to dotnet core and Azure. Demetrix SAFE was the perfect place to start our biological design and data management platform Demetrix uses F# for DNA design and data management in our research pipeline. Our data systems are built on top of SAFE and it was a great experience for both veteran F# developers and people new to the environment. I would start with SAFE again in a heartbeat for a new project. We shared some of our experiences at Open F# 2018. Microdesk Spoil your customers with F# and the SAFE stack! Porting a production web app from TypeScript/React to use the SAFE stack turned out to be a huge win. Sharing F# models on the front and back-end allows you to leverage the excellent F# compiler and type system when designing and refactoring your codebase. Using a type provider (in our case, SQLProvider) extends this coverage to your database as well. This means that changes to any part of your application will be picked up by the compiler which will essentially guide you to every relevant place in the source code that needs to be updated. This is so effective that once you experience it, you will never want to be without it. On the front end, the Elmish pattern, which may look intimidating at first glance, is actually quite fun and intuitive to write. More importantly, it guides you into the \"pit of success\" by making you write highly testable \"pure functions\" that outline your UI state transitions (in your update function). Putting all state transitions in one place becomes a breath of fresh air because it eliminates the spaghetti code that can happen in MVVM view models of even modest complexity. Do you have a complex \"sort\" that needs to be handled in your update ? You can easily write a unit test in F# that passes in the relevant command input for that. No mocking is required because it will be a pure function! If you still feel leery of the Elmish pattern, you are free to use React Hooks API or any other pattern you prefer. There are also many excellent external libraries - i.e. Feliz - that allow you to optionally use the Elmish pattern on only certain pages, among other things. Worried about getting stuck? Don't worry because the F# community will practially crawl all over themselves to be the first to answer you question. There are also options for professional consultation as well. The community support is amazing! The SAFE stack is designed to be as turn-key as possible, but there are also plenty of opportunities to customize the stack as you see fit. Overall, the SAFE stack has allowed me to completely spoil a very damanding customer with timely, bug-free deliverables.","title":"Testimonials"},{"location":"testimonials/#msu-solutions-gmbh","text":"SAFE gives us a fast development cycle for our web and mobile platforms We at msu solutions GmbH are big fans of SAFE stack. For the last couple of years we were already using F# open source technologies for web and mobile projects. Tools like the Fable compiler and elmish are rock solid and a pleasure to work with. Since the release of SAFE, we see that all these important technologies are now bundled and tested under one big umbrella. Especially the commercial support for SAFE is very important for us and our customers.","title":"msu solutions GmbH"},{"location":"testimonials/#goswin-rothenthal","text":"It just works! The docs are very detailed and helpful. I got the template up and running on a public URL on Azure within one hour. Without any issues. Even though I am new to dotnet core and Azure.","title":"Goswin Rothenthal"},{"location":"testimonials/#demetrix","text":"SAFE was the perfect place to start our biological design and data management platform Demetrix uses F# for DNA design and data management in our research pipeline. Our data systems are built on top of SAFE and it was a great experience for both veteran F# developers and people new to the environment. I would start with SAFE again in a heartbeat for a new project. We shared some of our experiences at Open F# 2018.","title":"Demetrix"},{"location":"testimonials/#microdesk","text":"Spoil your customers with F# and the SAFE stack! Porting a production web app from TypeScript/React to use the SAFE stack turned out to be a huge win. Sharing F# models on the front and back-end allows you to leverage the excellent F# compiler and type system when designing and refactoring your codebase. Using a type provider (in our case, SQLProvider) extends this coverage to your database as well. This means that changes to any part of your application will be picked up by the compiler which will essentially guide you to every relevant place in the source code that needs to be updated. This is so effective that once you experience it, you will never want to be without it. On the front end, the Elmish pattern, which may look intimidating at first glance, is actually quite fun and intuitive to write. More importantly, it guides you into the \"pit of success\" by making you write highly testable \"pure functions\" that outline your UI state transitions (in your update function). Putting all state transitions in one place becomes a breath of fresh air because it eliminates the spaghetti code that can happen in MVVM view models of even modest complexity. Do you have a complex \"sort\" that needs to be handled in your update ? You can easily write a unit test in F# that passes in the relevant command input for that. No mocking is required because it will be a pure function! If you still feel leery of the Elmish pattern, you are free to use React Hooks API or any other pattern you prefer. There are also many excellent external libraries - i.e. Feliz - that allow you to optionally use the Elmish pattern on only certain pages, among other things. Worried about getting stuck? Don't worry because the F# community will practially crawl all over themselves to be the first to answer you question. There are also options for professional consultation as well. The community support is amazing! The SAFE stack is designed to be as turn-key as possible, but there are also plenty of opportunities to customize the stack as you see fit. Overall, the SAFE stack has allowed me to completely spoil a very damanding customer with timely, bug-free deliverables.","title":"Microdesk"},{"location":"recipes/template/","text":"How do I create a SAFE recipe? Follow the following pattern and headings and the guide below. Best practices DO focus on integration between different components in the SAFE Stack e.g. how to connect Fable apps to Saturn backend etc. DO focus on getting results quickly. DO consider both template versions e.g. make the recipe suitable for both \"minimal\" and \"full\" template options Do NOT reproduce reference documentation from \"source\" technologies e.g. do NOT replicate documentation from Saturn or Fable sites. DO link to reference documentation from source technologies. Do NOT create reference documentation in a recipe. DO use simple code snippets where appropriate. How Do I < insert task here >? Start by writing a short introduction of a few sentences. Explain what the recipe is about, and problems it solves. Which technologies does it utilise, and what are the alternatives etc.? Remember to link the first instance of any technology to the appropriate docs elsewhere within this site, or to the homepage of the technology (or both!). Step-by-step Guide Write clear instructions on how to get to the desired outcome. The step-by-step instructions should be clear, short, easy to understand with possibly a use case and an example at the end if suitable. If you have a step in this section that is relevant to some other recipe we have here in the docs, such as adding a package to a SAFE app, link it to that relevant page. See here for an example recipe.","title":"Create a new Recipe"},{"location":"recipes/template/#how-do-i-create-a-safe-recipe","text":"Follow the following pattern and headings and the guide below.","title":"How do I create a SAFE recipe?"},{"location":"recipes/template/#best-practices","text":"DO focus on integration between different components in the SAFE Stack e.g. how to connect Fable apps to Saturn backend etc. DO focus on getting results quickly. DO consider both template versions e.g. make the recipe suitable for both \"minimal\" and \"full\" template options Do NOT reproduce reference documentation from \"source\" technologies e.g. do NOT replicate documentation from Saturn or Fable sites. DO link to reference documentation from source technologies. Do NOT create reference documentation in a recipe. DO use simple code snippets where appropriate.","title":"Best practices"},{"location":"recipes/template/#how-do-i-insert-task-here","text":"Start by writing a short introduction of a few sentences. Explain what the recipe is about, and problems it solves. Which technologies does it utilise, and what are the alternatives etc.? Remember to link the first instance of any technology to the appropriate docs elsewhere within this site, or to the homepage of the technology (or both!).","title":"How Do I &lt; insert task here &gt;?"},{"location":"recipes/template/#step-by-step-guide","text":"Write clear instructions on how to get to the desired outcome. The step-by-step instructions should be clear, short, easy to understand with possibly a use case and an example at the end if suitable. If you have a step in this section that is relevant to some other recipe we have here in the docs, such as adding a package to a SAFE app, link it to that relevant page. See here for an example recipe.","title":"Step-by-step Guide"},{"location":"recipes/build/add-build-script/","text":"How do I add a build script to the project? FAKE Fake is a DSL for build tasks that is modular, extensible and easy to start with. Fake allows you to easily build, bundle, deploy your app and more by executing a single command. The standard template comes with a FAKE script by default, and this recipe only applies to the minimal template . Paket Before moving on, we recommend migrating to Paket . In fact, this is a prerequisite for this recipe . It is possible to use FAKE without Paket by creating an executable instead of a script file, however this will not be covered in this recipe. If you\u2019re not using Paket to handle your dependencies, go through the Migrate to Paket recipe before continuing. 1. The Build Dependencies Paste the following at the end of your paket.dependencies file, which is at the root of the solution. group Build source https://api.nuget.org/v3/index.json framework: netstandard2.0 storage: none nuget FSharp.Core nuget Fake.Core.Target nuget Fake.DotNet.Cli nuget Fake.IO.FileSystem Then, execute paket install to install these dependencies. 2. Fake CLI Tool Run the following commands at the root folder of your solution to install FAKE as a local tool: dotnet tool install fake-cli dotnet tool restore 3. The Build Script Add an F# script file to the root folder of your solution named build.fsx and paste the following code into it. The script builds and publishes the client and server applications in their production / release modes, and copies the outputs of both into a deploy folder at the root of the repository. To learn more about targets and FAKE in general, see Getting Started with FAKE . # r \"paket: groupref build //\" # load \"./.fake/build.fsx/intellisense.fsx\" # r \"netstandard\" open Fake.Core open Fake.Core.TargetOperators open Fake.DotNet open Fake.IO Target . initEnvironment () let serverPath = Path . getFullName \"./src/Server\" let clientPath = Path . getFullName \"./src/Client\" let deployDir = Path . getFullName \"./deploy\" let npm args workingDir = let npmPath = ProcessUtils . tryFindFileOnPath \"npm\" |> Option . get let arguments = args |> String . split ' ' |> Arguments . OfArgs Command . RawCommand ( npmPath , arguments ) |> CreateProcess . fromCommand |> CreateProcess . withWorkingDirectory workingDir |> CreateProcess . ensureExitCode |> Proc . run |> ignore let dotnet cmd workingDir = DotNet . exec ( DotNet . Options . withWorkingDirectory workingDir ) cmd \"\" Target . create \"Bundle\" ( fun _ -> Shell . cleanDir deployDir npm \"install\" clientPath dotnet ( sprintf \"publish -c Release -o \\\" %s \\\" \" deployDir ) serverPath npm \"run build\" clientPath ) \"Clean\" ==> \"InstallClient\" ==> \"Bundle\" Target . runOrDefaultWithArguments \"Bundle\" 4. Build the Application You can now build your application by running the following command at the root directory of your solution: dotnet fake build","title":"Add build automation"},{"location":"recipes/build/add-build-script/#how-do-i-add-a-build-script-to-the-project","text":"","title":"How do I add a build script to the project?"},{"location":"recipes/build/add-build-script/#fake","text":"Fake is a DSL for build tasks that is modular, extensible and easy to start with. Fake allows you to easily build, bundle, deploy your app and more by executing a single command. The standard template comes with a FAKE script by default, and this recipe only applies to the minimal template .","title":"FAKE"},{"location":"recipes/build/add-build-script/#paket","text":"Before moving on, we recommend migrating to Paket . In fact, this is a prerequisite for this recipe . It is possible to use FAKE without Paket by creating an executable instead of a script file, however this will not be covered in this recipe. If you\u2019re not using Paket to handle your dependencies, go through the Migrate to Paket recipe before continuing.","title":"Paket"},{"location":"recipes/build/add-build-script/#1-the-build-dependencies","text":"Paste the following at the end of your paket.dependencies file, which is at the root of the solution. group Build source https://api.nuget.org/v3/index.json framework: netstandard2.0 storage: none nuget FSharp.Core nuget Fake.Core.Target nuget Fake.DotNet.Cli nuget Fake.IO.FileSystem Then, execute paket install to install these dependencies.","title":"1. The Build Dependencies"},{"location":"recipes/build/add-build-script/#2-fake-cli-tool","text":"Run the following commands at the root folder of your solution to install FAKE as a local tool: dotnet tool install fake-cli dotnet tool restore","title":"2. Fake CLI Tool"},{"location":"recipes/build/add-build-script/#3-the-build-script","text":"Add an F# script file to the root folder of your solution named build.fsx and paste the following code into it. The script builds and publishes the client and server applications in their production / release modes, and copies the outputs of both into a deploy folder at the root of the repository. To learn more about targets and FAKE in general, see Getting Started with FAKE . # r \"paket: groupref build //\" # load \"./.fake/build.fsx/intellisense.fsx\" # r \"netstandard\" open Fake.Core open Fake.Core.TargetOperators open Fake.DotNet open Fake.IO Target . initEnvironment () let serverPath = Path . getFullName \"./src/Server\" let clientPath = Path . getFullName \"./src/Client\" let deployDir = Path . getFullName \"./deploy\" let npm args workingDir = let npmPath = ProcessUtils . tryFindFileOnPath \"npm\" |> Option . get let arguments = args |> String . split ' ' |> Arguments . OfArgs Command . RawCommand ( npmPath , arguments ) |> CreateProcess . fromCommand |> CreateProcess . withWorkingDirectory workingDir |> CreateProcess . ensureExitCode |> Proc . run |> ignore let dotnet cmd workingDir = DotNet . exec ( DotNet . Options . withWorkingDirectory workingDir ) cmd \"\" Target . create \"Bundle\" ( fun _ -> Shell . cleanDir deployDir npm \"install\" clientPath dotnet ( sprintf \"publish -c Release -o \\\" %s \\\" \" deployDir ) serverPath npm \"run build\" clientPath ) \"Clean\" ==> \"InstallClient\" ==> \"Bundle\" Target . runOrDefaultWithArguments \"Bundle\"","title":"3. The Build Script"},{"location":"recipes/build/add-build-script/#4-build-the-application","text":"You can now build your application by running the following command at the root directory of your solution: dotnet fake build","title":"4. Build the Application"},{"location":"recipes/build/bundle-app/","text":"How do I bundle my SAFE application? When developing your SAFE application, the local runtime experience uses WebPack to run the client and redirect API calls to the server on a different port . However, when you deploy your application, you'll need to run your Saturn server which will serve up statically-built client resources (HTML, JavaScript, CSS etc.). I'm using the standard template 1. Run the FAKE script If you created your SAFE app using the recommended defaults, your application already has a FAKE script which will do the bundling for you. You can create a bundle using the following command: dotnet fake build This will build and package up both the client and server and place them into the /deploy folder at the root of the repository. See here for more details on this build target. I'm using the minimal template If you created your SAFE app using the minimal option, you need to bundle up the client and server separately. 1. Bundle the Client (Fable) application Execute the following commands: npm run build This will build the client project and copy all outputs into /deploy/public . The run build command run webpack using the Production config, and the webpack.config.js file specifies its output as /deploy/public . 2. Bundle the Server (Saturn) application Execute the following commands: cd src/Server dotnet publish -c release -o ../../deploy This will bundle the server project and copy all outputs into the deploy folder. Testing the bundle Navigate to the deploy folder at the root of your repository. Run the Server.exe application. Navigate in your browser to http://localhost:8085 . You should now see your SAFE application. Further reading See this article for more information on architectural concerns regarding the move from dev to production and bundling SAFE Stack applications.","title":"Package my SAFE app for deployment"},{"location":"recipes/build/bundle-app/#how-do-i-bundle-my-safe-application","text":"When developing your SAFE application, the local runtime experience uses WebPack to run the client and redirect API calls to the server on a different port . However, when you deploy your application, you'll need to run your Saturn server which will serve up statically-built client resources (HTML, JavaScript, CSS etc.).","title":"How do I bundle my SAFE application?"},{"location":"recipes/build/bundle-app/#im-using-the-standard-template","text":"","title":"I'm using the standard template"},{"location":"recipes/build/bundle-app/#1-run-the-fake-script","text":"If you created your SAFE app using the recommended defaults, your application already has a FAKE script which will do the bundling for you. You can create a bundle using the following command: dotnet fake build This will build and package up both the client and server and place them into the /deploy folder at the root of the repository. See here for more details on this build target.","title":"1. Run the FAKE script"},{"location":"recipes/build/bundle-app/#im-using-the-minimal-template","text":"If you created your SAFE app using the minimal option, you need to bundle up the client and server separately.","title":"I'm using the minimal template"},{"location":"recipes/build/bundle-app/#1-bundle-the-client-fable-application","text":"Execute the following commands: npm run build This will build the client project and copy all outputs into /deploy/public . The run build command run webpack using the Production config, and the webpack.config.js file specifies its output as /deploy/public .","title":"1. Bundle the Client (Fable) application"},{"location":"recipes/build/bundle-app/#2-bundle-the-server-saturn-application","text":"Execute the following commands: cd src/Server dotnet publish -c release -o ../../deploy This will bundle the server project and copy all outputs into the deploy folder.","title":"2. Bundle the Server (Saturn) application"},{"location":"recipes/build/bundle-app/#testing-the-bundle","text":"Navigate to the deploy folder at the root of your repository. Run the Server.exe application. Navigate in your browser to http://localhost:8085 . You should now see your SAFE application.","title":"Testing the bundle"},{"location":"recipes/build/bundle-app/#further-reading","text":"See this article for more information on architectural concerns regarding the move from dev to production and bundling SAFE Stack applications.","title":"Further reading"},{"location":"recipes/build/docker-image/","text":"How do I build with docker? Using Docker makes it possible to deploy your application as a docker container or release an image on docker hub. This recipe walks you through creating a Dockerfile and automating the build and test process with Docker Hub . 1. Create a .dockerignore file Create a .dockerignore file with the same contents as .gitignore Linux cp .gitignore .dockerignore Windows copy .gitignore .dockerignore Now, add the following lines to the .dockerignore file: .git 2. Create the dockerfile Create a Dockerfile with the following contents: FROM mcr.microsoft.com/dotnet/core/sdk:3.1 as build # Install node RUN curl -sL https://deb.nodesource.com/setup_14.x | bash RUN apt-get update && apt-get install -y nodejs WORKDIR /workspace COPY . . RUN dotnet tool restore RUN dotnet fake build -t Bundle FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-alpine COPY --from = build /workspace/deploy /app WORKDIR /app EXPOSE 8085 ENTRYPOINT [ \"dotnet\" , \"Server.dll\" ] This uses multistage builds to keep the final image small. Using the minimal template? If you created your SAFE app using the minimal option, a FAKE script is not included by default so you need to bundle up the client and server separately. Replace the line RUN dotnet fake build -t Bundle with RUN npm run build RUN cd src/Server && dotnet publish -c release -o ../../deploy 3. Building and running with docker locally Build the image docker build -t my-safe-app . Run the container docker run -it -p 8085:8085 my-safe-app Because the build is done entirely in docker, Docker Hub automated builds can be setup to automatically build and push the docker image. 4. Testing the server Create a docker-compose.server.test.yml file with the following contents: sut: build: context: . target: build command: cd tests/Server && dotnet run If you added tests to the minimal template according to the testing the server recipe, change the command to cd src/Server.Tests && dotnet run Docker Hub can also run automated tests for you. The template is not currently setup for automating the client tests. Follow the instructions to enable Autotest on docker hub. 5. Making the docker build faster Not recommended for most applications If you often build with docker locally, you may wish to make the build faster by optimising the Dockerfile for caching. For example, it is not necessary to download all paket and npm dependencies on every build unless there have been changes to the dependencies. Furthermore, the client and server can be built in separate build stages so that they are cached independently. Enable Docker BuildKit to build them concurrently. This comes at the expense of making the dockerfile more complex; if any changes are made to the build such as adding new projects or migrating package managers, the dockerfile must be updated accordingly. The following should be a good starting point but is not guarenteed to work. FROM mcr.microsoft.com/dotnet/core/sdk:3.1 as build # Install node RUN curl -sL https://deb.nodesource.com/setup_14.x | bash RUN apt-get update && apt-get install -y nodejs WORKDIR /workspace COPY .config .config RUN dotnet tool restore COPY .paket .paket COPY paket.dependencies paket.lock ./ RUN dotnet paket restore FROM build as server-build COPY src/Shared src/Shared COPY src/Server src/Server RUN cd src/Server && dotnet publish -c release -o ../../deploy FROM build as client-build COPY package.json package-lock.json ./ RUN npm install COPY webpack.config.js ./ COPY src/Shared src/Shared COPY src/Client src/Client RUN npm run build FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-alpine COPY --from = server-build /workspace/deploy /app COPY --from = client-build /workspace/deploy /app WORKDIR /app EXPOSE 8085 ENTRYPOINT [ \"dotnet\" , \"Server.dll\" ]","title":"Create a docker image"},{"location":"recipes/build/docker-image/#how-do-i-build-with-docker","text":"Using Docker makes it possible to deploy your application as a docker container or release an image on docker hub. This recipe walks you through creating a Dockerfile and automating the build and test process with Docker Hub .","title":"How do I build with docker?"},{"location":"recipes/build/docker-image/#1-create-a-dockerignore-file","text":"Create a .dockerignore file with the same contents as .gitignore","title":"1. Create a .dockerignore file"},{"location":"recipes/build/docker-image/#linux","text":"cp .gitignore .dockerignore","title":"Linux"},{"location":"recipes/build/docker-image/#windows","text":"copy .gitignore .dockerignore Now, add the following lines to the .dockerignore file: .git","title":"Windows"},{"location":"recipes/build/docker-image/#2-create-the-dockerfile","text":"Create a Dockerfile with the following contents: FROM mcr.microsoft.com/dotnet/core/sdk:3.1 as build # Install node RUN curl -sL https://deb.nodesource.com/setup_14.x | bash RUN apt-get update && apt-get install -y nodejs WORKDIR /workspace COPY . . RUN dotnet tool restore RUN dotnet fake build -t Bundle FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-alpine COPY --from = build /workspace/deploy /app WORKDIR /app EXPOSE 8085 ENTRYPOINT [ \"dotnet\" , \"Server.dll\" ] This uses multistage builds to keep the final image small.","title":"2. Create the dockerfile"},{"location":"recipes/build/docker-image/#using-the-minimal-template","text":"If you created your SAFE app using the minimal option, a FAKE script is not included by default so you need to bundle up the client and server separately. Replace the line RUN dotnet fake build -t Bundle with RUN npm run build RUN cd src/Server && dotnet publish -c release -o ../../deploy","title":"Using the minimal template?"},{"location":"recipes/build/docker-image/#3-building-and-running-with-docker-locally","text":"Build the image docker build -t my-safe-app . Run the container docker run -it -p 8085:8085 my-safe-app Because the build is done entirely in docker, Docker Hub automated builds can be setup to automatically build and push the docker image.","title":"3. Building and running with docker locally"},{"location":"recipes/build/docker-image/#4-testing-the-server","text":"Create a docker-compose.server.test.yml file with the following contents: sut: build: context: . target: build command: cd tests/Server && dotnet run If you added tests to the minimal template according to the testing the server recipe, change the command to cd src/Server.Tests && dotnet run Docker Hub can also run automated tests for you. The template is not currently setup for automating the client tests. Follow the instructions to enable Autotest on docker hub.","title":"4. Testing the server"},{"location":"recipes/build/docker-image/#5-making-the-docker-build-faster","text":"Not recommended for most applications If you often build with docker locally, you may wish to make the build faster by optimising the Dockerfile for caching. For example, it is not necessary to download all paket and npm dependencies on every build unless there have been changes to the dependencies. Furthermore, the client and server can be built in separate build stages so that they are cached independently. Enable Docker BuildKit to build them concurrently. This comes at the expense of making the dockerfile more complex; if any changes are made to the build such as adding new projects or migrating package managers, the dockerfile must be updated accordingly. The following should be a good starting point but is not guarenteed to work. FROM mcr.microsoft.com/dotnet/core/sdk:3.1 as build # Install node RUN curl -sL https://deb.nodesource.com/setup_14.x | bash RUN apt-get update && apt-get install -y nodejs WORKDIR /workspace COPY .config .config RUN dotnet tool restore COPY .paket .paket COPY paket.dependencies paket.lock ./ RUN dotnet paket restore FROM build as server-build COPY src/Shared src/Shared COPY src/Server src/Server RUN cd src/Server && dotnet publish -c release -o ../../deploy FROM build as client-build COPY package.json package-lock.json ./ RUN npm install COPY webpack.config.js ./ COPY src/Shared src/Shared COPY src/Client src/Client RUN npm run build FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-alpine COPY --from = server-build /workspace/deploy /app COPY --from = client-build /workspace/deploy /app WORKDIR /app EXPOSE 8085 ENTRYPOINT [ \"dotnet\" , \"Server.dll\" ]","title":"5. Making the docker build faster"},{"location":"recipes/build/remove-fake/","text":"How do I remove the use of FAKE? FAKE is a tool for build automation. The standard SAFE template comes with a ready-made build script at the root of the solution that provides support for many common SAFE tasks. If you would prefer not to use FAKE, you can of course simply ignore it, but this recipes shows how to completely remove it from your repository. It is important to note that having removed FAKE, you will have to follow a more manual approach to each of these processes. This recipe will only include instructions on how to build and deploy the application after removing FAKE. Note that the minimal template does not have FAKE installed by default, and this recipe only applies to the standard template . 1. Build Script Delete build.fsx at the root of the solution. 2. Dependencies Find the following block of code inside the paket.dependencies file that\u2019s also at the root of the solution and delete it. group Build source https : //api.nuget.org/v3/index.json framework : netstandard2 . 0 storage : none nuget FSharp . Core nuget Fake . Core . ReleaseNotes nuget Fake . Core . Target nuget Fake . DotNet . Cli nuget Fake . IO . FileSystem nuget Farmer 3. Paket Install Then, execute paket install in your terminal at the root of the solution. This will remove the dependencies whose names were included in the Build group. 4. Fake Tool The final step is to delete the FAKE tool. Execute the following command at the root of the solution to do this: dotnet tool uninstall fake-cli Running the App Now that you have FAKE removed, you will have to separately run the server and the client. 1. Start the Client Execute npm start inside a terminal at the root of the solution . 2. Start the Server Navigate to src/Server inside a terminal and execute dotnet run . The app will now be running at http://0.0.0.0:8080/ . Navigate to this address in a browser to see your app running. Bundling the App See this guide to learn how to package a SAFE application for deployment to e.g. Azure. You can now find the outcome of the bundling process in the deploy folder at the root of the solution.","title":"Remove FAKE from my project"},{"location":"recipes/build/remove-fake/#how-do-i-remove-the-use-of-fake","text":"FAKE is a tool for build automation. The standard SAFE template comes with a ready-made build script at the root of the solution that provides support for many common SAFE tasks. If you would prefer not to use FAKE, you can of course simply ignore it, but this recipes shows how to completely remove it from your repository. It is important to note that having removed FAKE, you will have to follow a more manual approach to each of these processes. This recipe will only include instructions on how to build and deploy the application after removing FAKE. Note that the minimal template does not have FAKE installed by default, and this recipe only applies to the standard template .","title":"How do I remove the use of FAKE?"},{"location":"recipes/build/remove-fake/#1-build-script","text":"Delete build.fsx at the root of the solution.","title":"1. Build Script"},{"location":"recipes/build/remove-fake/#2-dependencies","text":"Find the following block of code inside the paket.dependencies file that\u2019s also at the root of the solution and delete it. group Build source https : //api.nuget.org/v3/index.json framework : netstandard2 . 0 storage : none nuget FSharp . Core nuget Fake . Core . ReleaseNotes nuget Fake . Core . Target nuget Fake . DotNet . Cli nuget Fake . IO . FileSystem nuget Farmer","title":"2. Dependencies"},{"location":"recipes/build/remove-fake/#3-paket-install","text":"Then, execute paket install in your terminal at the root of the solution. This will remove the dependencies whose names were included in the Build group.","title":"3. Paket Install"},{"location":"recipes/build/remove-fake/#4-fake-tool","text":"The final step is to delete the FAKE tool. Execute the following command at the root of the solution to do this: dotnet tool uninstall fake-cli","title":"4. Fake Tool"},{"location":"recipes/build/remove-fake/#running-the-app","text":"Now that you have FAKE removed, you will have to separately run the server and the client.","title":"Running the App"},{"location":"recipes/build/remove-fake/#1-start-the-client","text":"Execute npm start inside a terminal at the root of the solution .","title":"1. Start the Client"},{"location":"recipes/build/remove-fake/#2-start-the-server","text":"Navigate to src/Server inside a terminal and execute dotnet run . The app will now be running at http://0.0.0.0:8080/ . Navigate to this address in a browser to see your app running.","title":"2. Start the Server"},{"location":"recipes/build/remove-fake/#bundling-the-app","text":"See this guide to learn how to package a SAFE application for deployment to e.g. Azure. You can now find the outcome of the bundling process in the deploy folder at the root of the solution.","title":"Bundling the App"},{"location":"recipes/build/support-older-browsers/","text":"How Do I Add Support for Older Browsers? What Is A Polyfill? Simply put, a polyfill is a block of code that implements a feature on web browsers that do not support that feature. All we need to use polyfills where necessary is to tell Babel and Fable to do so in our webpack config file. Note that the standard template uses polyfills by default, and this recipe only applies to the minimal template . 1. NPM Package First, add @babel/preset-env NPM package to the Client. You can find out more about this package here . Also, see: How Do I Add an NPM Package to the Client . 2. Configuration Object Add the following object to the webpack.config.js file. The useBuiltIns option configures how @babel/preset-env handles polyfills. You can find out more about this option here . var babelOptions = { presets : [ [ '@babel/preset-env' , { modules : false , useBuiltIns : 'usage' , corejs : 3 }] ], } 3. Fable Loader Make the following modifications to the fable-loader object, which you can find at the bottom of webpack.config inside the module field of the module.exports object: { test : /\\.fs(x|proj)?$/ , use : { loader : 'fable-loader' , // <- Add a comma here. options : { babel : babelOptions } // <- Add this line. } }, 4. Babel Loader Make the following modifications to the babel-loader object, which you can find right below fable-loader . { test : /\\.js$/ , exclude : /node_modules/ , use : { loader : 'babel-loader' , // <- Add a comma here. options : babelOptions // <- Add this line, } }, Done! Babel will now use polyfills only where necessary to both enable your code to be run on older browsers and achieve optimal performance when they are not needed.","title":"Support older browsers"},{"location":"recipes/build/support-older-browsers/#how-do-i-add-support-for-older-browsers","text":"","title":"How Do I Add Support for Older Browsers?"},{"location":"recipes/build/support-older-browsers/#what-is-a-polyfill","text":"Simply put, a polyfill is a block of code that implements a feature on web browsers that do not support that feature. All we need to use polyfills where necessary is to tell Babel and Fable to do so in our webpack config file. Note that the standard template uses polyfills by default, and this recipe only applies to the minimal template .","title":"What Is A Polyfill?"},{"location":"recipes/build/support-older-browsers/#1-npm-package","text":"First, add @babel/preset-env NPM package to the Client. You can find out more about this package here . Also, see: How Do I Add an NPM Package to the Client .","title":"1. NPM Package"},{"location":"recipes/build/support-older-browsers/#2-configuration-object","text":"Add the following object to the webpack.config.js file. The useBuiltIns option configures how @babel/preset-env handles polyfills. You can find out more about this option here . var babelOptions = { presets : [ [ '@babel/preset-env' , { modules : false , useBuiltIns : 'usage' , corejs : 3 }] ], }","title":"2. Configuration Object"},{"location":"recipes/build/support-older-browsers/#3-fable-loader","text":"Make the following modifications to the fable-loader object, which you can find at the bottom of webpack.config inside the module field of the module.exports object: { test : /\\.fs(x|proj)?$/ , use : { loader : 'fable-loader' , // <- Add a comma here. options : { babel : babelOptions } // <- Add this line. } },","title":"3. Fable Loader"},{"location":"recipes/build/support-older-browsers/#4-babel-loader","text":"Make the following modifications to the babel-loader object, which you can find right below fable-loader . { test : /\\.js$/ , exclude : /node_modules/ , use : { loader : 'babel-loader' , // <- Add a comma here. options : babelOptions // <- Add this line, } },","title":"4. Babel Loader"},{"location":"recipes/build/support-older-browsers/#done","text":"Babel will now use polyfills only where necessary to both enable your code to be run on older browsers and achieve optimal performance when they are not needed.","title":"Done!"},{"location":"recipes/client-server/fable-remoting/","text":"How Do I Add Support for Fable Remoting? Fable Remoting is a type-safe RPC communication layer for SAFE apps. It uses HTTP behind the scenes, but allows you to program against protocols that exist across the application without needing to think about the HTTP plumbing, and is a great fit for the majority of SAFE applications. Note that the standard template uses Fable Remoting. This recipe only applies to the minimal template . 1. Install NuGet Packages Add Fable.Remoting.Giraffe to the Server and Fable.Remoting.Client to the Client. See How Do I Add a NuGet Package to the Server and How Do I Add a NuGet Package to the Client . 2. Create the API protocol You now need to create the protocol, or contract, of the API we\u2019ll be creating. Insert the following below the Route module in Shared.fs : type IMyApi = { hello : unit -> Async < string > } 3. Create the routing function We need to provide a basic routing function in order to ensure client and server communicate on the same endpoint. Find the Route module in src/Shared/Shared.fs and replace it with the following: module Route = let builder typeName methodName = sprintf \"/api/%s/%s\" typeName methodName 4. Create the protocol implementation We now need to provide an implementation of the protocol on the server. Open src/Server/Server.fs and insert the following right after the open statements: let myApi = { hello = fun () -> async { return \"Hello from SAFE!\" } } 5. Hook into ASP.NET We now need to \"adapt\" Fable Remoting into the ASP.NET pipeline by converting it into a Giraffe HTTP Handler. Don't worry - this is not hard. Find webApp in Server.fs and replace it with the following: open Fable.Remoting.Server open Fable.Remoting.Giraffe let webApp = Remoting . createApi () |> Remoting . withRouteBuilder Route . builder // use the routing function from step 3 |> Remoting . fromValue myApi // use the myApi implementation from step 4 |> Remoting . buildHttpHandler // adapt it to Giraffe's HTTP Handler 6. Create the Client proxy We now need a corresponding client proxy in order to be able to connect to the server. Open src/Client/Client.fs and insert the following right after the Msg type: open Fable.Remoting.Client let myApi = Remoting . createApi () |> Remoting . withRouteBuilder Route . builder |> Remoting . buildProxy < IMyApi > 7. Make calls to the Server Replace the following two lines in the init function in Client.fs : let getHello () = Fetch . get < unit , string > Route . hello let cmd = Cmd . OfPromise . perform getHello () GotHello with this: let cmd = Cmd . OfAsync . perform myApi . hello () GotHello Done! At this point, the app should work just as it did before. Now, expanding the API and adding a new endpoint is as easy as adding a new field to the API protocol we defined in Shared.fs , editing the myApi record in Server.fs with the implementation, and finally making calls from the proxy.","title":"Add support for Fable Remoting"},{"location":"recipes/client-server/fable-remoting/#how-do-i-add-support-for-fable-remoting","text":"Fable Remoting is a type-safe RPC communication layer for SAFE apps. It uses HTTP behind the scenes, but allows you to program against protocols that exist across the application without needing to think about the HTTP plumbing, and is a great fit for the majority of SAFE applications. Note that the standard template uses Fable Remoting. This recipe only applies to the minimal template .","title":"How Do I Add Support for Fable Remoting?"},{"location":"recipes/client-server/fable-remoting/#1-install-nuget-packages","text":"Add Fable.Remoting.Giraffe to the Server and Fable.Remoting.Client to the Client. See How Do I Add a NuGet Package to the Server and How Do I Add a NuGet Package to the Client .","title":"1. Install NuGet Packages"},{"location":"recipes/client-server/fable-remoting/#2-create-the-api-protocol","text":"You now need to create the protocol, or contract, of the API we\u2019ll be creating. Insert the following below the Route module in Shared.fs : type IMyApi = { hello : unit -> Async < string > }","title":"2. Create the API protocol"},{"location":"recipes/client-server/fable-remoting/#3-create-the-routing-function","text":"We need to provide a basic routing function in order to ensure client and server communicate on the same endpoint. Find the Route module in src/Shared/Shared.fs and replace it with the following: module Route = let builder typeName methodName = sprintf \"/api/%s/%s\" typeName methodName","title":"3. Create the routing function"},{"location":"recipes/client-server/fable-remoting/#4-create-the-protocol-implementation","text":"We now need to provide an implementation of the protocol on the server. Open src/Server/Server.fs and insert the following right after the open statements: let myApi = { hello = fun () -> async { return \"Hello from SAFE!\" } }","title":"4. Create the protocol implementation"},{"location":"recipes/client-server/fable-remoting/#5-hook-into-aspnet","text":"We now need to \"adapt\" Fable Remoting into the ASP.NET pipeline by converting it into a Giraffe HTTP Handler. Don't worry - this is not hard. Find webApp in Server.fs and replace it with the following: open Fable.Remoting.Server open Fable.Remoting.Giraffe let webApp = Remoting . createApi () |> Remoting . withRouteBuilder Route . builder // use the routing function from step 3 |> Remoting . fromValue myApi // use the myApi implementation from step 4 |> Remoting . buildHttpHandler // adapt it to Giraffe's HTTP Handler","title":"5. Hook into ASP.NET"},{"location":"recipes/client-server/fable-remoting/#6-create-the-client-proxy","text":"We now need a corresponding client proxy in order to be able to connect to the server. Open src/Client/Client.fs and insert the following right after the Msg type: open Fable.Remoting.Client let myApi = Remoting . createApi () |> Remoting . withRouteBuilder Route . builder |> Remoting . buildProxy < IMyApi >","title":"6. Create the Client proxy"},{"location":"recipes/client-server/fable-remoting/#7-make-calls-to-the-server","text":"Replace the following two lines in the init function in Client.fs : let getHello () = Fetch . get < unit , string > Route . hello let cmd = Cmd . OfPromise . perform getHello () GotHello with this: let cmd = Cmd . OfAsync . perform myApi . hello () GotHello","title":"7. Make calls to the Server"},{"location":"recipes/client-server/fable-remoting/#done","text":"At this point, the app should work just as it did before. Now, expanding the API and adding a new endpoint is as easy as adding a new field to the API protocol we defined in Shared.fs , editing the myApi record in Server.fs with the implementation, and finally making calls from the proxy.","title":"Done!"},{"location":"recipes/client-server/messaging-post/","text":"How do I send and receive data using POST? This recipe shows how to create an endpoint on the server and hook up it up to the client using HTTP POST. This recipe assumes that you have also followed this recipe and have an understanding of MVU messaging. This recipe only shows how to wire up the client and server. A POST endpoint is normally used to send data from the client to the server in the body, for example from a form. This is useful when we need to supply more data than can easily be provided in the URI. You may wish to use POST for \"write\" operations and use GETs for \"reads\", however this is a highly opinionated topic that is beyond the scope of this recipe. I'm using the standard template (Fable Remoting) Fable Remoting takes care of deciding whether to use POST or GET etc. - you don't have to worry about this. Refer to this recipe for more details. I'm using the minimal template (Raw HTTP) In Shared 1. Create contract Create the type that will store the payload sent from the client to the server. type SaveCustomerRequest = { Name : string Age : int } On the Client 1. Call the endpoint Create a new function saveCustomer that will call the server. It supplies the customer to save, which is serialized and sent to the server in the body of the message. let saveCustomer customer = let save customer = Fetch . post < SaveCustomerRequest , int > ( \"/api/customer\" , customer ) Cmd . OfPromise . perform save customer CustomerSaved The generic arguments of Fetch.post are the input and output types. The example above shows that the input is of type SaveCustomerRequest with the response will contain an integer value. This may be the ID generated by the server for the save operation. This can now be called from within your update function e.g. | SaveCustomer request -> model , saveCustomer request | CustomerSaved generatedId -> { model with GeneratedCustomerId = Some generatedId ; Message = \"Saved customer!\" }, Cmd . none On the Server 1. Write implementation Create a function that can extract the payload from the body of the request using Giraffe's built-in model binding support : open FSharp.Control.Tasks open Giraffe open Microsoft.AspNetCore.Http open Shared /// Extracts the request from the body and saves to the database. let saveCustomer next (ctx:HttpContext) = task { let! customer = ctx.BindModelAsync<SaveCustomerRequest>() do! Database.saveCustomer customer return! Successful.OK \"Saved customer\" next ctx } 2. Expose your function Tie your function into the router, using the post verb instead of get . let webApp = router { post \"/api/customer\" saveCustomer // Add this }","title":"Post data to the server"},{"location":"recipes/client-server/messaging-post/#how-do-i-send-and-receive-data-using-post","text":"This recipe shows how to create an endpoint on the server and hook up it up to the client using HTTP POST. This recipe assumes that you have also followed this recipe and have an understanding of MVU messaging. This recipe only shows how to wire up the client and server. A POST endpoint is normally used to send data from the client to the server in the body, for example from a form. This is useful when we need to supply more data than can easily be provided in the URI. You may wish to use POST for \"write\" operations and use GETs for \"reads\", however this is a highly opinionated topic that is beyond the scope of this recipe.","title":"How do I send and receive data using POST?"},{"location":"recipes/client-server/messaging-post/#im-using-the-standard-template-fable-remoting","text":"Fable Remoting takes care of deciding whether to use POST or GET etc. - you don't have to worry about this. Refer to this recipe for more details.","title":"I'm using the standard template (Fable Remoting)"},{"location":"recipes/client-server/messaging-post/#im-using-the-minimal-template-raw-http","text":"","title":"I'm using the minimal template (Raw HTTP)"},{"location":"recipes/client-server/messaging-post/#in-shared","text":"","title":"In Shared"},{"location":"recipes/client-server/messaging-post/#1-create-contract","text":"Create the type that will store the payload sent from the client to the server. type SaveCustomerRequest = { Name : string Age : int }","title":"1. Create contract"},{"location":"recipes/client-server/messaging-post/#on-the-client","text":"","title":"On the Client"},{"location":"recipes/client-server/messaging-post/#1-call-the-endpoint","text":"Create a new function saveCustomer that will call the server. It supplies the customer to save, which is serialized and sent to the server in the body of the message. let saveCustomer customer = let save customer = Fetch . post < SaveCustomerRequest , int > ( \"/api/customer\" , customer ) Cmd . OfPromise . perform save customer CustomerSaved The generic arguments of Fetch.post are the input and output types. The example above shows that the input is of type SaveCustomerRequest with the response will contain an integer value. This may be the ID generated by the server for the save operation. This can now be called from within your update function e.g. | SaveCustomer request -> model , saveCustomer request | CustomerSaved generatedId -> { model with GeneratedCustomerId = Some generatedId ; Message = \"Saved customer!\" }, Cmd . none","title":"1. Call the endpoint"},{"location":"recipes/client-server/messaging-post/#on-the-server","text":"","title":"On the Server"},{"location":"recipes/client-server/messaging-post/#1-write-implementation","text":"Create a function that can extract the payload from the body of the request using Giraffe's built-in model binding support : open FSharp.Control.Tasks open Giraffe open Microsoft.AspNetCore.Http open Shared /// Extracts the request from the body and saves to the database. let saveCustomer next (ctx:HttpContext) = task { let! customer = ctx.BindModelAsync<SaveCustomerRequest>() do! Database.saveCustomer customer return! Successful.OK \"Saved customer\" next ctx }","title":"1. Write implementation"},{"location":"recipes/client-server/messaging-post/#2-expose-your-function","text":"Tie your function into the router, using the post verb instead of get . let webApp = router { post \"/api/customer\" saveCustomer // Add this }","title":"2. Expose your function"},{"location":"recipes/client-server/messaging/","text":"How do I send and receive data? This recipe shows how to create an endpoint on the server and hook up it up to the client. This recipe assumes that you have also followed this recipe and have an understanding of MVU messaging. This recipe only shows how to wire up the client and server. I'm using the standard template (Fable Remoting) Fable Remoting is a library which allows you to create client/server messaging without any need to think about HTTP verbs or serialization etc. In Shared 1. Update contract Add your new endpoint onto an existing API contract e.g. ITodosApi . Because Fable Remoting exposes your API through F# on client and server, you get type safety across both. type ITodosApi = { getCustomer : int -> Async < Customer option > } On the server 1. Write implementation Create a function that implements the back-end service that you require. Use standard functions to read from databases or other external sources as required. let loadCustomer customerId = async { return Some { Name = \"My Customer\" } } Note the use of async here. Fable Remoting uses async workflows, and not tasks. You can write functions that use task, but will have to at some point map to async using Async.AwaitTask . 2. Expose your function Tie the function you've just written into the API implementation. let todosApi = { ///... getCustomer = loadCustomer } 3. Test the endpoint (optional) Test out your endpoint using e.g. web browser / Postman / REST Client for VS Code etc. See here for more details on the required format. On the client 1. Call the endpoint Create a new function loadCustomer that will call the endpoint. let loadCustomer customerId = Cmd . OfAsync . perform todosApi . getCustomer customerId LoadedCustomer Note the final value supplied, CustomerLoaded . This is the Msg case that will be sent into the Elmish loop once the call returns , with the returned data. It should take in a value that matches the type returned by the Server e.g. CustomerLoaded of Customer option . See here for more information. This can now be called from within your update function e.g. | LoadCustomer customerId -> model , loadCustomer customerId I'm using the minimal template (Raw HTTP) This recipe shows how to create a GET endpoint on the server and consume it on the client using the Fetch API. On the Server 1. Write implementation Create a function that implements the back-end service that you require. Use standard functions to read from databases or other external sources as required. open Saturn open FSharp.Control.Tasks /// Loads a customer from the DB and returns as a Customer in json. let loadCustomer ( customerId : int ) next ctx = task { let customer = { Name = \"My Customer\" } return ! json customer next ctx } Note how we parameterise this function to take in the customerId as the first argument. Any parameters you need should be supplied in this manner. If you do not need any parameters, just omit them and leave the next and ctx ones. This example does not cover dealing with \"missing\" data e.g. invalid customer ID is found. 2.Expose your function Tie the function into the router with a route. let webApp = router { getf \"/api/customer/%i\" loadCustomer // Add this } Note the use of getf rather than get . If you do not need any parameters, just use get . See here for reference docs on the use of the Saturn router. 3. Test the endpoint (optional) Test out your endpoint using e.g. web browser / Postman / REST Client for VS Code etc. On the client 1. Call the endpoint Create a new function loadCustomer that will call the endpoint. let loadCustomer customerId = let loadCustomer () = Fetch . get < unit , Customer > ( sprintf \"/api/customer/%i\" customerId ) Cmd . OfPromise . perform loadCustomer () CustomerLoaded Note the final value supplied, CustomerLoaded . This is the Msg case that will be sent into the Elmish loop once the call returns , with the returned data. It should take in a value that matches the type returned by the Server e.g. CustomerLoaded of Customer . See here for more information. An alternative (and slightly more succinct) way of writing this is: let loadCustomer customerId = let loadCustomer = sprintf \"/api/customer/%i\" >> Fetch . get < unit , Customer > Cmd . OfPromise . perform loadCustomer customerId CustomerLoaded This can now be called from within your update function e.g. | LoadCustomer customerId -> model , loadCustomer customerId","title":"Get data from the server"},{"location":"recipes/client-server/messaging/#how-do-i-send-and-receive-data","text":"This recipe shows how to create an endpoint on the server and hook up it up to the client. This recipe assumes that you have also followed this recipe and have an understanding of MVU messaging. This recipe only shows how to wire up the client and server.","title":"How do I send and receive data?"},{"location":"recipes/client-server/messaging/#im-using-the-standard-template-fable-remoting","text":"Fable Remoting is a library which allows you to create client/server messaging without any need to think about HTTP verbs or serialization etc.","title":"I'm using the standard template (Fable Remoting)"},{"location":"recipes/client-server/messaging/#in-shared","text":"","title":"In Shared"},{"location":"recipes/client-server/messaging/#1-update-contract","text":"Add your new endpoint onto an existing API contract e.g. ITodosApi . Because Fable Remoting exposes your API through F# on client and server, you get type safety across both. type ITodosApi = { getCustomer : int -> Async < Customer option > }","title":"1. Update contract"},{"location":"recipes/client-server/messaging/#on-the-server","text":"","title":"On the server"},{"location":"recipes/client-server/messaging/#1-write-implementation","text":"Create a function that implements the back-end service that you require. Use standard functions to read from databases or other external sources as required. let loadCustomer customerId = async { return Some { Name = \"My Customer\" } } Note the use of async here. Fable Remoting uses async workflows, and not tasks. You can write functions that use task, but will have to at some point map to async using Async.AwaitTask .","title":"1. Write implementation"},{"location":"recipes/client-server/messaging/#2-expose-your-function","text":"Tie the function you've just written into the API implementation. let todosApi = { ///... getCustomer = loadCustomer }","title":"2. Expose your function"},{"location":"recipes/client-server/messaging/#3-test-the-endpoint-optional","text":"Test out your endpoint using e.g. web browser / Postman / REST Client for VS Code etc. See here for more details on the required format.","title":"3. Test the endpoint (optional)"},{"location":"recipes/client-server/messaging/#on-the-client","text":"","title":"On the client"},{"location":"recipes/client-server/messaging/#1-call-the-endpoint","text":"Create a new function loadCustomer that will call the endpoint. let loadCustomer customerId = Cmd . OfAsync . perform todosApi . getCustomer customerId LoadedCustomer Note the final value supplied, CustomerLoaded . This is the Msg case that will be sent into the Elmish loop once the call returns , with the returned data. It should take in a value that matches the type returned by the Server e.g. CustomerLoaded of Customer option . See here for more information. This can now be called from within your update function e.g. | LoadCustomer customerId -> model , loadCustomer customerId","title":"1. Call the endpoint"},{"location":"recipes/client-server/messaging/#im-using-the-minimal-template-raw-http","text":"This recipe shows how to create a GET endpoint on the server and consume it on the client using the Fetch API.","title":"I'm using the minimal template (Raw HTTP)"},{"location":"recipes/client-server/messaging/#on-the-server_1","text":"","title":"On the Server"},{"location":"recipes/client-server/messaging/#1-write-implementation_1","text":"Create a function that implements the back-end service that you require. Use standard functions to read from databases or other external sources as required. open Saturn open FSharp.Control.Tasks /// Loads a customer from the DB and returns as a Customer in json. let loadCustomer ( customerId : int ) next ctx = task { let customer = { Name = \"My Customer\" } return ! json customer next ctx } Note how we parameterise this function to take in the customerId as the first argument. Any parameters you need should be supplied in this manner. If you do not need any parameters, just omit them and leave the next and ctx ones. This example does not cover dealing with \"missing\" data e.g. invalid customer ID is found.","title":"1. Write implementation"},{"location":"recipes/client-server/messaging/#2expose-your-function","text":"Tie the function into the router with a route. let webApp = router { getf \"/api/customer/%i\" loadCustomer // Add this } Note the use of getf rather than get . If you do not need any parameters, just use get . See here for reference docs on the use of the Saturn router.","title":"2.Expose your function"},{"location":"recipes/client-server/messaging/#3-test-the-endpoint-optional_1","text":"Test out your endpoint using e.g. web browser / Postman / REST Client for VS Code etc.","title":"3. Test the endpoint (optional)"},{"location":"recipes/client-server/messaging/#on-the-client_1","text":"","title":"On the client"},{"location":"recipes/client-server/messaging/#1-call-the-endpoint_1","text":"Create a new function loadCustomer that will call the endpoint. let loadCustomer customerId = let loadCustomer () = Fetch . get < unit , Customer > ( sprintf \"/api/customer/%i\" customerId ) Cmd . OfPromise . perform loadCustomer () CustomerLoaded Note the final value supplied, CustomerLoaded . This is the Msg case that will be sent into the Elmish loop once the call returns , with the returned data. It should take in a value that matches the type returned by the Server e.g. CustomerLoaded of Customer . See here for more information. An alternative (and slightly more succinct) way of writing this is: let loadCustomer customerId = let loadCustomer = sprintf \"/api/customer/%i\" >> Fetch . get < unit , Customer > Cmd . OfPromise . perform loadCustomer customerId CustomerLoaded This can now be called from within your update function e.g. | LoadCustomer customerId -> model , loadCustomer customerId","title":"1. Call the endpoint"},{"location":"recipes/client-server/mvu-roundtrip/","text":"How do I load data from server to client using MVU? This recipe demonstrates the steps you need to take to store new data on the client using the MVU pattern, which is typically read from the Server. You will learn the steps required to modify the model, update and view functions to handle a button click which requests data from the server and handles the response. In Shared 1. Create shared domain Create a type in the Shared project which will act as the contract type between client and server. As SAFE compiles F# into JavaScript for you, you only need a single definition which will automatically be shared. type Customer = { Name : string } On the Client 1. Create message pairs Modify the Msg type to have two new messages: type Msg = // other messages ... | LoadCustomer of customerId : int // Add this | CustomerLoaded of Customer // Add this You will see that this symmetrical pattern is often followed in MVU: A command to initiate a call to the server for some data ( Load Customer) An event with the result of calling the command (Customer Loaded ) 2. Update the Model Update the Model to store the Customer once it is loaded: type Model = { // ... TheCustomer : Customer option } Make TheCustomer optional so that it can be initialised as None (see next step). 3. Update the Init function Update the init function to provide default data let model = { // ... TheCustomer = None } 4. Update the View Update your view to initiate the LoadCustomer event. Here, we create a button that will start loading customer 42 on click: let view model dispatch = div [] [ // ... button [ OnClick ( fun _ -> dispatch ( LoadCustomer 42 )) ] [ str \"Load Customer\" ] ] 5. Handle the Update Modify the update function to handle the new messages: let update msg model = match msg with // .... | LoadCustomer customerId -> // Implementation to connect to the server to be defined. | CustomerLoaded c -> { model with TheCustomer = Some c }, Cmd . none The code to fire off the message to the server differs depending on the client / server communication you are using and normally whether you are reading or writing data. See here for more information.","title":"Perform roundtrips with MVU"},{"location":"recipes/client-server/mvu-roundtrip/#how-do-i-load-data-from-server-to-client-using-mvu","text":"This recipe demonstrates the steps you need to take to store new data on the client using the MVU pattern, which is typically read from the Server. You will learn the steps required to modify the model, update and view functions to handle a button click which requests data from the server and handles the response.","title":"How do I load data from server to client using MVU?"},{"location":"recipes/client-server/mvu-roundtrip/#in-shared","text":"","title":"In Shared"},{"location":"recipes/client-server/mvu-roundtrip/#1-create-shared-domain","text":"Create a type in the Shared project which will act as the contract type between client and server. As SAFE compiles F# into JavaScript for you, you only need a single definition which will automatically be shared. type Customer = { Name : string }","title":"1. Create shared domain"},{"location":"recipes/client-server/mvu-roundtrip/#on-the-client","text":"","title":"On the Client"},{"location":"recipes/client-server/mvu-roundtrip/#1-create-message-pairs","text":"Modify the Msg type to have two new messages: type Msg = // other messages ... | LoadCustomer of customerId : int // Add this | CustomerLoaded of Customer // Add this You will see that this symmetrical pattern is often followed in MVU: A command to initiate a call to the server for some data ( Load Customer) An event with the result of calling the command (Customer Loaded )","title":"1. Create message pairs"},{"location":"recipes/client-server/mvu-roundtrip/#2-update-the-model","text":"Update the Model to store the Customer once it is loaded: type Model = { // ... TheCustomer : Customer option } Make TheCustomer optional so that it can be initialised as None (see next step).","title":"2. Update the Model"},{"location":"recipes/client-server/mvu-roundtrip/#3-update-the-init-function","text":"Update the init function to provide default data let model = { // ... TheCustomer = None }","title":"3. Update the Init function"},{"location":"recipes/client-server/mvu-roundtrip/#4-update-the-view","text":"Update your view to initiate the LoadCustomer event. Here, we create a button that will start loading customer 42 on click: let view model dispatch = div [] [ // ... button [ OnClick ( fun _ -> dispatch ( LoadCustomer 42 )) ] [ str \"Load Customer\" ] ]","title":"4. Update the View"},{"location":"recipes/client-server/mvu-roundtrip/#5-handle-the-update","text":"Modify the update function to handle the new messages: let update msg model = match msg with // .... | LoadCustomer customerId -> // Implementation to connect to the server to be defined. | CustomerLoaded c -> { model with TheCustomer = Some c }, Cmd . none The code to fire off the message to the server differs depending on the client / server communication you are using and normally whether you are reading or writing data. See here for more information.","title":"5. Handle the Update"},{"location":"recipes/client-server/saturn-to-giraffe/","text":"How do I use Giraffe instead of Saturn? Saturn is a functional alternative to MVC and Razor which sits on top of Giraffe . Giraffe itself is a functional wrapper around the ASP.NET Core web framework, making it easier to work with when using F#. Since Saturn is built on top of Giraffe, migrating to using \"raw\" Giraffe is relatively simple to do. Bootstrapping the Application 1. Open libraries Navigate to the Server module in the Server project. Remove open Saturn and replace it with open Giraffe open Microsoft.AspNetCore.Builder open Microsoft.Extensions.DependencyInjection open Microsoft.Extensions.Hosting open Microsoft.AspNetCore.Hosting 2. Replace application In the same module, we need to replace the Server's application computation expression with some functions which set up the default host, configure the application and register services. Remove this let app = application { // ...setup functions } run app and replace it with this let configureApp ( app : IApplicationBuilder ) = app . UseStaticFiles () . UseGiraffe webApp let configureServices ( services : IServiceCollection ) = services . AddGiraffe () |> ignore Host . CreateDefaultBuilder () . ConfigureWebHostDefaults ( fun webHostBuilder -> webHostBuilder . Configure ( configureApp ) . ConfigureServices ( configureServices ) . UseUrls ([| \"http://0.0.0.0:8085\" |]) . UseWebRoot ( \"public\" ) |> ignore ) . Build () . Run () Routing If you are using the standard SAFE template, there is nothing more you need to do, as routing is taken care of by Fable Remoting. If however you are using the minimal template, you will need to replace the Saturn router expression with the Giraffe equivalent. Replace this let webApp = router { get Route . hello ( json \"Hello from SAFE!\" ) } with this let webApp = route Route . hello >=> json \"Hello from SAFE!\" Other setup The steps shown here are the minimal necessary to get a SAFE app running using Giraffe. As with any Server setup however, there are many more optional parameters that you may wish to configure, such as caching , response compression and serialisation options as seen in the default SAFE templates amongst many others. See the Giraffe and ASP.NET Core host builder , application builder and service collection docs for more information on this.","title":"Use Giraffe instead of Saturn"},{"location":"recipes/client-server/saturn-to-giraffe/#how-do-i-use-giraffe-instead-of-saturn","text":"Saturn is a functional alternative to MVC and Razor which sits on top of Giraffe . Giraffe itself is a functional wrapper around the ASP.NET Core web framework, making it easier to work with when using F#. Since Saturn is built on top of Giraffe, migrating to using \"raw\" Giraffe is relatively simple to do.","title":"How do I use Giraffe instead of Saturn?"},{"location":"recipes/client-server/saturn-to-giraffe/#bootstrapping-the-application","text":"","title":"Bootstrapping the Application"},{"location":"recipes/client-server/saturn-to-giraffe/#1-open-libraries","text":"Navigate to the Server module in the Server project. Remove open Saturn and replace it with open Giraffe open Microsoft.AspNetCore.Builder open Microsoft.Extensions.DependencyInjection open Microsoft.Extensions.Hosting open Microsoft.AspNetCore.Hosting","title":"1. Open libraries"},{"location":"recipes/client-server/saturn-to-giraffe/#2-replace-application","text":"In the same module, we need to replace the Server's application computation expression with some functions which set up the default host, configure the application and register services. Remove this let app = application { // ...setup functions } run app and replace it with this let configureApp ( app : IApplicationBuilder ) = app . UseStaticFiles () . UseGiraffe webApp let configureServices ( services : IServiceCollection ) = services . AddGiraffe () |> ignore Host . CreateDefaultBuilder () . ConfigureWebHostDefaults ( fun webHostBuilder -> webHostBuilder . Configure ( configureApp ) . ConfigureServices ( configureServices ) . UseUrls ([| \"http://0.0.0.0:8085\" |]) . UseWebRoot ( \"public\" ) |> ignore ) . Build () . Run ()","title":"2. Replace application"},{"location":"recipes/client-server/saturn-to-giraffe/#routing","text":"If you are using the standard SAFE template, there is nothing more you need to do, as routing is taken care of by Fable Remoting. If however you are using the minimal template, you will need to replace the Saturn router expression with the Giraffe equivalent. Replace this let webApp = router { get Route . hello ( json \"Hello from SAFE!\" ) } with this let webApp = route Route . hello >=> json \"Hello from SAFE!\"","title":"Routing"},{"location":"recipes/client-server/saturn-to-giraffe/#other-setup","text":"The steps shown here are the minimal necessary to get a SAFE app running using Giraffe. As with any Server setup however, there are many more optional parameters that you may wish to configure, such as caching , response compression and serialisation options as seen in the default SAFE templates amongst many others. See the Giraffe and ASP.NET Core host builder , application builder and service collection docs for more information on this.","title":"Other setup"},{"location":"recipes/client-server/server-errors-on-client/","text":"How Do I Handle Server Exceptions on the Client? SAFE Stack makes it easy to catch and handle exceptions raised by the server on the client. Though the way we make a call to the server from the client is different between the standard and the minimal template, the way we handle server errors on the client is the same in principle. 1. Update the Model Update the model to store the error details that we receive from the server. Find the Model type in src/Client/Index.fs and add it the following Errors field: type Model = { ... // the rest of the fields Errors : string list } Now, bind an empty list to the field record inside the init function: let model = { ... // the rest of the fields Errors = [] } 2. Add an Error Message Handler We now add a new message to handle errors that we get back from the server after making a request. Add the following case to the Msg type: type Msg = | ... // other message cases | GotError of exn 3. Handle the new Message In this simple example, we will simply capture the Message of the exception. Add the following line to the end of the pattern match inside the update function: | GotError ex -> { model with Errors = ex . Message :: model . Errors }, Cmd . none The following steps will vary depending on whether you\u2019re using the standard template or the minimal one. 4. Connect Server Errors to Elmish We now have to connect up the server response to the new message we created. Elmish has support for this through the either Cmd functions (instead of the perform functions). Make the following changes to your server call: I Am Using the Standard Template let cmd = Cmd . OfAsync . perform todosApi . getTodos () GotTodos \u2026and replace it with the following: let cmd = Cmd . OfAsync . either todosApi . getTodos () GotTodos GotError I Am Using the Minimal Template let cmd = Cmd . OfPromise . perform getHello () GotHello \u2026and replace it with the following: let cmd = Cmd . OfPromise . either getHello () GotHello GotError Done! Now, if you get an exception from the Server, its message will be added to the Errors field of the Model type. Instead of throwing the error, you can now display a meaningful text to the user like so: [ for msg in errorMessages do p [] [ str msg ] ]","title":"Handle server errors on the client"},{"location":"recipes/client-server/server-errors-on-client/#how-do-i-handle-server-exceptions-on-the-client","text":"SAFE Stack makes it easy to catch and handle exceptions raised by the server on the client. Though the way we make a call to the server from the client is different between the standard and the minimal template, the way we handle server errors on the client is the same in principle.","title":"How Do I Handle Server Exceptions on the Client?"},{"location":"recipes/client-server/server-errors-on-client/#1-update-the-model","text":"Update the model to store the error details that we receive from the server. Find the Model type in src/Client/Index.fs and add it the following Errors field: type Model = { ... // the rest of the fields Errors : string list } Now, bind an empty list to the field record inside the init function: let model = { ... // the rest of the fields Errors = [] }","title":"1. Update the Model"},{"location":"recipes/client-server/server-errors-on-client/#2-add-an-error-message-handler","text":"We now add a new message to handle errors that we get back from the server after making a request. Add the following case to the Msg type: type Msg = | ... // other message cases | GotError of exn","title":"2. Add an Error Message Handler"},{"location":"recipes/client-server/server-errors-on-client/#3-handle-the-new-message","text":"In this simple example, we will simply capture the Message of the exception. Add the following line to the end of the pattern match inside the update function: | GotError ex -> { model with Errors = ex . Message :: model . Errors }, Cmd . none The following steps will vary depending on whether you\u2019re using the standard template or the minimal one.","title":"3. Handle the new Message"},{"location":"recipes/client-server/server-errors-on-client/#4-connect-server-errors-to-elmish","text":"We now have to connect up the server response to the new message we created. Elmish has support for this through the either Cmd functions (instead of the perform functions). Make the following changes to your server call:","title":"4. Connect Server Errors to Elmish"},{"location":"recipes/client-server/server-errors-on-client/#i-am-using-the-standard-template","text":"let cmd = Cmd . OfAsync . perform todosApi . getTodos () GotTodos \u2026and replace it with the following: let cmd = Cmd . OfAsync . either todosApi . getTodos () GotTodos GotError","title":"I Am Using the Standard Template"},{"location":"recipes/client-server/server-errors-on-client/#i-am-using-the-minimal-template","text":"let cmd = Cmd . OfPromise . perform getHello () GotHello \u2026and replace it with the following: let cmd = Cmd . OfPromise . either getHello () GotHello GotError","title":"I Am Using the Minimal Template"},{"location":"recipes/client-server/server-errors-on-client/#done","text":"Now, if you get an exception from the Server, its message will be added to the Errors field of the Model type. Instead of throwing the error, you can now display a meaningful text to the user like so: [ for msg in errorMessages do p [] [ str msg ] ]","title":"Done!"},{"location":"recipes/client-server/share-code/","text":"How Do I Share Code Types Between the Client and the Server? SAFE Stack makes it really simple and easy to share code between the client and the server, since both of them are written in F#. The client side is transpiled into JavaScript via webpack, whilst the server side is compiled down to .NET CIL. Serialization between both happens in the background, so you don't have to worry about it. Types Let\u2019s say the you have the following type in src/Server/Server.fs : type Customer = { Id : Guid Name : string Email : string PhoneNumber : string } Values and Functions And you have the following function that is used to validate this Customer type in src/Client/Index.fs : let customerIsValid customer = ( Guid . Empty = customer . Id || String . IsNullOrEmpty customer . Name || String . IsNullOrEmpty customer . Email || String . IsNullOrEmpty customer . PhoneNumber ) |> not Shared If at any point you realise you need to use both the Customer type and the customerIsValid function both in the Client and the Server, all you need to do is to move both of them to Shared project. You can either put them in the Shared.fs file, or create your own file in the Shared project (eg. Customer.fs ). After this, you will be able to use both the Customer type and the customerIsValid function in both the Client and the Server. Serialization SAFE comes out of the box with [Fable.Remoting] or [Thoth] for serialization. These will handle transport of data seamlessly for you. Considerations Be careful not to place code in Shared.fs that depends on a Client or Server-specific dependency. If your code depends on Fable for example, in most cases it will not be suitable to place it in Shared, since it can only be used in Client. Similarly, if your types rely on .NET specific types in e.g. the framework class library (FCL), beware. Fable has built-in mappings for popular .NET types e.g. System.DateTime and System.Math , but you will have to write your own mappers otherwise.","title":"Share code between the client and the server"},{"location":"recipes/client-server/share-code/#how-do-i-share-code-types-between-the-client-and-the-server","text":"SAFE Stack makes it really simple and easy to share code between the client and the server, since both of them are written in F#. The client side is transpiled into JavaScript via webpack, whilst the server side is compiled down to .NET CIL. Serialization between both happens in the background, so you don't have to worry about it.","title":"How Do I Share Code Types Between the Client and the Server?"},{"location":"recipes/client-server/share-code/#types","text":"Let\u2019s say the you have the following type in src/Server/Server.fs : type Customer = { Id : Guid Name : string Email : string PhoneNumber : string }","title":"Types"},{"location":"recipes/client-server/share-code/#values-and-functions","text":"And you have the following function that is used to validate this Customer type in src/Client/Index.fs : let customerIsValid customer = ( Guid . Empty = customer . Id || String . IsNullOrEmpty customer . Name || String . IsNullOrEmpty customer . Email || String . IsNullOrEmpty customer . PhoneNumber ) |> not","title":"Values and Functions"},{"location":"recipes/client-server/share-code/#shared","text":"If at any point you realise you need to use both the Customer type and the customerIsValid function both in the Client and the Server, all you need to do is to move both of them to Shared project. You can either put them in the Shared.fs file, or create your own file in the Shared project (eg. Customer.fs ). After this, you will be able to use both the Customer type and the customerIsValid function in both the Client and the Server.","title":"Shared"},{"location":"recipes/client-server/share-code/#serialization","text":"SAFE comes out of the box with [Fable.Remoting] or [Thoth] for serialization. These will handle transport of data seamlessly for you.","title":"Serialization"},{"location":"recipes/client-server/share-code/#considerations","text":"Be careful not to place code in Shared.fs that depends on a Client or Server-specific dependency. If your code depends on Fable for example, in most cases it will not be suitable to place it in Shared, since it can only be used in Client. Similarly, if your types rely on .NET specific types in e.g. the framework class library (FCL), beware. Fable has built-in mappings for popular .NET types e.g. System.DateTime and System.Math , but you will have to write your own mappers otherwise.","title":"Considerations"},{"location":"recipes/developing-and-testing/debug-safe-app/","text":"How do I debug a SAFE app? I'm using Visual Studio In order to debug Server code from Visual Studio, we need set the correct URLs in the project's debug properties. Debugging the Server 1. Configure launch settings You can do this through the Server project's Properties/Debug editor or by editing the launchSettings.json file which is in the properties folder. After selecting the debug profile that you wish to edit ( IIS Express or Server ), you will need to set the App URL field to http://localhost:8085 and Launch browser field to http://localhost:8080 . The process is very similar for VS Mac. Once this is done, you can expect your launchSettings.json file to look something like this: { \"iisSettings\" : { \"windowsAuthentication\" : false , \"anonymousAuthentication\" : true , \"iisExpress\" : { \"applicationUrl\" : \"http://localhost:8085/\" , \"sslPort\" : 44330 } }, \"profiles\" : { \"IIS Express\" : { \"commandName\" : \"IISExpress\" , \"launchBrowser\" : true , \"launchUrl\" : \"http://localhost:8080/\" , \"environmentVariables\" : { \"ASPNETCORE_ENVIRONMENT\" : \"Development\" } }, \"Server\" : { \"commandName\" : \"Project\" , \"launchBrowser\" : true , \"launchUrl\" : \"http://localhost:8080\" , \"environmentVariables\" : { \"ASPNETCORE_ENVIRONMENT\" : \"Development\" }, \"applicationUrl\" : \"http://localhost:8085\" } } } 2. Start the Client Since you will be running the server directly through Visual Studio, you cannot use a FAKE script to start the application, so launch the client directly using e.g. npm run start . 3. Debug the Server Set the server as your Startup project, either using the drop-down menu at the top of the IDE or by right clicking on the project itself and selecting Set as Startup Project . Select the profile that you set up earlier and wish to launch from the drop-down at the top of the IDE. Either press the Play button at the top of the IDE or hit F5 on your keyboard to start the Server debugging and launch a browser pointing at the website. Debugging the Client Although we write our client-side code using F#, it is being converted into Javascript at runtime by Fable and executed in the browser. However, we can still debug it via the magic of source mapping. If you are using Visual Studio, you cannot directly connect to the browser debugger. You can, however, debug your client F# code using the browser's development tools. 1. Set breakpoints in Client code The exact instructions will depend on your browser, but essentially it simply involves: Opening the Developer tools panel (usually by hitting F12). Finding the F# file you want to add breakpoints to in the source of the website (look inside the webpack folder). Add breakpoints to it in your browser inspector. I'm using VS Code VS Code allows \"full stack\" debugging i.e. both F# on the client and server. Prerequisites that you should install: 0. Install Prerequisites Install either Google Chrome or Microsoft Edge : Enables client-side debugging. Configure your browser with the following extensions: Redux Dev Tools : Provides improved debugging support in Chrome with Elmish and access to Redux debugging. React Developer Tools : Provides access to React debugging in Chrome. Configure VS Code with the following extensions: Ionide : Provides F# support to Code. C# : Provides .NET Core debugging support. Debugger for Chrome : Provides integrated client-side debugging in Code. Debugger for Edge : Provides integrated client-side debugging in Code. 1. Create a launch.json file Open the Command Palette using Ctrl+Shift+P and run Debug: Open launch.json . This will ask you to choose a platform; select .NET Core . This will create a launch.json file in the root of your solution and also open it in the editor. 2. Add a Configuration Click the \"Add Configuration...\" button and choose Launch .NET Core Console Application . The only change required is to point it at the Server application, by replacing the program line with this: \"program\" : \"${workspaceFolder}/src/Server/bin/Debug/netcoreapp3.1/Server.dll\" , 3. Configure a build task From the Command Palette, choose Configure Task . Select Create tasks.json file from template . This will show you a list of pre-configured templates. Select .NET Core . 4. Debug the Server Either hit F5 or open the Debugging pane and press the Play button to build and launch the Server with the debugger attached. Observe that the Debug Console panel will show output from the server. The server is now running and you can set breakpoints and view the callstack etc. 5. Debug the Client Start the Client using e.g. npm run start . Open the Command Palette and run Debug: Open Link . When prompted for a url, type http://localhost:8080/ . This will launch a browser which is pointed at the URL and connect the debugger to it. You can now set breakpoints in your Client within VS Code. Select the appropriate Debug Console you wish to view. If you find that your breakpoints aren't being hit, try stopping the Client, disconnecting the debugger and re-launching them both. To find out more about the VS Code debugger, see here .","title":"Debug a SAFE app"},{"location":"recipes/developing-and-testing/debug-safe-app/#how-do-i-debug-a-safe-app","text":"","title":"How do I debug a SAFE app?"},{"location":"recipes/developing-and-testing/debug-safe-app/#im-using-visual-studio","text":"In order to debug Server code from Visual Studio, we need set the correct URLs in the project's debug properties.","title":"I'm using Visual Studio"},{"location":"recipes/developing-and-testing/debug-safe-app/#debugging-the-server","text":"","title":"Debugging the Server"},{"location":"recipes/developing-and-testing/debug-safe-app/#1-configure-launch-settings","text":"You can do this through the Server project's Properties/Debug editor or by editing the launchSettings.json file which is in the properties folder. After selecting the debug profile that you wish to edit ( IIS Express or Server ), you will need to set the App URL field to http://localhost:8085 and Launch browser field to http://localhost:8080 . The process is very similar for VS Mac. Once this is done, you can expect your launchSettings.json file to look something like this: { \"iisSettings\" : { \"windowsAuthentication\" : false , \"anonymousAuthentication\" : true , \"iisExpress\" : { \"applicationUrl\" : \"http://localhost:8085/\" , \"sslPort\" : 44330 } }, \"profiles\" : { \"IIS Express\" : { \"commandName\" : \"IISExpress\" , \"launchBrowser\" : true , \"launchUrl\" : \"http://localhost:8080/\" , \"environmentVariables\" : { \"ASPNETCORE_ENVIRONMENT\" : \"Development\" } }, \"Server\" : { \"commandName\" : \"Project\" , \"launchBrowser\" : true , \"launchUrl\" : \"http://localhost:8080\" , \"environmentVariables\" : { \"ASPNETCORE_ENVIRONMENT\" : \"Development\" }, \"applicationUrl\" : \"http://localhost:8085\" } } }","title":"1. Configure launch settings"},{"location":"recipes/developing-and-testing/debug-safe-app/#2-start-the-client","text":"Since you will be running the server directly through Visual Studio, you cannot use a FAKE script to start the application, so launch the client directly using e.g. npm run start .","title":"2. Start the Client"},{"location":"recipes/developing-and-testing/debug-safe-app/#3-debug-the-server","text":"Set the server as your Startup project, either using the drop-down menu at the top of the IDE or by right clicking on the project itself and selecting Set as Startup Project . Select the profile that you set up earlier and wish to launch from the drop-down at the top of the IDE. Either press the Play button at the top of the IDE or hit F5 on your keyboard to start the Server debugging and launch a browser pointing at the website.","title":"3. Debug the Server"},{"location":"recipes/developing-and-testing/debug-safe-app/#debugging-the-client","text":"Although we write our client-side code using F#, it is being converted into Javascript at runtime by Fable and executed in the browser. However, we can still debug it via the magic of source mapping. If you are using Visual Studio, you cannot directly connect to the browser debugger. You can, however, debug your client F# code using the browser's development tools.","title":"Debugging the Client"},{"location":"recipes/developing-and-testing/debug-safe-app/#1-set-breakpoints-in-client-code","text":"The exact instructions will depend on your browser, but essentially it simply involves: Opening the Developer tools panel (usually by hitting F12). Finding the F# file you want to add breakpoints to in the source of the website (look inside the webpack folder). Add breakpoints to it in your browser inspector.","title":"1. Set breakpoints in Client code"},{"location":"recipes/developing-and-testing/debug-safe-app/#im-using-vs-code","text":"VS Code allows \"full stack\" debugging i.e. both F# on the client and server. Prerequisites that you should install:","title":"I'm using VS Code"},{"location":"recipes/developing-and-testing/debug-safe-app/#0-install-prerequisites","text":"Install either Google Chrome or Microsoft Edge : Enables client-side debugging. Configure your browser with the following extensions: Redux Dev Tools : Provides improved debugging support in Chrome with Elmish and access to Redux debugging. React Developer Tools : Provides access to React debugging in Chrome. Configure VS Code with the following extensions: Ionide : Provides F# support to Code. C# : Provides .NET Core debugging support. Debugger for Chrome : Provides integrated client-side debugging in Code. Debugger for Edge : Provides integrated client-side debugging in Code.","title":"0. Install Prerequisites"},{"location":"recipes/developing-and-testing/debug-safe-app/#1-create-a-launchjson-file","text":"Open the Command Palette using Ctrl+Shift+P and run Debug: Open launch.json . This will ask you to choose a platform; select .NET Core . This will create a launch.json file in the root of your solution and also open it in the editor.","title":"1. Create a launch.json file"},{"location":"recipes/developing-and-testing/debug-safe-app/#2-add-a-configuration","text":"Click the \"Add Configuration...\" button and choose Launch .NET Core Console Application . The only change required is to point it at the Server application, by replacing the program line with this: \"program\" : \"${workspaceFolder}/src/Server/bin/Debug/netcoreapp3.1/Server.dll\" ,","title":"2. Add a Configuration"},{"location":"recipes/developing-and-testing/debug-safe-app/#3-configure-a-build-task","text":"From the Command Palette, choose Configure Task . Select Create tasks.json file from template . This will show you a list of pre-configured templates. Select .NET Core .","title":"3. Configure a build task"},{"location":"recipes/developing-and-testing/debug-safe-app/#4-debug-the-server","text":"Either hit F5 or open the Debugging pane and press the Play button to build and launch the Server with the debugger attached. Observe that the Debug Console panel will show output from the server. The server is now running and you can set breakpoints and view the callstack etc.","title":"4. Debug the Server"},{"location":"recipes/developing-and-testing/debug-safe-app/#5-debug-the-client","text":"Start the Client using e.g. npm run start . Open the Command Palette and run Debug: Open Link . When prompted for a url, type http://localhost:8080/ . This will launch a browser which is pointed at the URL and connect the debugger to it. You can now set breakpoints in your Client within VS Code. Select the appropriate Debug Console you wish to view. If you find that your breakpoints aren't being hit, try stopping the Client, disconnecting the debugger and re-launching them both. To find out more about the VS Code debugger, see here .","title":"5. Debug the Client"},{"location":"recipes/developing-and-testing/testing-the-client/","text":"How do I test the client? Testing on the client is a little different than on the server. This is because the code which is ultimately being executed in the browser is Javascript, translated from F# by Fable, and so it must be tested in a Javascript environment. Furthermore, code that is shared between the Client and Server must be tested in both a dotnet environment and a Javascript environment. The SAFE template uses a library called Fable.Mocha which allows us to run the same tests in both environments. It mirrors the Expecto API and works in much the same way. I'm using the standard template If you are using the standard template then there is nothing more you need to do in order to start testing your Client. You will find a folder in the solution named tests . Inside this there is a project, Client.Tests , which contains a single script demonstrating how to use Mocha to test the TODO sample. Note the compiler directive here which makes sure that the Shared tests are only included when executing in a Javascript (Fable) context. They are covered by Expecto under dotnet as you can see in Server.Tests.fs . 1. Launch the test server In order to run the tests, instead of starting your application using dotnet fake build -t run you should instead use dotnet fake build -t runtests 2. View the results Once the build is complete and the website is running, navigate to http://localhost:8081/ in a web browser. You should see a test results page that looks like this: This command builds and runs the Server test project too. If you want to run the Client tests alone, you can simply launch the test server using npm run test:live , which executes a command stored in package.json . I'm using the minimal template If you are using the minimal template, you will need to first configure a test project as none are included. 1. Add a test project In the src folder, create a create a .Net Standard library called Client.Tests . cd src dotnet new ClassLib -lang F # -o Client.Tests cd .. dotnet sln add src / Client . Tests 2. Reference the Client project Reference the Client project from the Client.Tests project: dotnet add Client . Tests reference Client 3. Add the Fable.Mocha package to Test project Run the following command: dotnet add Client . Tests package Fable . Mocha 4. Add a test Delete the Library.fs file and replace it with a new file called Tests.fs to your test project. Add the following code to it: module Tests open Fable.Mocha open Index let client = testList \"Client\" [ testCase \"Hello received\" <| fun _ -> let hello = \"Hello Test!\" let model , _ = init () let model , _ = update ( GotHello hello ) model Expect . equal hello model . Hello \"The hello should be set\" ] let all = testList \"All\" [ client ] [< EntryPoint >] let main _ = Mocha . runTests all 5. Add Test web page Add a file called index.html to the root of the test project and add the following content to it: <!DOCTYPE html> < html > < head > < title > SAFE Client Tests </ title > </ head > < body > </ body > </ html > 6. Add test webpack config Add a new file root directory called webpack.tests.config.js . Populate it with the contents of a Fable-compatible webpack config template such as this . 7. Update the test webpack config Replace the CONFIG value in the webpack file you just created with the following: var CONFIG = { indexHtmlTemplate : ' ./ src / Client . Tests / index . html' , fsharpEntry : ' ./ src / Client . Tests / Client . Tests . fsproj' , outputDir : ' ./ src / Client . Tests' , assetsDir : ' ./ src / Client . Tests' , devServerPort : 8081 , devServerProxy : undefined , babel : undefined } Remove all references and code from the webpack file that refers to MiniCssExtractPlugin or CONFIG.cssEntry. 8. Add launch command Add the following entry to the scripts element in the Client project's package.json file: \"test:live\" : \"webpack-dev-server --config webpack.tests.config.js\" 9. Build the Tests Save all changes and build the Client.Test project. 9. Launch the test website Run the command npm install followed by npm run test : live Once the build is complete and the website is running, navigate to http://localhost:8081/ in a web browser. You should see a test results page that looks like this:","title":"Test the Client"},{"location":"recipes/developing-and-testing/testing-the-client/#how-do-i-test-the-client","text":"Testing on the client is a little different than on the server. This is because the code which is ultimately being executed in the browser is Javascript, translated from F# by Fable, and so it must be tested in a Javascript environment. Furthermore, code that is shared between the Client and Server must be tested in both a dotnet environment and a Javascript environment. The SAFE template uses a library called Fable.Mocha which allows us to run the same tests in both environments. It mirrors the Expecto API and works in much the same way.","title":"How do I test the client?"},{"location":"recipes/developing-and-testing/testing-the-client/#im-using-the-standard-template","text":"If you are using the standard template then there is nothing more you need to do in order to start testing your Client. You will find a folder in the solution named tests . Inside this there is a project, Client.Tests , which contains a single script demonstrating how to use Mocha to test the TODO sample. Note the compiler directive here which makes sure that the Shared tests are only included when executing in a Javascript (Fable) context. They are covered by Expecto under dotnet as you can see in Server.Tests.fs .","title":"I'm using the standard template"},{"location":"recipes/developing-and-testing/testing-the-client/#1-launch-the-test-server","text":"In order to run the tests, instead of starting your application using dotnet fake build -t run you should instead use dotnet fake build -t runtests","title":"1. Launch the test server"},{"location":"recipes/developing-and-testing/testing-the-client/#2-view-the-results","text":"Once the build is complete and the website is running, navigate to http://localhost:8081/ in a web browser. You should see a test results page that looks like this: This command builds and runs the Server test project too. If you want to run the Client tests alone, you can simply launch the test server using npm run test:live , which executes a command stored in package.json .","title":"2. View the results"},{"location":"recipes/developing-and-testing/testing-the-client/#im-using-the-minimal-template","text":"If you are using the minimal template, you will need to first configure a test project as none are included.","title":"I'm using the minimal template"},{"location":"recipes/developing-and-testing/testing-the-client/#1-add-a-test-project","text":"In the src folder, create a create a .Net Standard library called Client.Tests . cd src dotnet new ClassLib -lang F # -o Client.Tests cd .. dotnet sln add src / Client . Tests","title":"1. Add a test project"},{"location":"recipes/developing-and-testing/testing-the-client/#2-reference-the-client-project","text":"Reference the Client project from the Client.Tests project: dotnet add Client . Tests reference Client","title":"2. Reference the Client project"},{"location":"recipes/developing-and-testing/testing-the-client/#3-add-the-fablemocha-package-to-test-project","text":"Run the following command: dotnet add Client . Tests package Fable . Mocha","title":"3. Add the Fable.Mocha package to Test project"},{"location":"recipes/developing-and-testing/testing-the-client/#4-add-a-test","text":"Delete the Library.fs file and replace it with a new file called Tests.fs to your test project. Add the following code to it: module Tests open Fable.Mocha open Index let client = testList \"Client\" [ testCase \"Hello received\" <| fun _ -> let hello = \"Hello Test!\" let model , _ = init () let model , _ = update ( GotHello hello ) model Expect . equal hello model . Hello \"The hello should be set\" ] let all = testList \"All\" [ client ] [< EntryPoint >] let main _ = Mocha . runTests all","title":"4. Add a test"},{"location":"recipes/developing-and-testing/testing-the-client/#5-add-test-web-page","text":"Add a file called index.html to the root of the test project and add the following content to it: <!DOCTYPE html> < html > < head > < title > SAFE Client Tests </ title > </ head > < body > </ body > </ html >","title":"5. Add Test web page"},{"location":"recipes/developing-and-testing/testing-the-client/#6-add-test-webpack-config","text":"Add a new file root directory called webpack.tests.config.js . Populate it with the contents of a Fable-compatible webpack config template such as this .","title":"6. Add test webpack config"},{"location":"recipes/developing-and-testing/testing-the-client/#7-update-the-test-webpack-config","text":"Replace the CONFIG value in the webpack file you just created with the following: var CONFIG = { indexHtmlTemplate : ' ./ src / Client . Tests / index . html' , fsharpEntry : ' ./ src / Client . Tests / Client . Tests . fsproj' , outputDir : ' ./ src / Client . Tests' , assetsDir : ' ./ src / Client . Tests' , devServerPort : 8081 , devServerProxy : undefined , babel : undefined } Remove all references and code from the webpack file that refers to MiniCssExtractPlugin or CONFIG.cssEntry.","title":"7. Update the test webpack config"},{"location":"recipes/developing-and-testing/testing-the-client/#8-add-launch-command","text":"Add the following entry to the scripts element in the Client project's package.json file: \"test:live\" : \"webpack-dev-server --config webpack.tests.config.js\"","title":"8. Add launch command"},{"location":"recipes/developing-and-testing/testing-the-client/#9-build-the-tests","text":"Save all changes and build the Client.Test project.","title":"9. Build the Tests"},{"location":"recipes/developing-and-testing/testing-the-client/#9-launch-the-test-website","text":"Run the command npm install followed by npm run test : live Once the build is complete and the website is running, navigate to http://localhost:8081/ in a web browser. You should see a test results page that looks like this:","title":"9. Launch the test website"},{"location":"recipes/developing-and-testing/testing-the-server/","text":"How do I test the Server? Testing your Server code in a SAFE app is just the same as in any other dotnet app, and you can use the same tools and frameworks that you are familiar with. These include all of the usual suspects such as NUnit , XUnit , FSUnit , Expecto , FSCheck , AutoFixture etc. In this guide we will look at using Expecto , as this is included with the standard SAFE template. I'm using the standard template Using the Expecto runner If you are using the standard template, then there is nothing more you need to do in order to start testing your Server code. You will find a folder in the solution named tests . Inside this, there is a project named Server.Tests that contains a single script demonstrating how to use Expecto to test the TODO sample. In order to run the tests, instead of starting your application using dotnet fake build -t run you should instead use dotnet fake build -t runtests This will execute the tests and print the results into the console window. This method builds and runs the Client test project too, which can be slow. If you want to run the Server tests alone, you can simply navigate to the Server.Tests directory and run the project using dotnet run . Using dotnet test or the Visual Studio Test runner If you would like to use dotnet tests from the command line or the test runner that comes with Visual Studio, there are a couple of extra steps to follow. 1. Install the Test Adapters Run the following commands at the root of your solution: dotnet paket add Microsoft . NET . Test . Sdk -p Server . Tests dotnet paket add YoloDev . Expecto . TestSdk -p Server . Tests 2. Disable EntryPoint generation Open your ServerTests.fsproj file and add the following element: <PropertyGroup> <GenerateProgramFile> false </GenerateProgramFile> </PropertyGroup> 3. Discover tests To allow your tests to be discovered, you will need to decorate them with a [<Tests>] attribute. The provided test would look like this: [< Tests >] let server = testList \"Server\" [ testCase \"Adding valid Todo\" <| fun _ -> let storage = Storage () let validTodo = Todo . create \"TODO\" let expectedResult = Ok () let result = storage . AddTodo validTodo Expect . equal result expectedResult \"Result should be ok\" Expect . contains ( storage . GetTodos () ) validTodo \"Storage should contain new todo\" ] 4. Run tests There are now two ways to run these tests. From the command line, you can just run dotnet test from the root of your solution. Alternatively, if you are using Visual Studio or VS Mac you can make use of the built-in test explorers. I'm using the minimal template If you are using the minimal template, you will need to first configure a test project as none are included. 1. Add a test project In the src folder, create a create a .Net Core library called Server.Tests . cd src dotnet new console -lang F # -o Server.Tests cd .. dotnet sln add src / Server . Tests 2. Reference the Server project Reference the Server project from the Server.Tests project: dotnet add Server . Tests reference Server 3. Add Expecto to the Test project Run the following command: dotnet add Server . Tests package Expecto You will see a warning that a Program.fs file might be generated which will need deleting, so do that if necessary. You can prevent this reoccuring by adding an entry to your test project file: <PropertyGroup> <GenerateProgramFile> false </GenerateProgramFile> </PropertyGroup> 4. Add something to test Update the Server.fs file in the Server project to extract the message logic from the router like so: let getMessage () = \"Hello from SAFE!\" let webApp = router { get Route . hello ( getMessage () |> json ) } 5. Add a test Delete the Library.fs file in your test project and replace it with a new file called Tests.fs . Add the following code to it: module Server.Tests open Expecto let server = testList \"Server\" [ testCase \"Message returned correctly\" <| fun _ -> let expectedResult = \"Hello from SAFE!\" let result = Server . getMessage () Expect . equal result expectedResult \"Result should be ok\" ] [< EntryPoint >] let main _ = runTests defaultConfig server 6. Run the test Navigate to the Test project directory and execute it using dotnet run This will print out the results in the console window 7. Using dotnet test or the Visual Studio Test Explorer Navigate to the Test project directory and add the test runners using the following commands: dotnet add package Microsoft . NET . Test . Sdk and dotnet add package YoloDev . Expecto . TestSdk You can now add [<Test>] attributes to your tests so that they can be discovered, and then run them using the dotnet tooling in the same way as explained earlier for the standard template.","title":"Test the Server"},{"location":"recipes/developing-and-testing/testing-the-server/#how-do-i-test-the-server","text":"Testing your Server code in a SAFE app is just the same as in any other dotnet app, and you can use the same tools and frameworks that you are familiar with. These include all of the usual suspects such as NUnit , XUnit , FSUnit , Expecto , FSCheck , AutoFixture etc. In this guide we will look at using Expecto , as this is included with the standard SAFE template.","title":"How do I test the Server?"},{"location":"recipes/developing-and-testing/testing-the-server/#im-using-the-standard-template","text":"","title":"I'm using the standard template"},{"location":"recipes/developing-and-testing/testing-the-server/#using-the-expecto-runner","text":"If you are using the standard template, then there is nothing more you need to do in order to start testing your Server code. You will find a folder in the solution named tests . Inside this, there is a project named Server.Tests that contains a single script demonstrating how to use Expecto to test the TODO sample. In order to run the tests, instead of starting your application using dotnet fake build -t run you should instead use dotnet fake build -t runtests This will execute the tests and print the results into the console window. This method builds and runs the Client test project too, which can be slow. If you want to run the Server tests alone, you can simply navigate to the Server.Tests directory and run the project using dotnet run .","title":"Using the Expecto runner"},{"location":"recipes/developing-and-testing/testing-the-server/#using-dotnet-test-or-the-visual-studio-test-runner","text":"If you would like to use dotnet tests from the command line or the test runner that comes with Visual Studio, there are a couple of extra steps to follow.","title":"Using dotnet test or the Visual Studio Test runner"},{"location":"recipes/developing-and-testing/testing-the-server/#1-install-the-test-adapters","text":"Run the following commands at the root of your solution: dotnet paket add Microsoft . NET . Test . Sdk -p Server . Tests dotnet paket add YoloDev . Expecto . TestSdk -p Server . Tests","title":"1. Install the Test Adapters"},{"location":"recipes/developing-and-testing/testing-the-server/#2-disable-entrypoint-generation","text":"Open your ServerTests.fsproj file and add the following element: <PropertyGroup> <GenerateProgramFile> false </GenerateProgramFile> </PropertyGroup>","title":"2. Disable EntryPoint generation"},{"location":"recipes/developing-and-testing/testing-the-server/#3-discover-tests","text":"To allow your tests to be discovered, you will need to decorate them with a [<Tests>] attribute. The provided test would look like this: [< Tests >] let server = testList \"Server\" [ testCase \"Adding valid Todo\" <| fun _ -> let storage = Storage () let validTodo = Todo . create \"TODO\" let expectedResult = Ok () let result = storage . AddTodo validTodo Expect . equal result expectedResult \"Result should be ok\" Expect . contains ( storage . GetTodos () ) validTodo \"Storage should contain new todo\" ]","title":"3. Discover tests"},{"location":"recipes/developing-and-testing/testing-the-server/#4-run-tests","text":"There are now two ways to run these tests. From the command line, you can just run dotnet test from the root of your solution. Alternatively, if you are using Visual Studio or VS Mac you can make use of the built-in test explorers.","title":"4. Run tests"},{"location":"recipes/developing-and-testing/testing-the-server/#im-using-the-minimal-template","text":"If you are using the minimal template, you will need to first configure a test project as none are included.","title":"I'm using the minimal template"},{"location":"recipes/developing-and-testing/testing-the-server/#1-add-a-test-project","text":"In the src folder, create a create a .Net Core library called Server.Tests . cd src dotnet new console -lang F # -o Server.Tests cd .. dotnet sln add src / Server . Tests","title":"1. Add a test project"},{"location":"recipes/developing-and-testing/testing-the-server/#2-reference-the-server-project","text":"Reference the Server project from the Server.Tests project: dotnet add Server . Tests reference Server","title":"2. Reference the Server project"},{"location":"recipes/developing-and-testing/testing-the-server/#3-add-expecto-to-the-test-project","text":"Run the following command: dotnet add Server . Tests package Expecto You will see a warning that a Program.fs file might be generated which will need deleting, so do that if necessary. You can prevent this reoccuring by adding an entry to your test project file: <PropertyGroup> <GenerateProgramFile> false </GenerateProgramFile> </PropertyGroup>","title":"3. Add Expecto to the Test project"},{"location":"recipes/developing-and-testing/testing-the-server/#4-add-something-to-test","text":"Update the Server.fs file in the Server project to extract the message logic from the router like so: let getMessage () = \"Hello from SAFE!\" let webApp = router { get Route . hello ( getMessage () |> json ) }","title":"4. Add something to test"},{"location":"recipes/developing-and-testing/testing-the-server/#5-add-a-test","text":"Delete the Library.fs file in your test project and replace it with a new file called Tests.fs . Add the following code to it: module Server.Tests open Expecto let server = testList \"Server\" [ testCase \"Message returned correctly\" <| fun _ -> let expectedResult = \"Hello from SAFE!\" let result = Server . getMessage () Expect . equal result expectedResult \"Result should be ok\" ] [< EntryPoint >] let main _ = runTests defaultConfig server","title":"5. Add a test"},{"location":"recipes/developing-and-testing/testing-the-server/#6-run-the-test","text":"Navigate to the Test project directory and execute it using dotnet run This will print out the results in the console window","title":"6. Run the test"},{"location":"recipes/developing-and-testing/testing-the-server/#7-using-dotnet-test-or-the-visual-studio-test-explorer","text":"Navigate to the Test project directory and add the test runners using the following commands: dotnet add package Microsoft . NET . Test . Sdk and dotnet add package YoloDev . Expecto . TestSdk You can now add [<Test>] attributes to your tests so that they can be discovered, and then run them using the dotnet tooling in the same way as explained earlier for the standard template.","title":"7. Using dotnet test or the Visual Studio Test Explorer"},{"location":"recipes/developing-and-testing/using-hot-reload/","text":"How do I use hot reload? Hot reload is a great time-saving technology and something that every developer will find useful. Whenever changes are made to code, they are immediately reflected in the running application without needing to manually redeploy. The specific way that this is achieved depends on the nature of the application. In a SAFE app we have two distinct components, the Client and the Server. Whether you are using the minimal or standard SAFE template, there is nothing more you need to do in order to get started with hot reload. Client reloading If you deploy your application and then make a change in the Client, after a moment it will be reflected in the browser without a full re-deployment. Importantly, the state of your application will be retained across the deployment, so you can continue where you left off. This is achieved using the hot module replacement functionality provided by webpack . To Add Hot Module Replacement manually If your client project has been hand-rolled, or you simply wish to see how to add it from scratch: 1. Configure the Webpack Dev Server Add the following to the devServer object of your webpack config: var devServer = { // other fields elided... hot : true , proxy : { // Redirect websocket requests that start with /socket/ to the server on the port 8085 // This is used by Hot Module Replacement '/socket/**' : { target : 'http://localhost:8085' , ws : true } } } 2. Configure webpack module exports Import and create an instance HotModuleReplacementPlugin at the top of the webpack configuration file, and ensure that the plugin is added to module.exports : // Import and create the HMR plugin var { HotModuleReplacementPlugin } = require ( 'webpack' ); var hmrPlugin = new HotModuleReplacementPlugin (); // other configuration... module . exports = { // Add the HMR plugin to the module plugins : [ /* other plugins... */ , hmrPlugin ] } 3. Update your F# client app First, add the Fable.Elmish.Hmr package to the client: dotnet add package Fable . Elmish . Hmr Then, open the Elmish.HMR namespace in your app: # if DEBUG open Elmish.Debug open Elmish.HMR # endif Best practice is to include hot module reloading in debug (not production) mode only, since production applications will not benefit from HMR and will only result in an increased bundle size. Server reloading Server reloading isn't quite as fully automated. If you make a change in the Server code and save your work, the project will automatically rebuild and launch itself. Once this is complete however you will need to refresh your browser to see any visual changes. If you are using the minimal template, you need to make sure you launch the Server using dotnet watch run rather than just dotnet run . The standard template takes care of this step for you using its FAKE build script. If you have already restored your NuGet dependencies, you can get a little boost in restart speed by using dotnet watch run --no-restore as well.","title":"Use hot reload"},{"location":"recipes/developing-and-testing/using-hot-reload/#how-do-i-use-hot-reload","text":"Hot reload is a great time-saving technology and something that every developer will find useful. Whenever changes are made to code, they are immediately reflected in the running application without needing to manually redeploy. The specific way that this is achieved depends on the nature of the application. In a SAFE app we have two distinct components, the Client and the Server. Whether you are using the minimal or standard SAFE template, there is nothing more you need to do in order to get started with hot reload.","title":"How do I use hot reload?"},{"location":"recipes/developing-and-testing/using-hot-reload/#client-reloading","text":"If you deploy your application and then make a change in the Client, after a moment it will be reflected in the browser without a full re-deployment. Importantly, the state of your application will be retained across the deployment, so you can continue where you left off. This is achieved using the hot module replacement functionality provided by webpack .","title":"Client reloading"},{"location":"recipes/developing-and-testing/using-hot-reload/#to-add-hot-module-replacement-manually","text":"If your client project has been hand-rolled, or you simply wish to see how to add it from scratch:","title":"To Add Hot Module Replacement manually"},{"location":"recipes/developing-and-testing/using-hot-reload/#1-configure-the-webpack-dev-server","text":"Add the following to the devServer object of your webpack config: var devServer = { // other fields elided... hot : true , proxy : { // Redirect websocket requests that start with /socket/ to the server on the port 8085 // This is used by Hot Module Replacement '/socket/**' : { target : 'http://localhost:8085' , ws : true } } }","title":"1. Configure the Webpack Dev Server"},{"location":"recipes/developing-and-testing/using-hot-reload/#2-configure-webpack-module-exports","text":"Import and create an instance HotModuleReplacementPlugin at the top of the webpack configuration file, and ensure that the plugin is added to module.exports : // Import and create the HMR plugin var { HotModuleReplacementPlugin } = require ( 'webpack' ); var hmrPlugin = new HotModuleReplacementPlugin (); // other configuration... module . exports = { // Add the HMR plugin to the module plugins : [ /* other plugins... */ , hmrPlugin ] }","title":"2. Configure webpack module exports"},{"location":"recipes/developing-and-testing/using-hot-reload/#3-update-your-f-client-app","text":"First, add the Fable.Elmish.Hmr package to the client: dotnet add package Fable . Elmish . Hmr Then, open the Elmish.HMR namespace in your app: # if DEBUG open Elmish.Debug open Elmish.HMR # endif Best practice is to include hot module reloading in debug (not production) mode only, since production applications will not benefit from HMR and will only result in an increased bundle size.","title":"3. Update your F# client app"},{"location":"recipes/developing-and-testing/using-hot-reload/#server-reloading","text":"Server reloading isn't quite as fully automated. If you make a change in the Server code and save your work, the project will automatically rebuild and launch itself. Once this is complete however you will need to refresh your browser to see any visual changes. If you are using the minimal template, you need to make sure you launch the Server using dotnet watch run rather than just dotnet run . The standard template takes care of this step for you using its FAKE build script. If you have already restored your NuGet dependencies, you can get a little boost in restart speed by using dotnet watch run --no-restore as well.","title":"Server reloading"},{"location":"recipes/javascript/import-js-module/","text":"How do I import a JavaScript module? Sometimes you need to use a JS library directly, instead of using it through a wrapper library that makes it easy to use from F# code. In this case you need to import a module from the library. We will use the react module from the React NPM package as an example here because it is always included as an NPM dependency in SAFE projects. Importing everything from a module In your client code, use the importAll function to import all items from a given module name. open Fable.Core.JsInterop let react : obj = importAll \"react\" Now you can access items contained in the module using the dynamic JS interop provided by Fable. This example just prints the version of React being used. printfn \"React version: %s\" react ? version Import one value from a module To import a single value use the import function instead. You need to provide both the name of the value and the module name. open Fable.Core.JsInterop let reactVersion : string = import \"version\" \"react\" Now you can use this value directly. printfn \"React version: %s\" reactVersion More information See the Fable docs for more ways to import modules and use JavaScript from Fable.","title":"Import a JavaScript module"},{"location":"recipes/javascript/import-js-module/#how-do-i-import-a-javascript-module","text":"Sometimes you need to use a JS library directly, instead of using it through a wrapper library that makes it easy to use from F# code. In this case you need to import a module from the library. We will use the react module from the React NPM package as an example here because it is always included as an NPM dependency in SAFE projects.","title":"How do I import a JavaScript module?"},{"location":"recipes/javascript/import-js-module/#importing-everything-from-a-module","text":"In your client code, use the importAll function to import all items from a given module name. open Fable.Core.JsInterop let react : obj = importAll \"react\" Now you can access items contained in the module using the dynamic JS interop provided by Fable. This example just prints the version of React being used. printfn \"React version: %s\" react ? version","title":"Importing everything from a module"},{"location":"recipes/javascript/import-js-module/#import-one-value-from-a-module","text":"To import a single value use the import function instead. You need to provide both the name of the value and the module name. open Fable.Core.JsInterop let reactVersion : string = import \"version\" \"react\" Now you can use this value directly. printfn \"React version: %s\" reactVersion","title":"Import one value from a module"},{"location":"recipes/javascript/import-js-module/#more-information","text":"See the Fable docs for more ways to import modules and use JavaScript from Fable.","title":"More information"},{"location":"recipes/javascript/third-party-react-package/","text":"How Do I Use a Third Party React Package? To use a third-party React library in a SAFE application, you need to write an F# wrapper around it. There are two ways for doing this \u2013 using Fable.React or using Feliz . Prerequisites This recipe uses the react-number-format NPM package for demonstration purposes. Add it to your Client before continuing. Using Fable.React 1. Create a new file Create an empty file named NumberFormat.fs in the Client project above Index.fs and insert the following statements at the beginning of the file. module NumberFormat open Fable.Core open Fable.Core.JsInterop open Fable.React 2. Define the Props Props represent the props of the React component. In this recipe, we're using the props listed here for react-number-format . We model them in Fable.React using a discriminated union. type Prop = | Value of float | ThousandSeparator of char | OnValueChange of ({| value : string ; floatValue : float Option |} -> unit ) One difference to note is that we use P ascalCase rather than c amelCase. Note that we can model any props here, both simple values and \"event handler\"-style ones. 3. Write the Component Add the following function to the file. Note that the last argument passed into the ofImport function is a list of ReactElements to be used as children of the react component. In this case, we are passing an empty list since we are essentially generating an input HTML element that typically doesn't have children. let numberFormat ( props : Prop list ) : ReactElement = let propsObject = keyValueList CaseRules . LowerFirst props // converts Props to JS object ofImport \"default\" \"react-number-format\" propsObject [] // import the default function/object from react-number-format 4. Use the Component With all these in place, you can use the React element in your client like so: open NumberFormat numberFormat [ Value 123 . OnValueChange ( fun x -> match x . floatValue with | None -> printfn \"NO VALUE (%s)\" x . value | Some v -> printfn \"SOME VALUE %f (%s)\" v x . value ) ThousandSeparator ',' ] Using Feliz 1. Add Feliz If you don't already have Feliz installed, add it to your client . 2. Create a New File Create an empty file named NumberFormat.fs in the Client project above Index.fs and insert the following statements at the beginning of the file. module NumberFormat open Fable.Core.JsInterop open Feliz 3. Wrap the Component Insert the following. This esentially creates a reference to the react-number-format package entry point. let numberFormat : obj = import \"default\" \"react-number-format\" 4. Abstract the Component Add the following type to the file. Each of the static members below corresponds to a prop for react-number-format listed here . The prop.custom function creates a JavaScript prop from a key-value pair that we pass to it in the form of a tuple. The input function is an exception to this ; it acts as the entry point for us to call the React component. type NumberFormat = static member inline value ( number : float option ) = prop . custom ( \"value\" , number ) static member inline onValueChange ( data : {| value : string ; floatValue : float Option |} -> unit ) = prop . custom ( \"onValueChange\" , data ) static member inline thousandSeparator ( char : char ) = prop . custom ( \"thousandSeparator\" , char ) static member inline input props = Interop . reactApi . createElement ( numberFormat , createObj !! props ) 5. Use the Component With all these in place, you can use the React element in your client like so: NumberFormat . input [ NumberFormat . value 123 . NumberFormat . onValueChange ( fun x -> match x . floatValue with | None -> printfn \"NO VALUE (%s)\" x . value | Some v -> printfn \"SOME VALUE %f (%s)\" v x . value ) NumberFormat . thousandSeparator ',' ]","title":"Add Support for a Third Party React Library"},{"location":"recipes/javascript/third-party-react-package/#how-do-i-use-a-third-party-react-package","text":"To use a third-party React library in a SAFE application, you need to write an F# wrapper around it. There are two ways for doing this \u2013 using Fable.React or using Feliz .","title":"How Do I Use a Third Party React Package?"},{"location":"recipes/javascript/third-party-react-package/#prerequisites","text":"This recipe uses the react-number-format NPM package for demonstration purposes. Add it to your Client before continuing.","title":"Prerequisites"},{"location":"recipes/javascript/third-party-react-package/#using-fablereact","text":"","title":"Using Fable.React"},{"location":"recipes/javascript/third-party-react-package/#1-create-a-new-file","text":"Create an empty file named NumberFormat.fs in the Client project above Index.fs and insert the following statements at the beginning of the file. module NumberFormat open Fable.Core open Fable.Core.JsInterop open Fable.React","title":"1. Create a new file"},{"location":"recipes/javascript/third-party-react-package/#2-define-the-props","text":"Props represent the props of the React component. In this recipe, we're using the props listed here for react-number-format . We model them in Fable.React using a discriminated union. type Prop = | Value of float | ThousandSeparator of char | OnValueChange of ({| value : string ; floatValue : float Option |} -> unit ) One difference to note is that we use P ascalCase rather than c amelCase. Note that we can model any props here, both simple values and \"event handler\"-style ones.","title":"2. Define the Props"},{"location":"recipes/javascript/third-party-react-package/#3-write-the-component","text":"Add the following function to the file. Note that the last argument passed into the ofImport function is a list of ReactElements to be used as children of the react component. In this case, we are passing an empty list since we are essentially generating an input HTML element that typically doesn't have children. let numberFormat ( props : Prop list ) : ReactElement = let propsObject = keyValueList CaseRules . LowerFirst props // converts Props to JS object ofImport \"default\" \"react-number-format\" propsObject [] // import the default function/object from react-number-format","title":"3. Write the Component"},{"location":"recipes/javascript/third-party-react-package/#4-use-the-component","text":"With all these in place, you can use the React element in your client like so: open NumberFormat numberFormat [ Value 123 . OnValueChange ( fun x -> match x . floatValue with | None -> printfn \"NO VALUE (%s)\" x . value | Some v -> printfn \"SOME VALUE %f (%s)\" v x . value ) ThousandSeparator ',' ]","title":"4. Use the Component"},{"location":"recipes/javascript/third-party-react-package/#using-feliz","text":"","title":"Using Feliz"},{"location":"recipes/javascript/third-party-react-package/#1-add-feliz","text":"If you don't already have Feliz installed, add it to your client .","title":"1. Add Feliz"},{"location":"recipes/javascript/third-party-react-package/#2-create-a-new-file","text":"Create an empty file named NumberFormat.fs in the Client project above Index.fs and insert the following statements at the beginning of the file. module NumberFormat open Fable.Core.JsInterop open Feliz","title":"2. Create a New File"},{"location":"recipes/javascript/third-party-react-package/#3-wrap-the-component","text":"Insert the following. This esentially creates a reference to the react-number-format package entry point. let numberFormat : obj = import \"default\" \"react-number-format\"","title":"3. Wrap the Component"},{"location":"recipes/javascript/third-party-react-package/#4-abstract-the-component","text":"Add the following type to the file. Each of the static members below corresponds to a prop for react-number-format listed here . The prop.custom function creates a JavaScript prop from a key-value pair that we pass to it in the form of a tuple. The input function is an exception to this ; it acts as the entry point for us to call the React component. type NumberFormat = static member inline value ( number : float option ) = prop . custom ( \"value\" , number ) static member inline onValueChange ( data : {| value : string ; floatValue : float Option |} -> unit ) = prop . custom ( \"onValueChange\" , data ) static member inline thousandSeparator ( char : char ) = prop . custom ( \"thousandSeparator\" , char ) static member inline input props = Interop . reactApi . createElement ( numberFormat , createObj !! props )","title":"4. Abstract the Component"},{"location":"recipes/javascript/third-party-react-package/#5-use-the-component","text":"With all these in place, you can use the React element in your client like so: NumberFormat . input [ NumberFormat . value 123 . NumberFormat . onValueChange ( fun x -> match x . floatValue with | None -> printfn \"NO VALUE (%s)\" x . value | Some v -> printfn \"SOME VALUE %f (%s)\" v x . value ) NumberFormat . thousandSeparator ',' ]","title":"5. Use the Component"},{"location":"recipes/package-management/add-npm-package-to-client/","text":"How do I add an NPM package to the Client? When you want to call a Javascript library from your Client, it is easy to import and reference it using NPM . Run the following command: npm install name-of-package This will download the package into the solution's node_modules folder. You will also see a reference to the package in the Client's package.json file: \"dependencies\" : { \"name-of-package\" : \"^1.0.0\" }","title":"Add an NPM package to the Client"},{"location":"recipes/package-management/add-npm-package-to-client/#how-do-i-add-an-npm-package-to-the-client","text":"When you want to call a Javascript library from your Client, it is easy to import and reference it using NPM . Run the following command: npm install name-of-package This will download the package into the solution's node_modules folder. You will also see a reference to the package in the Client's package.json file: \"dependencies\" : { \"name-of-package\" : \"^1.0.0\" }","title":"How do I add an NPM package to the Client?"},{"location":"recipes/package-management/add-nuget-package-to-client/","text":"How do I add a Nuget package to the Client? Adding packages to the Client project is a very similar process to the Server , with one important difference: Although the Client code is written in F#, at runtime it is converted into Javascript using Fable . Because of this, we must be careful to only reference libraries which are Fable compatible . There are lots of great libraries available to choose from.","title":"Add a Nuget package to the Client"},{"location":"recipes/package-management/add-nuget-package-to-client/#how-do-i-add-a-nuget-package-to-the-client","text":"Adding packages to the Client project is a very similar process to the Server , with one important difference: Although the Client code is written in F#, at runtime it is converted into Javascript using Fable . Because of this, we must be careful to only reference libraries which are Fable compatible . There are lots of great libraries available to choose from.","title":"How do I add a Nuget package to the Client?"},{"location":"recipes/package-management/add-nuget-package-to-server/","text":"How do I add a Nuget package to the Server? You can add nuget packages to the server to give it more capabilities. You can download a wide variety of packages from the official NuGet site . In this example we will add the FsToolkit ErrorHandling package package. I'm using the standard template (Paket) 1. Add the package Navigate to the root directory of your solution and run: dotnet paket add FsToolkit.ErrorHandling -p Server This will add an entry to both the solution paket.dependencies file and the Server project's paket.reference file, as well as update the lock file with the updated dependency graph. Find information on how you can convert your project from nuget to Paket here . For a detailed explanation of package management using Paket, visit the official docs . I'm using the minimal template (NuGet) 1. Navigate to the Server project directory 2. Add the package Run the following command: dotnet add package FsToolkit.ErrorHandling Once you have done this, you will find an element in your fsproj file which looks like this: <ItemGroup> <PackageReference Include= \"FsToolkit.ErrorHandling\" Version= \"1.4.3\" /> </ItemGroup> You can also achieve the same thing using the Visual Studio Package Manager , the VS Mac Package Manager or the Package Manager Console . For a detailed explanation of package management using Nuget, visit the official docs .","title":"Add a NuGet package to the Server"},{"location":"recipes/package-management/add-nuget-package-to-server/#how-do-i-add-a-nuget-package-to-the-server","text":"You can add nuget packages to the server to give it more capabilities. You can download a wide variety of packages from the official NuGet site . In this example we will add the FsToolkit ErrorHandling package package.","title":"How do I add a Nuget package to the Server?"},{"location":"recipes/package-management/add-nuget-package-to-server/#im-using-the-standard-template-paket","text":"","title":"I'm using the standard template (Paket)"},{"location":"recipes/package-management/add-nuget-package-to-server/#1-add-the-package","text":"Navigate to the root directory of your solution and run: dotnet paket add FsToolkit.ErrorHandling -p Server This will add an entry to both the solution paket.dependencies file and the Server project's paket.reference file, as well as update the lock file with the updated dependency graph. Find information on how you can convert your project from nuget to Paket here . For a detailed explanation of package management using Paket, visit the official docs .","title":"1. Add the package"},{"location":"recipes/package-management/add-nuget-package-to-server/#im-using-the-minimal-template-nuget","text":"","title":"I'm using the minimal template (NuGet)"},{"location":"recipes/package-management/add-nuget-package-to-server/#1-navigate-to-the-server-project-directory","text":"","title":"1. Navigate to the Server project directory"},{"location":"recipes/package-management/add-nuget-package-to-server/#2-add-the-package","text":"Run the following command: dotnet add package FsToolkit.ErrorHandling Once you have done this, you will find an element in your fsproj file which looks like this: <ItemGroup> <PackageReference Include= \"FsToolkit.ErrorHandling\" Version= \"1.4.3\" /> </ItemGroup> You can also achieve the same thing using the Visual Studio Package Manager , the VS Mac Package Manager or the Package Manager Console . For a detailed explanation of package management using Nuget, visit the official docs .","title":"2. Add the package"},{"location":"recipes/package-management/migrate-to-paket/","text":"How do I migrate to Paket from NuGet? Paket is a fully featured package manager that acts as an alternative to the NuGet package manager. It can help you reference libraries from NuGet, Git repositories or Http resources. It also provides precise control over your dependencies, separating direct and transitive references and capturing the exact configuration with each commit. You can find out more at the Paket website. Note that the standard template uses Paket by default. This recipe only applies to the minimal template . 1. Create a .NET Tool Manifest The manifest allows others to easily install the tools required to build your application. At the root of your codebase run: dotnet new tool-manifest 2. Install and restore Paket dotnet tool install paket dotnet tool restore This will add three files to your solution, all of which should be committed to source control: paket.dependencies : This will be at the solution root and contains the top level list of dependencies for your project. It is also used to specify any rules such as where they should be downloaded from and which versions etc. paket.lock : This will also be at the solution root and contains the concrete resolution of all direct and transitive dependencies. paket.references : There will be one of these in each project directory. It simply specifies which packages the project requires. 3. Run the Migration Run this command to move existing Nuget references to Paket from your packages.config or .fsproj file: dotnet paket convert-from-nuget For a more detailed explanation of this process see the official migration guide. In the case where you have added a nuget project to a solution which is already using paket, run this command with the option --force . If you are working in Visual Studio and wish to see your Paket files in the Solution Explorer, you will need to add both the paket.lock and any paket.references files created in your project directories during the last step to your solution.","title":"Migrate to Paket from NuGet"},{"location":"recipes/package-management/migrate-to-paket/#how-do-i-migrate-to-paket-from-nuget","text":"Paket is a fully featured package manager that acts as an alternative to the NuGet package manager. It can help you reference libraries from NuGet, Git repositories or Http resources. It also provides precise control over your dependencies, separating direct and transitive references and capturing the exact configuration with each commit. You can find out more at the Paket website. Note that the standard template uses Paket by default. This recipe only applies to the minimal template .","title":"How do I migrate to Paket from NuGet?"},{"location":"recipes/package-management/migrate-to-paket/#1-create-a-net-tool-manifest","text":"The manifest allows others to easily install the tools required to build your application. At the root of your codebase run: dotnet new tool-manifest","title":"1. Create a .NET Tool Manifest"},{"location":"recipes/package-management/migrate-to-paket/#2-install-and-restore-paket","text":"dotnet tool install paket dotnet tool restore This will add three files to your solution, all of which should be committed to source control: paket.dependencies : This will be at the solution root and contains the top level list of dependencies for your project. It is also used to specify any rules such as where they should be downloaded from and which versions etc. paket.lock : This will also be at the solution root and contains the concrete resolution of all direct and transitive dependencies. paket.references : There will be one of these in each project directory. It simply specifies which packages the project requires.","title":"2. Install and restore Paket"},{"location":"recipes/package-management/migrate-to-paket/#3-run-the-migration","text":"Run this command to move existing Nuget references to Paket from your packages.config or .fsproj file: dotnet paket convert-from-nuget For a more detailed explanation of this process see the official migration guide. In the case where you have added a nuget project to a solution which is already using paket, run this command with the option --force . If you are working in Visual Studio and wish to see your Paket files in the Solution Explorer, you will need to add both the paket.lock and any paket.references files created in your project directories during the last step to your solution.","title":"3. Run the Migration"},{"location":"recipes/package-management/migrate-to-yarn/","text":"How do I migrate to Yarn from NPM? Yarn is an alternative Javascript package manager created by Facebook. When it was first released it provided several features which were absent from NPM at the time such as offline caching and deterministic dependency resolution . Today however, NPM has largely gained feature parity with Yarn, although they still do things slightly differently and therefore many people prefer one over the other. The SAFE template uses NPM out of the box, but it is easy to migrate to Yarn if you wish. Switching to Yarn 1. Install Yarn You will need to install Yarn on your machine. Please note: Version 2 of Yarn is not currently supported . 2. Migrate from NPM Simply run the command: yarn 3. Sync package versions If you want to make sure that Yarn is using the same package versions that NPM had in its lock file, run yarn import Once this process is complete you can remove the NPM package-lock.json as it is no longer needed. For more details on migration see the official docs . Running the application Now that you have switched to using Yarn, you will need to modify the way in which the client application is built and launched. The way in which you do this depends on whether you have started with the minimal or full template, as the latter uses FAKE to manage its build process. Launching the application from the minimal template 1. Start the Client Run the command yarn run start 2. Start the Server Navigate to the Server project directory and run: dotnet run Launching the application from the full template 1. Update FAKE build script Open the build.fsx file that is in the root of the solution directory and replace all instances of \"npm\" with \"yarn\" (both in strings and in value names). 2. Update install args Replace Target . create \"InstallClient\" ( fun _ -> yarn \"install\" clientPath ) with Target . create \"InstallClient\" ( fun _ -> yarn \"install --frozen-lockfile\" clientPath ) 3. Launch the application At the root of your solution you can now just run dotnet fake build -t run as usual to launch both the Client and Server at the same time.","title":"Migrate to Yarn from NPM"},{"location":"recipes/package-management/migrate-to-yarn/#how-do-i-migrate-to-yarn-from-npm","text":"Yarn is an alternative Javascript package manager created by Facebook. When it was first released it provided several features which were absent from NPM at the time such as offline caching and deterministic dependency resolution . Today however, NPM has largely gained feature parity with Yarn, although they still do things slightly differently and therefore many people prefer one over the other. The SAFE template uses NPM out of the box, but it is easy to migrate to Yarn if you wish.","title":"How do I migrate to Yarn from NPM?"},{"location":"recipes/package-management/migrate-to-yarn/#switching-to-yarn","text":"","title":"Switching to Yarn"},{"location":"recipes/package-management/migrate-to-yarn/#1-install-yarn","text":"You will need to install Yarn on your machine. Please note: Version 2 of Yarn is not currently supported .","title":"1. Install Yarn"},{"location":"recipes/package-management/migrate-to-yarn/#2-migrate-from-npm","text":"Simply run the command: yarn","title":"2. Migrate from NPM"},{"location":"recipes/package-management/migrate-to-yarn/#3-sync-package-versions","text":"If you want to make sure that Yarn is using the same package versions that NPM had in its lock file, run yarn import Once this process is complete you can remove the NPM package-lock.json as it is no longer needed. For more details on migration see the official docs .","title":"3. Sync package versions"},{"location":"recipes/package-management/migrate-to-yarn/#running-the-application","text":"Now that you have switched to using Yarn, you will need to modify the way in which the client application is built and launched. The way in which you do this depends on whether you have started with the minimal or full template, as the latter uses FAKE to manage its build process.","title":"Running the application"},{"location":"recipes/package-management/migrate-to-yarn/#launching-the-application-from-the-minimal-template","text":"","title":"Launching the application from the minimal template"},{"location":"recipes/package-management/migrate-to-yarn/#1-start-the-client","text":"Run the command yarn run start","title":"1. Start the Client"},{"location":"recipes/package-management/migrate-to-yarn/#2-start-the-server","text":"Navigate to the Server project directory and run: dotnet run","title":"2. Start the Server"},{"location":"recipes/package-management/migrate-to-yarn/#launching-the-application-from-the-full-template","text":"","title":"Launching the application from the full template"},{"location":"recipes/package-management/migrate-to-yarn/#1-update-fake-build-script","text":"Open the build.fsx file that is in the root of the solution directory and replace all instances of \"npm\" with \"yarn\" (both in strings and in value names).","title":"1. Update FAKE build script"},{"location":"recipes/package-management/migrate-to-yarn/#2-update-install-args","text":"Replace Target . create \"InstallClient\" ( fun _ -> yarn \"install\" clientPath ) with Target . create \"InstallClient\" ( fun _ -> yarn \"install --frozen-lockfile\" clientPath )","title":"2. Update install args"},{"location":"recipes/package-management/migrate-to-yarn/#3-launch-the-application","text":"At the root of your solution you can now just run dotnet fake build -t run as usual to launch both the Client and Server at the same time.","title":"3. Launch the application"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/","text":"How do I ensure NPM and Nuget packages stay in sync? SAFE Stack uses Fable bindings, which are NuGet packages that provide idiomatic and type-safe wrappers around native JavaScript APIs. These bindings often rely on third-party JavaScript libraries distributed via the NPM registry. This leads to the problem of keeping both the NPM package in sync with its corresponding NuGet F# wrapper. Femto is a dotnet CLI tool that solves this issue. For in-depth information about Femto, see Introducing Femto . 1. Install Femto Navigate to the root folder of the solution and execute the following command: dotnet tool install femto 2. Analyse Dependencies In the root directory, run the following: dotnet femto ./ src / Client alternatively, you can call femto directly from ./src/Client : cd ./ src / Client dotnet femto This will give you a report of discrepancies between the NuGet packages and the NPM packages for the project, as well as steps to take in order to resolve them. 3. Resolve Dependencies To sync your NPM dependencies with your NuGet dependencies, you can either manually follow the steps returned by step 2 , or resolve them automatically using the following command: dotnet femto ./ src / Client - -resolve Done! Keeping your NPM dependencies in sync with your NuGet packages is now as easy as repeating step 3. Of course, you can instead repeat the step 2 and resolve packages manually, too.","title":"Sync NuGet and NPM Packages"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/#how-do-i-ensure-npm-and-nuget-packages-stay-in-sync","text":"SAFE Stack uses Fable bindings, which are NuGet packages that provide idiomatic and type-safe wrappers around native JavaScript APIs. These bindings often rely on third-party JavaScript libraries distributed via the NPM registry. This leads to the problem of keeping both the NPM package in sync with its corresponding NuGet F# wrapper. Femto is a dotnet CLI tool that solves this issue. For in-depth information about Femto, see Introducing Femto .","title":"How do I ensure NPM and Nuget packages stay in sync?"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/#1-install-femto","text":"Navigate to the root folder of the solution and execute the following command: dotnet tool install femto","title":"1. Install Femto"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/#2-analyse-dependencies","text":"In the root directory, run the following: dotnet femto ./ src / Client alternatively, you can call femto directly from ./src/Client : cd ./ src / Client dotnet femto This will give you a report of discrepancies between the NuGet packages and the NPM packages for the project, as well as steps to take in order to resolve them.","title":"2. Analyse Dependencies"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/#3-resolve-dependencies","text":"To sync your NPM dependencies with your NuGet dependencies, you can either manually follow the steps returned by step 2 , or resolve them automatically using the following command: dotnet femto ./ src / Client - -resolve","title":"3. Resolve Dependencies"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/#done","text":"Keeping your NPM dependencies in sync with your NuGet packages is now as easy as repeating step 3. Of course, you can instead repeat the step 2 and resolve packages manually, too.","title":"Done!"},{"location":"recipes/storage/use-litedb/","text":"How Do I Use LiteDB? The default template uses in-memory storage. This recipe will show you how to replace the in-memory storage with LiteDB in the form of LiteDB.FSharp . If you're using the minimal template, the first steps will show you how to add a LiteDB database; the remaining section of this recipe are designed to work off the default template's starter app. 1. Add LiteDB.FSharp Add the LiteDB.FSharp NuGet package to the server project . 2. Create the database Replace the use of the ResizeArray in the Storage type with a database and collection: open LiteDB.FSharp open LiteDB type Storage () = let database = let mapper = FSharpBsonMapper () let connStr = \"Filename=Todo.db;mode=Exclusive\" new LiteDatabase ( connStr , mapper ) let todos = database . GetCollection < Todo > \"todos\" LiteDb is a file-based database, and will create the file if it does not exist automatically. This will create a database file Todo.db in the Server folder. The option mode=Exclusive is added for MacOS support (see this issue ). See here for more information on connection string arguments. See the official docs for details on constructor arguments. 3. Implement the rest of the repository Replace the implementations of GetTodos and AddTodo as follows: /// Retrieves all todo items. member _ . GetTodos () = todos . FindAll () |> List . ofSeq /// Tries to add a todo item to the collection. member _ . AddTodo ( todo : Todo ) = if Todo . isValid todo . Description then todos . Insert todo |> ignore Ok () else Error \"Invalid todo\" 4. Initialise the database Modify the existing \"priming\" so that it first checks if there are any records in the database before inserting data: if storage . GetTodos () |> Seq . isEmpty then storage . AddTodo ( Todo . create \"Create new SAFE project\" ) |> ignore storage . AddTodo ( Todo . create \"Write your app\" ) |> ignore storage . AddTodo ( Todo . create \"Ship it !!!\" ) |> ignore 5. Make Todo compatible with LiteDb Add the CLIMutable attribute to the Todo record in Shared.fs [< CLIMutable >] type Todo = { Id : Guid Description : string } This is required to allow LiteDB to hydrate (read) data into F# records. All Done! Run the application. You will see that a database has been created in the Server folder and that you are presented with the standard TODO list. Add an item and restart the application; observe that your data is still there.","title":"Quickly add a database"},{"location":"recipes/storage/use-litedb/#how-do-i-use-litedb","text":"The default template uses in-memory storage. This recipe will show you how to replace the in-memory storage with LiteDB in the form of LiteDB.FSharp . If you're using the minimal template, the first steps will show you how to add a LiteDB database; the remaining section of this recipe are designed to work off the default template's starter app.","title":"How Do I Use LiteDB?"},{"location":"recipes/storage/use-litedb/#1-add-litedbfsharp","text":"Add the LiteDB.FSharp NuGet package to the server project .","title":"1. Add LiteDB.FSharp"},{"location":"recipes/storage/use-litedb/#2-create-the-database","text":"Replace the use of the ResizeArray in the Storage type with a database and collection: open LiteDB.FSharp open LiteDB type Storage () = let database = let mapper = FSharpBsonMapper () let connStr = \"Filename=Todo.db;mode=Exclusive\" new LiteDatabase ( connStr , mapper ) let todos = database . GetCollection < Todo > \"todos\" LiteDb is a file-based database, and will create the file if it does not exist automatically. This will create a database file Todo.db in the Server folder. The option mode=Exclusive is added for MacOS support (see this issue ). See here for more information on connection string arguments. See the official docs for details on constructor arguments.","title":"2. Create the database"},{"location":"recipes/storage/use-litedb/#3-implement-the-rest-of-the-repository","text":"Replace the implementations of GetTodos and AddTodo as follows: /// Retrieves all todo items. member _ . GetTodos () = todos . FindAll () |> List . ofSeq /// Tries to add a todo item to the collection. member _ . AddTodo ( todo : Todo ) = if Todo . isValid todo . Description then todos . Insert todo |> ignore Ok () else Error \"Invalid todo\"","title":"3. Implement the rest of the repository"},{"location":"recipes/storage/use-litedb/#4-initialise-the-database","text":"Modify the existing \"priming\" so that it first checks if there are any records in the database before inserting data: if storage . GetTodos () |> Seq . isEmpty then storage . AddTodo ( Todo . create \"Create new SAFE project\" ) |> ignore storage . AddTodo ( Todo . create \"Write your app\" ) |> ignore storage . AddTodo ( Todo . create \"Ship it !!!\" ) |> ignore","title":"4. Initialise the database"},{"location":"recipes/storage/use-litedb/#5-make-todo-compatible-with-litedb","text":"Add the CLIMutable attribute to the Todo record in Shared.fs [< CLIMutable >] type Todo = { Id : Guid Description : string } This is required to allow LiteDB to hydrate (read) data into F# records.","title":"5. Make Todo compatible with LiteDb"},{"location":"recipes/storage/use-litedb/#all-done","text":"Run the application. You will see that a database has been created in the Server folder and that you are presented with the standard TODO list. Add an item and restart the application; observe that your data is still there.","title":"All Done!"},{"location":"recipes/ui/add-bulma/","text":"How do I add Bulma to a SAFE project? Bulma is a free open-source UI framework based on flex-box that helps you create modern and responsive layouts. When it comes to using Bulma as your front-end library on a SAFE Stack web application, you have two options. Fulma : Fulma provides a wrapper around Bulma for fable-react. Feliz.Bulma : Feliz.Bulma is a Bulma wrapper for Feliz . By adding either of these to your SAFE project alongside the Bulma stylesheet or the Bulma NPM package , you can take full advantage of Bulma. Using Fulma Add the Fulma NuGet package to the solution . Start using Fulma components in your F# files. open Fulma Button . button [] [ str \"Click me!\" ] Using Feliz.Bulma Add the Feliz.Bulma Nuget package to the solution . Start using Feliz.Bulma components in your F# files. open Feliz.Bulma Bulma . button . button [ str \"Click me!\" ]","title":"Add Bulma support"},{"location":"recipes/ui/add-bulma/#how-do-i-add-bulma-to-a-safe-project","text":"Bulma is a free open-source UI framework based on flex-box that helps you create modern and responsive layouts. When it comes to using Bulma as your front-end library on a SAFE Stack web application, you have two options. Fulma : Fulma provides a wrapper around Bulma for fable-react. Feliz.Bulma : Feliz.Bulma is a Bulma wrapper for Feliz . By adding either of these to your SAFE project alongside the Bulma stylesheet or the Bulma NPM package , you can take full advantage of Bulma.","title":"How do I add Bulma to a SAFE project?"},{"location":"recipes/ui/add-bulma/#using-fulma","text":"Add the Fulma NuGet package to the solution . Start using Fulma components in your F# files. open Fulma Button . button [] [ str \"Click me!\" ]","title":"Using Fulma"},{"location":"recipes/ui/add-bulma/#using-felizbulma","text":"Add the Feliz.Bulma Nuget package to the solution . Start using Feliz.Bulma components in your F# files. open Feliz.Bulma Bulma . button . button [ str \"Click me!\" ]","title":"Using Feliz.Bulma"},{"location":"recipes/ui/add-feliz/","text":"How do I add Feliz to a SAFE project? Feliz is a wrapper for the base React DSL library that emphasises consistency, lightweight formatting, discoverable attributes and full type-safety. It is quick and easy to add Feliz to your SAFE application and start using it. Using Feliz Add Feliz to your project Start using Feliz in your code. open Feliz Html . button [ prop . style [ style . marginLeft 5 ] prop . onClick ( fun _ -> setCount ( count - 1 )) prop . text \"Decrement\" ]","title":"Add Feliz support"},{"location":"recipes/ui/add-feliz/#how-do-i-add-feliz-to-a-safe-project","text":"Feliz is a wrapper for the base React DSL library that emphasises consistency, lightweight formatting, discoverable attributes and full type-safety. It is quick and easy to add Feliz to your SAFE application and start using it.","title":"How do I add Feliz to a SAFE project?"},{"location":"recipes/ui/add-feliz/#using-feliz","text":"Add Feliz to your project Start using Feliz in your code. open Feliz Html . button [ prop . style [ style . marginLeft 5 ] prop . onClick ( fun _ -> setCount ( count - 1 )) prop . text \"Decrement\" ]","title":"Using Feliz"},{"location":"recipes/ui/add-fontawesome/","text":"How Do I Use FontAwesome? FontAwesome is the most popular icon set out there and will provide you with a handful of free icons as well as a multitude of premium icons. The standard SAFE template has out-of-the-box support for FontAwesome. You can just start using it in your Client code like so: open Fable.FontAwesome Icon . icon [ Fa . i [ Fa . Solid . Star ] [ ] ] This will display a solid star icon. I am Using the Minimal Template If you\u2019re using the minimal template, there are a couple of things to do before you can start using FontAwesome. 1. The NuGet Package Add Fable.FontAwesome.Free NuGet Package to the Client project. See How do I add a Nuget package to the Client? . 2. The CDN Link Open the index.html file and add the following line to the head element: < link rel = \"stylesheet\" href = \"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css\" > All Done! Now you can use FontAwesome in your code","title":"Add FontAwesome support"},{"location":"recipes/ui/add-fontawesome/#how-do-i-use-fontawesome","text":"FontAwesome is the most popular icon set out there and will provide you with a handful of free icons as well as a multitude of premium icons. The standard SAFE template has out-of-the-box support for FontAwesome. You can just start using it in your Client code like so: open Fable.FontAwesome Icon . icon [ Fa . i [ Fa . Solid . Star ] [ ] ] This will display a solid star icon.","title":"How Do I Use FontAwesome?"},{"location":"recipes/ui/add-fontawesome/#i-am-using-the-minimal-template","text":"If you\u2019re using the minimal template, there are a couple of things to do before you can start using FontAwesome.","title":"I am Using the Minimal Template"},{"location":"recipes/ui/add-fontawesome/#1-the-nuget-package","text":"Add Fable.FontAwesome.Free NuGet Package to the Client project. See How do I add a Nuget package to the Client? .","title":"1. The NuGet Package"},{"location":"recipes/ui/add-fontawesome/#2-the-cdn-link","text":"Open the index.html file and add the following line to the head element: < link rel = \"stylesheet\" href = \"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css\" >","title":"2. The CDN Link"},{"location":"recipes/ui/add-fontawesome/#all-done","text":"Now you can use FontAwesome in your code","title":"All Done!"},{"location":"recipes/ui/add-style/","text":"How Do I Use stylesheets with SAFE? If you wish to use your own CSS or SASS stylesheets with SAFE apps, you can embed either through webpack. The template already includes all required NPM packages you may need, so you will only need to configure webpack to reference your stylesheet and include in the outputs. Adding the Stylesheet First, create a CSS file in the src/Client folder of your solution e.g style.css . The same approach can be taken for .scss files. Configuring WebPack I'm using the Standard Template 1. Link to the stylesheet Inside the webpack.config.js file, add the following variable to the CONFIG object, which points to the style file you created previously. cssEntry : './src/Client/style.css' , 2. Embed CSS into outputs Find the entry field in the module.exports object at the bottom of the file, and replace it with the following: entry : isProduction ? { app : [ resolve ( CONFIG . fsharpEntry ), resolve ( CONFIG . cssEntry )] } : { app : resolve ( CONFIG . fsharpEntry ), style : resolve ( CONFIG . cssEntry ) }, This combines the css and F# outputs into a single bundle for production, and separately for dev. I'm using the Minimal Template 1. Embed CSS into outputs Find the entry field in the module.exports object at the bottom of the file, and replace it with the following: entry : { app : [ resolve ( './src/Client/Client.fsproj' ), resolve ( './src/Client/style.css' ) ] }, There you have it! You can now style your app by writing to the style.css file.","title":"Add Stylesheet support"},{"location":"recipes/ui/add-style/#how-do-i-use-stylesheets-with-safe","text":"If you wish to use your own CSS or SASS stylesheets with SAFE apps, you can embed either through webpack. The template already includes all required NPM packages you may need, so you will only need to configure webpack to reference your stylesheet and include in the outputs.","title":"How Do I Use stylesheets with SAFE?"},{"location":"recipes/ui/add-style/#adding-the-stylesheet","text":"First, create a CSS file in the src/Client folder of your solution e.g style.css . The same approach can be taken for .scss files.","title":"Adding the Stylesheet"},{"location":"recipes/ui/add-style/#configuring-webpack","text":"","title":"Configuring WebPack"},{"location":"recipes/ui/add-style/#im-using-the-standard-template","text":"","title":"I'm using the Standard Template"},{"location":"recipes/ui/add-style/#1-link-to-the-stylesheet","text":"Inside the webpack.config.js file, add the following variable to the CONFIG object, which points to the style file you created previously. cssEntry : './src/Client/style.css' ,","title":"1. Link to the stylesheet"},{"location":"recipes/ui/add-style/#2-embed-css-into-outputs","text":"Find the entry field in the module.exports object at the bottom of the file, and replace it with the following: entry : isProduction ? { app : [ resolve ( CONFIG . fsharpEntry ), resolve ( CONFIG . cssEntry )] } : { app : resolve ( CONFIG . fsharpEntry ), style : resolve ( CONFIG . cssEntry ) }, This combines the css and F# outputs into a single bundle for production, and separately for dev.","title":"2. Embed CSS into outputs"},{"location":"recipes/ui/add-style/#im-using-the-minimal-template","text":"","title":"I'm using the Minimal Template"},{"location":"recipes/ui/add-style/#1-embed-css-into-outputs","text":"Find the entry field in the module.exports object at the bottom of the file, and replace it with the following: entry : { app : [ resolve ( './src/Client/Client.fsproj' ), resolve ( './src/Client/style.css' ) ] },","title":"1. Embed CSS into outputs"},{"location":"recipes/ui/add-style/#there-you-have-it","text":"You can now style your app by writing to the style.css file.","title":"There you have it!"},{"location":"recipes/ui/cdn-to-npm/","text":"How do I migrate from a CDN stylesheet to an NPM package? Though the SAFE template default for referencing a stylesheet is to use a CDN, it\u2019s quite reasonable to want to use an NPM package instead. One common case is that it enables you to further customise Bulma themes by overriding Sass variables. 1. Remove the CDN Reference Find the following line in src/Client/index.html and delete it before moving on: < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css\" > 2. Add the NPM Package Go ahead and add the Bulma NPM package to your project. See: How do I add an NPM package to the client? 3. Load the Stylesheets There are two ways for loading the stylesheets: Fable Interop A quick and easy way to reference this NPM package in an F# file is to insert the following couple of lines: open Fable.Core.JsInterop importAll \"bulma/bulma.sass\" You can use this approach for any NPM package. b. Using Sass Add a Sass stylesheet to your project using this recipe . Add the following line to your Sass file to bring in Bulma @import \"~bulma/bulma.sass\"","title":"Migrate from a CDN stylesheet to an NPM package"},{"location":"recipes/ui/cdn-to-npm/#how-do-i-migrate-from-a-cdn-stylesheet-to-an-npm-package","text":"Though the SAFE template default for referencing a stylesheet is to use a CDN, it\u2019s quite reasonable to want to use an NPM package instead. One common case is that it enables you to further customise Bulma themes by overriding Sass variables.","title":"How do I migrate from a CDN stylesheet to an NPM package?"},{"location":"recipes/ui/cdn-to-npm/#1-remove-the-cdn-reference","text":"Find the following line in src/Client/index.html and delete it before moving on: < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css\" >","title":"1. Remove the CDN Reference"},{"location":"recipes/ui/cdn-to-npm/#2-add-the-npm-package","text":"Go ahead and add the Bulma NPM package to your project. See: How do I add an NPM package to the client?","title":"2. Add the NPM Package"},{"location":"recipes/ui/cdn-to-npm/#3-load-the-stylesheets","text":"There are two ways for loading the stylesheets:","title":"3. Load the Stylesheets"},{"location":"recipes/ui/cdn-to-npm/#fable-interop","text":"A quick and easy way to reference this NPM package in an F# file is to insert the following couple of lines: open Fable.Core.JsInterop importAll \"bulma/bulma.sass\" You can use this approach for any NPM package.","title":"Fable Interop"},{"location":"recipes/ui/cdn-to-npm/#b-using-sass","text":"Add a Sass stylesheet to your project using this recipe . Add the following line to your Sass file to bring in Bulma @import \"~bulma/bulma.sass\"","title":"b. Using Sass"},{"location":"recipes/ui/use-different-bulma-themes/","text":"How Do I Use Different Bulma Themes? Bulmaswatch Bulmaswatch is a great website for finding free Bulma themes. However, once you decide on what theme to use, visit this website to get a CDN link to its CSS file. For this recipe, I will use the Nuclear theme . I am Using the Standard Template The standard template uses a CDN (Content Delivery Network) link to reference the Bulma theme that it uses. Changing the theme then, is as simple as changing this link. Since the class names Bulma uses to style HTML elements remain the same, we don\u2019t need to change anything else. 1. Find the Link In your index.html , find the line that references the Bulma stylesheet that\u2019s used in the template through a CDN link. It will look like the following: < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css\" > 2. Change the Link Go ahead and replace this link with the link to the theme that you want to use, which in my case is Nuclear: < link rel = \"stylesheet\" href = \"https://cdnjs.cloudflare.com/ajax/libs/bulmaswatch/0.8.1/nuclear/bulmaswatch.min.css\" > I am Using the Minimal Template 1. Add Link to CDN In your index.html , add the following line anywhere between the opening and closing head tags: < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css\" > 2. Add Fulma or Feliz.Bulma to the Solution Read this recipe for the rest of the instructions. And that\u2019s it. You should now see your app styled in accordance with the Bulma theme you\u2019ve just switched to.","title":"Use different Bulma Themes"},{"location":"recipes/ui/use-different-bulma-themes/#how-do-i-use-different-bulma-themes","text":"","title":"How Do I Use Different Bulma Themes?"},{"location":"recipes/ui/use-different-bulma-themes/#bulmaswatch","text":"Bulmaswatch is a great website for finding free Bulma themes. However, once you decide on what theme to use, visit this website to get a CDN link to its CSS file. For this recipe, I will use the Nuclear theme .","title":"Bulmaswatch"},{"location":"recipes/ui/use-different-bulma-themes/#i-am-using-the-standard-template","text":"The standard template uses a CDN (Content Delivery Network) link to reference the Bulma theme that it uses. Changing the theme then, is as simple as changing this link. Since the class names Bulma uses to style HTML elements remain the same, we don\u2019t need to change anything else.","title":"I am Using the Standard Template"},{"location":"recipes/ui/use-different-bulma-themes/#1-find-the-link","text":"In your index.html , find the line that references the Bulma stylesheet that\u2019s used in the template through a CDN link. It will look like the following: < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css\" >","title":"1. Find the Link"},{"location":"recipes/ui/use-different-bulma-themes/#2-change-the-link","text":"Go ahead and replace this link with the link to the theme that you want to use, which in my case is Nuclear: < link rel = \"stylesheet\" href = \"https://cdnjs.cloudflare.com/ajax/libs/bulmaswatch/0.8.1/nuclear/bulmaswatch.min.css\" >","title":"2. Change the Link"},{"location":"recipes/ui/use-different-bulma-themes/#i-am-using-the-minimal-template","text":"","title":"I am Using the Minimal Template"},{"location":"recipes/ui/use-different-bulma-themes/#1-add-link-to-cdn","text":"In your index.html , add the following line anywhere between the opening and closing head tags: < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css\" >","title":"1. Add Link to CDN"},{"location":"recipes/ui/use-different-bulma-themes/#2-add-fulma-or-felizbulma-to-the-solution","text":"Read this recipe for the rest of the instructions. And that\u2019s it. You should now see your app styled in accordance with the Bulma theme you\u2019ve just switched to.","title":"2. Add Fulma or Feliz.Bulma to the Solution"},{"location":"recipes/upgrading/v1-to-v2/","text":"How do I upgrade from SAFE v1 to v2? There have been a number of changes between the first and second major versions of the SAFE template. This guide shows you how to upgrade your v1 project to v2. If you haven't done so already then you will need to install the prequisites listed in the Quick Start guide. Terminology for this Recipe: \"Overwrite\" : Take the file from the \"new\" V2 template and copy it over the equivalent file in your existing project. \"Delete\" : Delete the file from your existing project. It is no longer required. \"Add\" : Add the file to your existing project. It is a new file added in V2. 1. Install the v2 template Download and install the latest SAFE Stack V2 template by running the following command: dotnet new -i SAFE.Template 2. Create a v2 project Create a new SAFE project in the safetemp folder. We will use this as a basis for our conversion. dotnet new SAFE - o safetemp 3. Branch your code We advise committing or stashing any unsaved changes to your code and making a new branch to perform the upgrade. You can then test it in isolation and then safely merge back in. 4. Update dotnet tools This file lists any custom dotnet tools used. Overwrite the .config/dotnet-tools.json file. Important ! If you have installed extra dotnet tools,you will need to add them back in manually. 4. Replace Yarn with NPM The v2 template no longer uses Yarn to manage JavaScript dependencies, and instead uses NPM. Delete the yarn.lock file. Overwrite the package.json file. Overwrite the package-lock.json file. Important ! If you have installed extra NPM packages, you will need to add them back in manually. If you have added any extra NPM packages, run this command to generate a new package-lock.json . npm install 5. Update Paket dependencies Overwrite the paket.dependencies file in the root of the solution. Overwrite the paket.lock file. Overwrite all paket.references files. Important If you have installed extra NuGet packages, you will need to add them back in manually to the dependencies and references files. There are no longer separate groups for the Client and Server dependency graphs. Simply include any custom packages in the main group. Run paket to update project references: dotnet paket install If you have added any extra NuGet packages, this command will also generate a new paket.lock file. 6. Update FAKE build script Overwrite the build.fsx FAKE script. Important If you have made any modifications to the build script e.g. extra targets, you will need to add them back in manually. The v2 FAKE script includes targets which build its Client and Server Test projects. If you are not planning on importing the Test projects to the v1 project you are upgrading then you can remove these targets. The v2 FAKE script includes a target for Azure deployment using Farmer. If you are not using Azure deployments, you can safely delete this target. 7. Update webpack config Overwrite the webpack.config.js file. Important If you have made any modifications to the webpack file, you will need to apply them back in manually. If you were using a CSS files, make sure to follow the Stylesheet recipe to add them back in. 8. Switch to a project for Shared files The v1 template used shared files to allow code reuse between the Server and Client. The v2 template now has a dedicated project for shared content. Add a new .Net Standard project to the solution by running cd src dotnet new ClassLib -lang F# -o Shared cd .. dotnet sln add src/Shared Remove the Library.fs module from the project and include any shared files you have been using (such as Shared.fs ). Reference the Shared project from the Server and Client projects (and any others which need to access shared content): cd src dotnet add Client reference Shared dotnet add Server reference Shared 9. Update Saturn application Open the Server.fs module at the root of the Server project (or whatever module contains your Saturn application expression). Delete the following content: let tryGetEnv key = match Environment . GetEnvironmentVariable key with | x when String . IsNullOrWhiteSpace x -> None | x -> Some x let publicPath = Path . GetFullPath \"../Client/public\" let port = \"SERVER_PORT\" |> tryGetEnv |> Option . map uint16 |> Option . defaultValue 8085us In the Saturn application expression, overwrite url ( \"http://0.0.0.0:\" + port . ToString () + \"/\" ) use_static publicPath with url \"http://0.0.0.0:8085\" use_static \"public\" 10. Check that it runs Run dotnet fake build -t run at the root of the solution to launch the app and check everything is working as expected. If you have problems loading your website, carefully check that you haven't missed out any javascript or nuget packages when overwriting the paket and package files. The console output will usually give you a good guide if this is the case.","title":"Upgrade from V1 to V2"},{"location":"recipes/upgrading/v1-to-v2/#how-do-i-upgrade-from-safe-v1-to-v2","text":"There have been a number of changes between the first and second major versions of the SAFE template. This guide shows you how to upgrade your v1 project to v2. If you haven't done so already then you will need to install the prequisites listed in the Quick Start guide.","title":"How do I upgrade from SAFE v1 to v2?"},{"location":"recipes/upgrading/v1-to-v2/#terminology-for-this-recipe","text":"\"Overwrite\" : Take the file from the \"new\" V2 template and copy it over the equivalent file in your existing project. \"Delete\" : Delete the file from your existing project. It is no longer required. \"Add\" : Add the file to your existing project. It is a new file added in V2.","title":"Terminology for this Recipe:"},{"location":"recipes/upgrading/v1-to-v2/#1-install-the-v2-template","text":"Download and install the latest SAFE Stack V2 template by running the following command: dotnet new -i SAFE.Template","title":"1. Install the v2 template"},{"location":"recipes/upgrading/v1-to-v2/#2-create-a-v2-project","text":"Create a new SAFE project in the safetemp folder. We will use this as a basis for our conversion. dotnet new SAFE - o safetemp","title":"2. Create a v2 project"},{"location":"recipes/upgrading/v1-to-v2/#3-branch-your-code","text":"We advise committing or stashing any unsaved changes to your code and making a new branch to perform the upgrade. You can then test it in isolation and then safely merge back in.","title":"3. Branch your code"},{"location":"recipes/upgrading/v1-to-v2/#4-update-dotnet-tools","text":"This file lists any custom dotnet tools used. Overwrite the .config/dotnet-tools.json file. Important ! If you have installed extra dotnet tools,you will need to add them back in manually.","title":"4. Update dotnet tools"},{"location":"recipes/upgrading/v1-to-v2/#4-replace-yarn-with-npm","text":"The v2 template no longer uses Yarn to manage JavaScript dependencies, and instead uses NPM. Delete the yarn.lock file. Overwrite the package.json file. Overwrite the package-lock.json file. Important ! If you have installed extra NPM packages, you will need to add them back in manually. If you have added any extra NPM packages, run this command to generate a new package-lock.json . npm install","title":"4. Replace Yarn with NPM"},{"location":"recipes/upgrading/v1-to-v2/#5-update-paket-dependencies","text":"Overwrite the paket.dependencies file in the root of the solution. Overwrite the paket.lock file. Overwrite all paket.references files. Important If you have installed extra NuGet packages, you will need to add them back in manually to the dependencies and references files. There are no longer separate groups for the Client and Server dependency graphs. Simply include any custom packages in the main group. Run paket to update project references: dotnet paket install If you have added any extra NuGet packages, this command will also generate a new paket.lock file.","title":"5. Update Paket dependencies"},{"location":"recipes/upgrading/v1-to-v2/#6-update-fake-build-script","text":"Overwrite the build.fsx FAKE script. Important If you have made any modifications to the build script e.g. extra targets, you will need to add them back in manually. The v2 FAKE script includes targets which build its Client and Server Test projects. If you are not planning on importing the Test projects to the v1 project you are upgrading then you can remove these targets. The v2 FAKE script includes a target for Azure deployment using Farmer. If you are not using Azure deployments, you can safely delete this target.","title":"6. Update FAKE build script"},{"location":"recipes/upgrading/v1-to-v2/#7-update-webpack-config","text":"Overwrite the webpack.config.js file. Important If you have made any modifications to the webpack file, you will need to apply them back in manually. If you were using a CSS files, make sure to follow the Stylesheet recipe to add them back in.","title":"7. Update webpack config"},{"location":"recipes/upgrading/v1-to-v2/#8-switch-to-a-project-for-shared-files","text":"The v1 template used shared files to allow code reuse between the Server and Client. The v2 template now has a dedicated project for shared content. Add a new .Net Standard project to the solution by running cd src dotnet new ClassLib -lang F# -o Shared cd .. dotnet sln add src/Shared Remove the Library.fs module from the project and include any shared files you have been using (such as Shared.fs ). Reference the Shared project from the Server and Client projects (and any others which need to access shared content): cd src dotnet add Client reference Shared dotnet add Server reference Shared","title":"8. Switch to a project for Shared files"},{"location":"recipes/upgrading/v1-to-v2/#9-update-saturn-application","text":"Open the Server.fs module at the root of the Server project (or whatever module contains your Saturn application expression). Delete the following content: let tryGetEnv key = match Environment . GetEnvironmentVariable key with | x when String . IsNullOrWhiteSpace x -> None | x -> Some x let publicPath = Path . GetFullPath \"../Client/public\" let port = \"SERVER_PORT\" |> tryGetEnv |> Option . map uint16 |> Option . defaultValue 8085us In the Saturn application expression, overwrite url ( \"http://0.0.0.0:\" + port . ToString () + \"/\" ) use_static publicPath with url \"http://0.0.0.0:8085\" use_static \"public\"","title":"9. Update Saturn application"},{"location":"recipes/upgrading/v1-to-v2/#10-check-that-it-runs","text":"Run dotnet fake build -t run at the root of the solution to launch the app and check everything is working as expected. If you have problems loading your website, carefully check that you haven't missed out any javascript or nuget packages when overwriting the paket and package files. The console output will usually give you a good guide if this is the case.","title":"10. Check that it runs"}]}